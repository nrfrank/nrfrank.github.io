{
  "version": 3,
  "sources": ["../../../src/optimizer/transforms/extract-prefix.js"],
  "sourcesContent": ["import {alternativeContainerTypes} from '../../parser/node-utils.js';\nimport {createAlternative, createGroup, NodeTypes} from '../../parser/parse.js';\n\n/**\nExtract nodes at the start of every alternative into a prefix.\nAlso works within groups.\n- `^aa|^abb|^ac` -> `^a(?:a|bb|c)`\n- `aa|aa|aa` -> `aa`\n- `a|b|c` -> `a|b|c` (no common prefix)\n*/\nconst extractPrefix = {\n  '*'({node}) {\n    if (!alternativeContainerTypes.has(node.type) || node.alternatives.length < 2) {\n      return;\n    }\n    const prefixNodes = [];\n    let passedSharedPrefix = false;\n    let i = 0;\n    while (!passedSharedPrefix) {\n      prefixNodes[i] = node.alternatives[0].elements[i];\n      for (const alt of node.alternatives) {\n        const kid = alt.elements[i];\n        if (!kid || !isAllowedSimpleType(kid.type) || !isNodeEqual(kid, prefixNodes[i])) {\n          passedSharedPrefix = true;\n          break;\n        }\n      }\n      i++;\n    }\n    prefixNodes.pop();\n    if (!prefixNodes.length) {\n      return;\n    }\n    for (const alt of node.alternatives) {\n      alt.elements = alt.elements.slice(prefixNodes.length);\n    }\n    const newContents = createAlternative();\n    newContents.elements = [...prefixNodes];\n    const suffixGroup = createGroup();\n    suffixGroup.alternatives = node.alternatives;\n    if (!suffixGroup.alternatives.every(alt => !alt.elements.length)) {\n      newContents.elements.push(suffixGroup);\n    }\n    node.alternatives = [newContents];\n  },\n};\n\nfunction isAllowedSimpleType(type) {\n  return (\n    type === NodeTypes.Assertion ||\n    type === NodeTypes.Character ||\n    type === NodeTypes.CharacterSet\n  );\n}\n\n// [TODO] Add support for more node types and move to `src/parser/`\nfunction isNodeEqual(a, b) {\n  if (a.type !== b.type) {\n    return false;\n  }\n  if (a.type === NodeTypes.Assertion || a.type === NodeTypes.CharacterSet) {\n    return a.kind === b.kind && a.negate === b.negate;\n  }\n  if (a.type === NodeTypes.Character) {\n    return a.value === b.value;\n  }\n  // Only supports types from `isAllowedSimpleType`\n  throw new Error(`Unexpected node type \"${a.type}\"`);\n}\n\nexport {\n  extractPrefix,\n  isAllowedSimpleType,\n  isNodeEqual,\n};\n"],
  "mappings": "aAAA,OAAQ,6BAAAA,MAAgC,6BACxC,OAAQ,qBAAAC,EAAmB,eAAAC,EAAa,aAAAC,MAAgB,wBASxD,MAAMC,EAAgB,CACpB,IAAI,CAAC,KAAAC,CAAI,EAAG,CACV,GAAI,CAACL,EAA0B,IAAIK,EAAK,IAAI,GAAKA,EAAK,aAAa,OAAS,EAC1E,OAEF,MAAMC,EAAc,CAAC,EACrB,IAAIC,EAAqB,GACrBC,EAAI,EACR,KAAO,CAACD,GAAoB,CAC1BD,EAAYE,CAAC,EAAIH,EAAK,aAAa,CAAC,EAAE,SAASG,CAAC,EAChD,UAAWC,KAAOJ,EAAK,aAAc,CACnC,MAAMK,EAAMD,EAAI,SAASD,CAAC,EAC1B,GAAI,CAACE,GAAO,CAACC,EAAoBD,EAAI,IAAI,GAAK,CAACE,EAAYF,EAAKJ,EAAYE,CAAC,CAAC,EAAG,CAC/ED,EAAqB,GACrB,KACF,CACF,CACAC,GACF,CAEA,GADAF,EAAY,IAAI,EACZ,CAACA,EAAY,OACf,OAEF,UAAWG,KAAOJ,EAAK,aACrBI,EAAI,SAAWA,EAAI,SAAS,MAAMH,EAAY,MAAM,EAEtD,MAAMO,EAAcZ,EAAkB,EACtCY,EAAY,SAAW,CAAC,GAAGP,CAAW,EACtC,MAAMQ,EAAcZ,EAAY,EAChCY,EAAY,aAAeT,EAAK,aAC3BS,EAAY,aAAa,MAAML,GAAO,CAACA,EAAI,SAAS,MAAM,GAC7DI,EAAY,SAAS,KAAKC,CAAW,EAEvCT,EAAK,aAAe,CAACQ,CAAW,CAClC,CACF,EAEA,SAASF,EAAoBI,EAAM,CACjC,OACEA,IAASZ,EAAU,WACnBY,IAASZ,EAAU,WACnBY,IAASZ,EAAU,YAEvB,CAGA,SAASS,EAAYI,EAAGC,EAAG,CACzB,GAAID,EAAE,OAASC,EAAE,KACf,MAAO,GAET,GAAID,EAAE,OAASb,EAAU,WAAaa,EAAE,OAASb,EAAU,aACzD,OAAOa,EAAE,OAASC,EAAE,MAAQD,EAAE,SAAWC,EAAE,OAE7C,GAAID,EAAE,OAASb,EAAU,UACvB,OAAOa,EAAE,QAAUC,EAAE,MAGvB,MAAM,IAAI,MAAM,yBAAyBD,EAAE,IAAI,GAAG,CACpD,CAEA,OACEZ,KAAA,cACAO,KAAA,oBACAC,KAAA",
  "names": ["alternativeContainerTypes", "createAlternative", "createGroup", "NodeTypes", "extractPrefix", "node", "prefixNodes", "passedSharedPrefix", "i", "alt", "kid", "isAllowedSimpleType", "isNodeEqual", "newContents", "suffixGroup", "type", "a", "b"]
}
