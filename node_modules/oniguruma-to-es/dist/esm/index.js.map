{
  "version": 3,
  "sources": ["../../src/utils.js", "../../src/options.js", "../../src/unicode.js", "../../src/transform.js", "../../src/generate.js", "../../src/subclass.js", "../../src/index.js"],
  "sourcesContent": ["import {EsVersion, Target} from './options.js';\n\nconst cp = String.fromCodePoint;\nconst r = String.raw;\n\nconst envFlags = {\n  flagGroups: (() => {\n    try {\n      new RegExp('(?i:)');\n    } catch {\n      return false;\n    }\n    return true;\n  })(),\n  unicodeSets: (() => {\n    try {\n      new RegExp('', 'v');\n    } catch {\n      return false;\n    }\n    return true;\n  })(),\n};\n// Detect WebKit bug: <github.com/slevithan/oniguruma-to-es/issues/30>\nenvFlags.literalHyphenIncorrectlyCreatesRange = (() => {\n  if (!envFlags.unicodeSets) {\n    return false;\n  }\n  try {\n    new RegExp(r`[\\d\\-a]`, 'v');\n  } catch {\n    return true;\n  }\n  return false;\n})();\n\nfunction getNewCurrentFlags(current, {enable, disable}) {\n  return {\n    dotAll: !disable?.dotAll && !!(enable?.dotAll || current.dotAll),\n    ignoreCase: !disable?.ignoreCase && !!(enable?.ignoreCase || current.ignoreCase),\n  };\n}\n\nfunction getOrInsert(map, key, defaultValue) {\n  if (!map.has(key)) {\n    map.set(key, defaultValue);\n  }\n  return map.get(key);\n}\n\n/**\n@param {keyof Target} target\n@param {keyof Target} min\n@returns {boolean}\n*/\nfunction isMinTarget(target, min) {\n  return EsVersion[target] >= EsVersion[min];\n}\n\nfunction throwIfNot(value, msg) {\n  if (!value) {\n    throw new Error(msg ?? 'Value expected');\n  }\n  return value;\n}\n\nexport {\n  cp,\n  envFlags,\n  getNewCurrentFlags,\n  getOrInsert,\n  isMinTarget,\n  r,\n  throwIfNot,\n};\n", "import {envFlags} from './utils.js';\n\nconst Accuracy = /** @type {const} */ ({\n  default: 'default',\n  strict: 'strict',\n});\n\nconst EsVersion = {\n  ES2025: 2025,\n  ES2024: 2024,\n  ES2018: 2018,\n};\n\nconst Target = /** @type {const} */ ({\n  auto: 'auto',\n  ES2025: 'ES2025',\n  ES2024: 'ES2024',\n  ES2018: 'ES2018',\n});\n\n/**\nReturns a complete set of options, with default values set for options that weren't provided.\n@param {import('.').ToRegExpOptions} [options]\n@returns {Required<import('.').ToRegExpOptions>}\n*/\nfunction getOptions(options = {}) {\n  if ({}.toString.call(options) !== '[object Object]') {\n    throw new Error('Unexpected options');\n  }\n  if (options.target !== undefined && !Target[options.target]) {\n    throw new Error(`Unexpected target \"${options.target}\"`)\n  }\n  // Set default values\n  const opts = {\n    // Sets the level of emulation rigor/strictness.\n    accuracy: 'default',\n    // Disables advanced emulation that relies on returning a `RegExp` subclass, resulting in\n    // certain patterns not being emulatable.\n    avoidSubclass: false,\n    // Oniguruma flags; a string with `i`, `m`, `x`, `D`, `S`, `W` in any order (all optional).\n    // Oniguruma's `m` is equivalent to JavaScript's `s` (`dotAll`).\n    flags: '',\n    // Include JavaScript flag `g` (`global`) in the result.\n    global: false,\n    // Include JavaScript flag `d` (`hasIndices`) in the result.\n    hasIndices: false,\n    // Delay regex construction until first use if the transpiled pattern is at least this length.\n    lazyCompileLength: Infinity,\n    // JavaScript version used for generated regexes. Using `auto` detects the best value based on\n    // your environment. Later targets allow faster processing, simpler generated source, and\n    // support for additional features.\n    target: 'auto',\n    // Disables optimizations that simplify the pattern when it doesn't change the meaning.\n    verbose: false,\n    ...options,\n    // Advanced options that override standard behavior, error checking, and flags when enabled.\n    rules: {\n      // Useful with TextMate grammars that merge backreferences across patterns.\n      allowOrphanBackrefs: false,\n      // Use ASCII-based `\\b` and `\\B`, which increases search performance of generated regexes.\n      asciiWordBoundaries: false,\n      // Allow unnamed captures and numbered calls (backreferences and subroutines) when using\n      // named capture. This is Oniguruma option `ONIG_OPTION_CAPTURE_GROUP`; on by default in\n      // `vscode-oniguruma`.\n      captureGroup: false,\n      // Change the recursion depth limit from Oniguruma's `20` to an integer `2`\u2013`20`.\n      recursionLimit: 20,\n      // `^` as `\\A`; `$` as`\\Z`. Improves search performance of generated regexes without changing\n      // meaning if searching line by line. This is Oniguruma option `ONIG_OPTION_SINGLELINE`.\n      singleline: false,\n      ...options.rules,\n    },\n  };\n  if (opts.target === 'auto') {\n    opts.target = envFlags.flagGroups ? 'ES2025' : (envFlags.unicodeSets ? 'ES2024' : 'ES2018');\n  }\n  return opts;\n}\n\nexport {\n  Accuracy,\n  EsVersion,\n  getOptions,\n  Target,\n};\n", "import {cp, r} from './utils.js';\nimport {slug} from 'oniguruma-parser/parser';\n\n// `\\t\\n\\v\\f\\r\\x20`\nconst asciiSpaceChar = '[\\t-\\r ]';\n// Different than `PosixClassMap`'s `word`\nconst defaultWordChar = r`[\\p{L}\\p{M}\\p{N}\\p{Pc}]`;\n\nconst CharsWithoutIgnoreCaseExpansion = new Set([\n  cp(0x130), // \u0130\n  cp(0x131), // \u0131\n]);\n\nfunction getIgnoreCaseMatchChars(char) {\n  // Some chars should not match the chars they case swap to\n  if (CharsWithoutIgnoreCaseExpansion.has(char)) {\n    return [char];\n  }\n  const set = new Set();\n  const lower = char.toLowerCase();\n  // Everything else is based on `lower`\n  const upper = lower.toUpperCase();\n  const title = LowerToTitleCaseMap.get(lower);\n  const altLower = LowerToAlternativeLowerCaseMap.get(lower);\n  const altUpper = LowerToAlternativeUpperCaseMap.get(lower);\n  // Exclude ucase if multiple chars; count code point length. Excludes ucase versions of German\n  // es-zed '\u00DF', ligatures like '\uFB00', and chars with no precomposed ucase like '\u0149'. See\n  // <unicode.org/Public/UNIDATA/SpecialCasing.txt>\n  if ([...upper].length === 1) {\n    set.add(upper);\n  }\n  altUpper && set.add(altUpper);\n  title && set.add(title);\n  // Lcase of '\u0130' is multiple chars, but it's excluded by `CharsWithoutIgnoreCaseExpansion`\n  set.add(lower);\n  altLower && set.add(altLower);\n  return [...set];\n}\n\n// The following set includes:\n// - All ES2024 general categories and their aliases (all are supported by Oniguruma). See\n//   <github.com/mathiasbynens/unicode-match-property-value-ecmascript/blob/main/data/mappings.js>\n// - All ES2024 binary properties and their aliases (all are supported by Oniguruma). See\n//   <tc39.es/ecma262/multipage/text-processing.html#table-binary-unicode-properties>\n// Unicode properties must be mapped to property names supported by JS, and must also apply JS's\n// stricter rules for casing, whitespace, hyphens, and underscores in Unicode property names. In\n// order to remain lightweight, this library assumes properties not in this list are Unicode script\n// names (which require a `Script=` or `sc=` prefix in JS). Unlike JS, Oniguruma doesn't support\n// script extensions, and it supports some properties that aren't supported in JS (including blocks\n// with an `In_` prefix). See also:\n// - Properties supported in Oniguruma: <github.com/kkos/oniguruma/blob/master/doc/UNICODE_PROPERTIES>\n// - Properties supported in JS by spec version: <github.com/eslint-community/regexpp/blob/main/src/unicode/properties.ts>\nconst JsUnicodePropertyMap = /* @__PURE__ */ new Map(\n`C Other\nCc Control cntrl\nCf Format\nCn Unassigned\nCo Private_Use\nCs Surrogate\nL Letter\nLC Cased_Letter\nLl Lowercase_Letter\nLm Modifier_Letter\nLo Other_Letter\nLt Titlecase_Letter\nLu Uppercase_Letter\nM Mark Combining_Mark\nMc Spacing_Mark\nMe Enclosing_Mark\nMn Nonspacing_Mark\nN Number\nNd Decimal_Number digit\nNl Letter_Number\nNo Other_Number\nP Punctuation punct\nPc Connector_Punctuation\nPd Dash_Punctuation\nPe Close_Punctuation\nPf Final_Punctuation\nPi Initial_Punctuation\nPo Other_Punctuation\nPs Open_Punctuation\nS Symbol\nSc Currency_Symbol\nSk Modifier_Symbol\nSm Math_Symbol\nSo Other_Symbol\nZ Separator\nZl Line_Separator\nZp Paragraph_Separator\nZs Space_Separator\nASCII\nASCII_Hex_Digit AHex\nAlphabetic Alpha\nAny\nAssigned\nBidi_Control Bidi_C\nBidi_Mirrored Bidi_M\nCase_Ignorable CI\nCased\nChanges_When_Casefolded CWCF\nChanges_When_Casemapped CWCM\nChanges_When_Lowercased CWL\nChanges_When_NFKC_Casefolded CWKCF\nChanges_When_Titlecased CWT\nChanges_When_Uppercased CWU\nDash\nDefault_Ignorable_Code_Point DI\nDeprecated Dep\nDiacritic Dia\nEmoji\nEmoji_Component EComp\nEmoji_Modifier EMod\nEmoji_Modifier_Base EBase\nEmoji_Presentation EPres\nExtended_Pictographic ExtPict\nExtender Ext\nGrapheme_Base Gr_Base\nGrapheme_Extend Gr_Ext\nHex_Digit Hex\nIDS_Binary_Operator IDSB\nIDS_Trinary_Operator IDST\nID_Continue IDC\nID_Start IDS\nIdeographic Ideo\nJoin_Control Join_C\nLogical_Order_Exception LOE\nLowercase Lower\nMath\nNoncharacter_Code_Point NChar\nPattern_Syntax Pat_Syn\nPattern_White_Space Pat_WS\nQuotation_Mark QMark\nRadical\nRegional_Indicator RI\nSentence_Terminal STerm\nSoft_Dotted SD\nTerminal_Punctuation Term\nUnified_Ideograph UIdeo\nUppercase Upper\nVariation_Selector VS\nWhite_Space space\nXID_Continue XIDC\nXID_Start XIDS`.\n  split(/\\s/).\n  map(p => [slug(p), p])\n);\n\nconst LowerToAlternativeLowerCaseMap = new Map([\n  ['s', cp(0x17F)], // s, \u017F\n  [cp(0x17F), 's'], // \u017F, s\n]);\n\nconst LowerToAlternativeUpperCaseMap = new Map([\n  [cp(0xDF), cp(0x1E9E)], // \u00DF, \u1E9E\n  [cp(0x6B), cp(0x212A)], // k, \u212A (Kelvin)\n  [cp(0xE5), cp(0x212B)], // \u00E5, \u212B (Angstrom)\n  [cp(0x3C9), cp(0x2126)], // \u03C9, \u2126 (Ohm)\n]);\n\n// See <github.com/node-unicode/unicode-16.0.0/tree/main/General_Category/Titlecase_Letter>\nconst LowerToTitleCaseMap = new Map([\n  titleEntry(0x1C5),\n  titleEntry(0x1C8),\n  titleEntry(0x1CB),\n  titleEntry(0x1F2),\n  ...titleRange(0x1F88, 0x1F8F),\n  ...titleRange(0x1F98, 0x1F9F),\n  ...titleRange(0x1FA8, 0x1FAF),\n  titleEntry(0x1FBC),\n  titleEntry(0x1FCC),\n  titleEntry(0x1FFC),\n]);\n\n// Unlike Onig's Unicode properties via `\\p` and `\\P`, these names are case sensitive and don't\n// allow inserting whitespace and underscores. Definitions at\n// <github.com/kkos/oniguruma/blob/master/doc/RE> (see: POSIX bracket: Unicode Case)\n// Note: Handling in the transformer assumes all values here are a single, negateable node that's\n// not pre-negated at the top level. It also uses ASCII versions of `graph` and `print` for target\n// `ES2018` (which doesn't allow intersection) if `accuracy` isn't `strict`\nconst PosixClassMap = new Map([\n  ['alnum', r`[\\p{Alpha}\\p{Nd}]`],\n  ['alpha', r`\\p{Alpha}`],\n  ['ascii', r`\\p{ASCII}`],\n  ['blank', r`[\\p{Zs}\\t]`],\n  ['cntrl', r`\\p{Cc}`],\n  ['digit', r`\\p{Nd}`],\n  ['graph', r`[\\P{space}&&\\P{Cc}&&\\P{Cn}&&\\P{Cs}]`],\n  ['lower', r`\\p{Lower}`],\n  ['print', r`[[\\P{space}&&\\P{Cc}&&\\P{Cn}&&\\P{Cs}]\\p{Zs}]`],\n  ['punct', r`[\\p{P}\\p{S}]`], // Updated value from Oniguruma 6.9.9; not Unicode `\\p{punct}`\n  ['space', r`\\p{space}`],\n  ['upper', r`\\p{Upper}`],\n  ['word', r`[\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}]`],\n  ['xdigit', r`\\p{AHex}`],\n]);\n\nfunction range(start, end) {\n  // const range = Array.from(Array(end + 1 - start), (_, i) => i + start);\n  // const range = Array(end + 1 - start).fill(start).map((x, i) => x + i);\n  const range = [];\n  for (let i = start; i <= end; i++) {\n    range.push(i);\n  }\n  return range;\n}\n\nfunction titleEntry(codePoint) {\n  const char = cp(codePoint);\n  return [char.toLowerCase(), char];\n}\n\nfunction titleRange(start, end) {\n  return range(start, end).map(codePoint => titleEntry(codePoint));\n}\n\nconst UnicodePropertiesWithSpecificCase = new Set([\n  'Lower', 'Lowercase',\n  'Upper', 'Uppercase',\n  'Ll', 'Lowercase_Letter',\n  'Lt', 'Titlecase_Letter',\n  'Lu', 'Uppercase_Letter',\n  // The `Changes_When_*` properties (and their aliases) could be included, but they're very rare.\n  // Some other properties include a handful of chars with specific cases only, but these chars are\n  // generally extreme edge cases and using such properties case insensitively generally produces\n  // undesired behavior anyway\n]);\n\nexport {\n  asciiSpaceChar,\n  defaultWordChar,\n  getIgnoreCaseMatchChars,\n  JsUnicodePropertyMap,\n  PosixClassMap,\n  UnicodePropertiesWithSpecificCase,\n};\n", "import {Accuracy, Target} from './options.js';\nimport {asciiSpaceChar, defaultWordChar, JsUnicodePropertyMap, PosixClassMap} from './unicode.js';\nimport {cp, getNewCurrentFlags, getOrInsert, isMinTarget, r} from './utils.js';\nimport emojiRegex from 'emoji-regex-xs';\nimport {createAlternative, createAssertion, createBackreference, createCapturingGroup, createCharacterClass, createCharacterSet, createGroup, createLookaroundAssertion, createQuantifier, createUnicodeProperty, NodeAbsentFunctionKinds, NodeAssertionKinds, NodeCharacterClassKinds, NodeCharacterSetKinds, NodeDirectiveKinds, NodeLookaroundAssertionKinds, NodeTypes, parse, slug} from 'oniguruma-parser/parser';\nimport {traverse} from 'oniguruma-parser/traverser';\n\n/**\n@typedef {\n  import('oniguruma-parser/parser').OnigurumaAst & {\n    options: {\n      disable: {[key: string]: boolean};\n      force: {[key: string]: boolean};\n    };\n    _originMap: Map<\n      import('oniguruma-parser/parser').CapturingGroupNode,\n      import('oniguruma-parser/parser').CapturingGroupNode\n    >;\n    _strategy: string?;\n  }\n} RegexPlusAst\n*/\n/**\nTransforms an Oniguruma AST in-place to a [Regex+](https://github.com/slevithan/regex) AST.\nAssumes target ES2025, expecting the generator to down-convert to the desired JS target version.\n\nRegex+'s syntax and behavior is a strict superset of native JavaScript, so the AST is very close\nto representing native ES2025 `RegExp` but with some added features (atomic groups, possessive\nquantifiers, recursion). The AST doesn't use some of Regex+'s extended features like flag x or\nsubroutines because they follow PCRE behavior and work somewhat differently than in Oniguruma. The\nAST represents what's needed to precisely reproduce Oniguruma behavior using Regex+.\n@param {import('oniguruma-parser/parser').OnigurumaAst} ast\n@param {{\n  accuracy?: keyof Accuracy;\n  asciiWordBoundaries?: boolean;\n  avoidSubclass?: boolean;\n  bestEffortTarget?: keyof Target;\n}} [options]\n@returns {RegexPlusAst}\n*/\nfunction transform(ast, options) {\n  const opts = {\n    // A couple edge cases exist where options `accuracy` and `bestEffortTarget` are used:\n    // - `CharacterSet` kind `grapheme` (`\\X`): An exact representation would require heavy Unicode\n    //   data; a best-effort approximation requires knowing the target.\n    // - `CharacterSet` kind `posix` with values `graph` and `print`: Their complex Unicode-based\n    //   representations would be hard to change to ASCII-based after the fact in the generator\n    //   based on `target`/`accuracy`, so produce the appropriate structure here.\n    accuracy: 'default',\n    asciiWordBoundaries: false,\n    avoidSubclass: false,\n    bestEffortTarget: 'ES2025',\n    ...options,\n  };\n  addParentProperties(ast);\n  const firstPassState = {\n    accuracy: opts.accuracy,\n    asciiWordBoundaries: opts.asciiWordBoundaries,\n    avoidSubclass: opts.avoidSubclass,\n    flagDirectivesByAlt: new Map(),\n    jsGroupNameMap: new Map(),\n    minTargetEs2024: isMinTarget(opts.bestEffortTarget, 'ES2024'),\n    passedLookbehind: false,\n    strategy: null,\n    // Subroutines can appear before the groups they ref, so collect reffed nodes for a second pass \n    subroutineRefMap: new Map(),\n    supportedGNodes: new Set(),\n    digitIsAscii: ast.flags.digitIsAscii,\n    spaceIsAscii: ast.flags.spaceIsAscii,\n    wordIsAscii: ast.flags.wordIsAscii,\n  };\n  traverse(ast, FirstPassVisitor, firstPassState);\n  // Global flags modified by the first pass\n  const globalFlags = {\n    dotAll: ast.flags.dotAll,\n    ignoreCase: ast.flags.ignoreCase,\n  };\n  // The interplay of subroutines (with Onig's unique rules/behavior for them; see comments in the\n  // parser for details) with backref multiplexing (a unique Onig feature), flag modifiers, and\n  // duplicate group names (which might be indirectly referenced by subroutines even though\n  // subroutines can't directly reference duplicate names) is extremely complicated to emulate in\n  // JS in a way that handles all edge cases, so we need multiple passes to do it\n  const secondPassState = {\n    currentFlags: globalFlags,\n    prevFlags: null,\n    globalFlags,\n    groupOriginByCopy: new Map(),\n    groupsByName: new Map(),\n    multiplexCapturesToLeftByRef: new Map(),\n    openRefs: new Map(),\n    reffedNodesByReferencer: new Map(),\n    subroutineRefMap: firstPassState.subroutineRefMap,\n  };\n  traverse(ast, SecondPassVisitor, secondPassState);\n  const thirdPassState = {\n    groupsByName: secondPassState.groupsByName,\n    highestOrphanBackref: 0,\n    numCapturesToLeft: 0,\n    reffedNodesByReferencer: secondPassState.reffedNodesByReferencer,\n  };\n  traverse(ast, ThirdPassVisitor, thirdPassState);\n  ast._originMap = secondPassState.groupOriginByCopy;\n  ast._strategy = firstPassState.strategy;\n  return ast;\n}\n\nconst FirstPassVisitor = {\n  AbsentFunction({node, parent, replaceWith}) {\n    const {kind, alternatives} = node;\n    if (kind === NodeAbsentFunctionKinds.repeater) {\n      // Convert `(?~\u2026)` to `(?:(?:(?!\u2026)\\p{Any})*)`\n      const group = prepContainer(createGroup(), [\n        adoptAndSwapKids(createLookaroundAssertion({negate: true}), alternatives),\n        createUnicodeProperty('Any'),\n      ]);\n      const quantifier = createQuantifier(group, 0, Infinity);\n      group.parent = quantifier;\n      replaceWith(setParent(prepContainer(createGroup(), [quantifier]), parent), {traverse: true});\n    } else {\n      throw new Error(`Unexpected absent function kind \"${kind}\"`);\n    }\n  },\n\n  Alternative: {\n    enter({node, parent, key}, {flagDirectivesByAlt}) {\n      // Look for own-level flag directives when entering an alternative because after traversing\n      // the directive itself, any subsequent flag directives will no longer be at the same level\n      const flagDirectives = node.elements.filter(el => el.kind === NodeDirectiveKinds.flags);\n      for (let i = key + 1; i < parent.alternatives.length; i++) {\n        const forwardSiblingAlt = parent.alternatives[i];\n        getOrInsert(flagDirectivesByAlt, forwardSiblingAlt, []).push(...flagDirectives);\n      }\n    },\n    exit({node}, {flagDirectivesByAlt}) {\n      // Wait until exiting to wrap an alternative's nodes with flag groups that extend flag\n      // directives from prior sibling alternatives because doing this at the end allows inner\n      // nodes to accurately check their level in the tree\n      if (flagDirectivesByAlt.get(node)?.length) {\n        const flags = getCombinedFlagModsFromFlagNodes(flagDirectivesByAlt.get(node));\n        if (flags) {\n          const flagGroup = setParent(prepContainer(createGroup({flags}), node.elements), node);\n          node.elements = [flagGroup];\n        }\n      }\n    },\n  },\n\n  Assertion({node, parent, key, container, root, remove, replaceWith}, state) {\n    const {kind, negate} = node;\n    const {asciiWordBoundaries, avoidSubclass, supportedGNodes, wordIsAscii} = state;\n    if (kind === NodeAssertionKinds.grapheme_boundary) {\n      // Supported by the parser but not yet for transpilation\n      throw new Error(`Unsupported grapheme boundary \"\\\\${negate ? 'Y' : 'y'}\"`);\n    } else if (kind === NodeAssertionKinds.line_end) {\n      // Onig's only line break char is line feed, unlike JS\n      replaceWith(setParent(parseFragment(r`(?=\\z|\\n)`), parent));\n    } else if (kind === NodeAssertionKinds.line_start) {\n      // Onig's only line break char is line feed, unlike JS. Onig's `^` doesn't match after a\n      // string-terminating line feed\n      replaceWith(setParent(parseFragment(r`(?<=\\A|\\n(?!\\z))`, {skipLookbehindValidation: true}), parent));\n    } else if (kind === NodeAssertionKinds.search_start) {\n      if (supportedGNodes.has(node)) {\n        root.flags.sticky = true;\n        remove();\n      } else {\n        const prev = container[key - 1]; // parent.elements[key - 1]\n        // Not all ways of blocking the `\\G` from matching are covered (ex: a node prior to the\n        // prev node could block), but blocked `\\G` is an edge case so it's okay if some blocked\n        // cases resulting in the standard error for being unsupported\n        if (prev && isAlwaysNonZeroLength(prev)) {\n          replaceWith(setParent(prepContainer(createLookaroundAssertion({negate: true})), parent));\n        } else if (avoidSubclass) {\n          throw new Error(r`Uses \"\\G\" in a way that requires a subclass`);\n        } else {\n          replaceWith(setParent(createAssertion(NodeAssertionKinds.string_start), parent));\n          state.strategy = 'clip_search';\n        }\n      }\n    } else if (kind === NodeAssertionKinds.string_end || kind === NodeAssertionKinds.string_start) {\n      // Don't need transformation since JS flag m isn't used\n    } else if (kind === NodeAssertionKinds.string_end_newline) {\n      replaceWith(setParent(parseFragment(r`(?=\\n?\\z)`), parent));\n    } else if (kind === NodeAssertionKinds.word_boundary) {\n      if (!wordIsAscii && !asciiWordBoundaries) {\n        const b = `(?:(?<=${defaultWordChar})(?!${defaultWordChar})|(?<!${defaultWordChar})(?=${defaultWordChar}))`;\n        const B = `(?:(?<=${defaultWordChar})(?=${defaultWordChar})|(?<!${defaultWordChar})(?!${defaultWordChar}))`;\n        replaceWith(setParent(parseFragment(negate ? B : b), parent));\n      }\n    } else {\n      throw new Error(`Unexpected assertion kind \"${kind}\"`);\n    }\n  },\n\n  Backreference({node}, {jsGroupNameMap}) {\n    let {ref} = node;\n    if (typeof ref === 'string' && !isValidJsGroupName(ref)) {\n      ref = getAndStoreJsGroupName(ref, jsGroupNameMap);\n      node.ref = ref;\n    }\n  },\n\n  CapturingGroup({node}, {jsGroupNameMap, subroutineRefMap}) {\n    let {name} = node;\n    if (name && !isValidJsGroupName(name)) {\n      name = getAndStoreJsGroupName(name, jsGroupNameMap);\n      node.name = name;\n    }\n    subroutineRefMap.set(node.number, node);\n    if (name) {\n      subroutineRefMap.set(name, node);\n    }\n  },\n\n  CharacterClassRange({node, parent, replaceWith}) {\n    if (parent.kind === NodeCharacterClassKinds.intersection) {\n      // JS doesn't allow intersection with ranges without a wrapper class\n      replaceWith(setParent(adoptAndSwapKids(createCharacterClass(), [node]), parent), {traverse: true});\n    }\n  },\n\n  CharacterSet({node, parent, replaceWith}, {accuracy, minTargetEs2024, digitIsAscii, spaceIsAscii, wordIsAscii}) {\n    const {kind, negate, value} = node;\n    // Flag D with `\\d`, `\\p{Digit}`, `[[:digit:]]`\n    if (digitIsAscii && (kind === NodeCharacterSetKinds.digit || value === 'digit')) {\n      replaceWith(setParent(createCharacterSet(NodeCharacterSetKinds.digit, {negate}), parent));\n      return;\n    }\n    // Flag S with `\\s`, `\\p{Space}`, `[[:space:]]`\n    if (spaceIsAscii && (kind === NodeCharacterSetKinds.space || value === 'space')) {\n      replaceWith(setParent(setNegate(parseFragment(asciiSpaceChar), negate), parent));\n      return;\n    }\n    // Flag W with `\\w`, `\\p{Word}`, `[[:word:]]`\n    if (wordIsAscii && (kind === NodeCharacterSetKinds.word || value === 'word')) {\n      replaceWith(setParent(createCharacterSet(NodeCharacterSetKinds.word, {negate}), parent));\n      return;\n    }\n    if (kind === NodeCharacterSetKinds.any) {\n      replaceWith(setParent(createUnicodeProperty('Any'), parent));\n    } else if (kind === NodeCharacterSetKinds.digit) {\n      replaceWith(setParent(createUnicodeProperty('Nd', {negate}), parent));\n    } else if (kind === NodeCharacterSetKinds.dot) {\n      // Doesn't need transformation\n    } else if (kind === NodeCharacterSetKinds.grapheme) {\n      if (accuracy === 'strict') {\n        throw new Error(r`Use of \"\\X\" requires non-strict accuracy`);\n      }\n      // `emojiRegex` is more permissive than `\\p{RGI_Emoji}` since it allows over/under-qualified\n      // emoji using a general pattern that matches any Unicode sequence following the structure of\n      // a valid emoji. That actually makes it more accurate for matching any grapheme\n      const emoji = minTargetEs2024 ? r`\\p{RGI_Emoji}` : emojiRegex().source.replace(/\\\\u\\{/g, `\\\\x{`);\n      // Close approximation of an extended grapheme cluster. Details: <unicode.org/reports/tr29/>.\n      // Skip property name validation to allow `RGI_Emoji` through, since Onig doesn't support it\n      replaceWith(setParent(parseFragment(r`(?>\\r\\n|${emoji}|\\P{M}\\p{M}*)`, {skipPropertyNameValidation: true}), parent));\n    } else if (kind === NodeCharacterSetKinds.hex) {\n      replaceWith(setParent(createUnicodeProperty('AHex', {negate}), parent));\n    } else if (kind === NodeCharacterSetKinds.newline) {\n      replaceWith(setParent(parseFragment(negate ? '[^\\n]' : '(?>\\r\\n?|[\\n\\v\\f\\x85\\u2028\\u2029])'), parent));\n    } else if (kind === NodeCharacterSetKinds.posix) {\n      if (!minTargetEs2024 && (value === 'graph' || value === 'print')) {\n        if (accuracy === 'strict') {\n          throw new Error(`POSIX class \"${value}\" requires min target ES2024 or non-strict accuracy`);\n        }\n        let ascii = {\n          graph: '!-~',\n          print: ' -~',\n        }[value];\n        if (negate) {\n          // POSIX classes are always nested in a char class; manually invert the range rather than\n          // using `[^\u2026]` so it can be unwrapped since ES2018 doesn't support nested classes\n          ascii = `\\0-${cp(ascii.codePointAt(0) - 1)}${cp(ascii.codePointAt(2) + 1)}-\\u{10FFFF}`;\n        }\n        replaceWith(setParent(parseFragment(`[${ascii}]`), parent));\n      } else {\n        replaceWith(setParent(setNegate(parseFragment(PosixClassMap.get(value)), negate), parent));\n      }\n    } else if (kind === NodeCharacterSetKinds.property) {\n      if (!JsUnicodePropertyMap.has(slug(value))) {\n        // Assume it's a script; no error checking is the price for avoiding heavyweight Unicode\n        // data for all script names\n        node.key = 'sc';\n      }\n    } else if (kind === NodeCharacterSetKinds.space) {\n      // Can't use JS's Unicode-based `\\s` since unlike Onig it includes `\\uFEFF`, excludes `\\x85`\n      replaceWith(setParent(createUnicodeProperty('space', {negate}), parent));\n    } else if (kind === NodeCharacterSetKinds.word) {\n      replaceWith(setParent(setNegate(parseFragment(defaultWordChar), negate), parent));\n    } else {\n      throw new Error(`Unexpected character set kind \"${kind}\"`);\n    }\n  },\n\n  Directive({node, parent, root, remove, replaceWith, removeAllPrevSiblings, removeAllNextSiblings}) {\n    const {kind, flags} = node;\n    if (kind === NodeDirectiveKinds.flags) {\n      if (!flags.enable && !flags.disable) {\n        // Flag directive without flags; ex: `(?-)`, `(?--)`\n        remove();\n      } else {\n        replaceWith(setParent(prepContainer(createGroup({flags}), removeAllNextSiblings()), parent), {traverse: true});\n      }\n    } else if (kind === NodeDirectiveKinds.keep) {\n      const firstAltFirstEl = root.pattern.alternatives[0].elements[0];\n      // Supporting a full-pattern wrapper around `\\K` enables use with flag modifiers\n      const hasWrapperGroup =\n        // Not emulatable if within a `CapturingGroup`\n        hasOnlyChild(root.pattern, kid => kid.type === NodeTypes.Group) &&\n        firstAltFirstEl.alternatives.length === 1;\n      const topLevel = hasWrapperGroup ? firstAltFirstEl : root.pattern;\n      if (parent.parent !== topLevel || topLevel.alternatives.length > 1) {\n        throw new Error(r`Uses \"\\K\" in a way that's unsupported`);\n      }\n      replaceWith(setParent(prepContainer(createLookaroundAssertion({behind: true}), removeAllPrevSiblings()), parent));\n    } else {\n      throw new Error(`Unexpected directive kind \"${kind}\"`);\n    }\n  },\n\n  Flags({node, parent}) {\n    if (node.posixIsAscii) {\n      // Supported by the parser but not yet for transpilation\n      throw new Error('Unsupported flag \"P\"');\n    }\n    // Remove Onig flags that aren't available in JS\n    [ 'digitIsAscii', // Flag D\n      'extended', // Flag x\n      'posixIsAscii', // Flag P\n      'spaceIsAscii', // Flag S\n      'wordIsAscii', // Flag W\n    ].forEach(f => delete node[f]);\n    Object.assign(node, {\n      // JS flag g; no Onig equiv\n      global: false,\n      // JS flag d; no Onig equiv\n      hasIndices: false,\n      // JS flag m; no Onig equiv but its behavior is always on in Onig. Onig's only line break\n      // char is line feed, unlike JS, so this flag isn't used since it would produce inaccurate\n      // results (also allows `^` and `$` to be used in the generator for string start and end)\n      multiline: false,\n      // JS flag y; no Onig equiv, but used for `\\G` emulation\n      sticky: node.sticky ?? false,\n      // Note: Regex+ doesn't allow explicitly adding flags it handles implicitly, so leave out\n      // properties `unicode` (JS flag u) and `unicodeSets` (JS flag v). Keep the existing values\n      // for `ignoreCase` (flag i) and `dotAll` (JS flag s, but Onig flag m)\n    });\n    // Options accepted by Regex+; see <github.com/slevithan/regex#-options>\n    parent.options = {\n      disable: {\n        // Onig uses different rules for flag x than Regex+, so disable the implicit flag\n        x: true,\n        // Onig has no flag to control \"named capture only\" mode but contextually applies its\n        // behavior when named capturing is used, so disable Regex+'s implicit flag for it\n        n: true,\n      },\n      force: {\n        // Always add flag v because we're generating an AST that relies on it (it enables JS\n        // support for Onig features nested classes, intersection, Unicode properties, etc.).\n        // However, the generator might disable flag v based on its `target` option\n        v: true,\n      },\n    };\n  },\n\n  Group({node}) {\n    if (!node.flags) {\n      return;\n    }\n    const {enable, disable} = node.flags;\n    // Onig's flag x (`extended`) isn't available in JS\n    enable?.extended && delete enable.extended;\n    disable?.extended && delete disable.extended;\n    // JS doesn't support flag groups that enable and disable the same flag; ex: `(?i-i:)`\n    enable?.dotAll && disable?.dotAll && delete enable.dotAll;\n    enable?.ignoreCase && disable?.ignoreCase && delete enable.ignoreCase;\n    // Cleanup\n    enable && !Object.keys(enable).length && delete node.flags.enable;\n    disable && !Object.keys(disable).length && delete node.flags.disable;\n    !node.flags.enable && !node.flags.disable && delete node.flags;\n  },\n\n  LookaroundAssertion({node}, state) {\n    const {kind} = node;\n    if (kind === NodeLookaroundAssertionKinds.lookbehind) {\n      state.passedLookbehind = true;\n    }\n  },\n\n  Pattern: {\n    enter({node}, {supportedGNodes}) {\n      // For `\\G` to be accurately emulatable using JS flag y, it must be at (and only at) the start\n      // of every top-level alternative (with complex rules for what determines being at the start).\n      // Additional `\\G` error checking in `Assertion` visitor\n      const leadingGs = [];\n      let hasAltWithLeadG = false;\n      let hasAltWithoutLeadG = false;\n      for (const alt of node.alternatives) {\n        if (alt.elements.length === 1 && alt.elements[0].kind === NodeAssertionKinds.search_start) {\n          // Remove the `\\G` (leaving behind an empty alternative, and without adding JS flag y)\n          // since a top-level alternative that includes only `\\G` always matches at the start of the\n          // match attempt. Note that this is based on Oniguruma's rules, and is different than other\n          // regex flavors where `\\G` matches at the end of the previous match (a subtle distinction\n          // that's relevant after zero-length matches)\n          alt.elements.pop();\n        } else {\n          const leadingG = getLeadingG(alt.elements);\n          if (leadingG) {\n            hasAltWithLeadG = true;\n            Array.isArray(leadingG) ?\n              leadingGs.push(...leadingG) :\n              leadingGs.push(leadingG);\n          } else {\n            hasAltWithoutLeadG = true;\n          }\n        }\n      }\n      if (hasAltWithLeadG && !hasAltWithoutLeadG) {\n        // Supported `\\G` nodes will be removed (and add flag y) when traversed\n        leadingGs.forEach(g => supportedGNodes.add(g));\n      }\n    },\n    exit(_, {accuracy, passedLookbehind, strategy}) {\n      if (accuracy === 'strict' && passedLookbehind && strategy) {\n        throw new Error(r`Uses \"\\G\" in a way that requires non-strict accuracy`);\n      }\n    },\n  },\n\n  Quantifier({node}) {\n    if (node.element.type === NodeTypes.Quantifier) {\n      // Change e.g. `a**` to `(?:a*)*`\n      const group = setParent(prepContainer(createGroup(), [node.element]), node);\n      node.element = group;\n    }\n  },\n\n  Subroutine({node}, {jsGroupNameMap}) {\n    let {ref} = node;\n    if (typeof ref === 'string' && !isValidJsGroupName(ref)) {\n      ref = getAndStoreJsGroupName(ref, jsGroupNameMap);\n      node.ref = ref;\n    }\n  },\n};\n\nconst SecondPassVisitor = {\n  Backreference({node}, {multiplexCapturesToLeftByRef, reffedNodesByReferencer}) {\n    const {orphan, ref} = node;\n    if (!orphan) {\n      // Copy the current state for later multiplexing expansion. That's done in a subsequent pass\n      // because backref numbers need to be recalculated after subroutine expansion\n      reffedNodesByReferencer.set(node, [...multiplexCapturesToLeftByRef.get(ref).map(({node}) => node)]);\n    }\n  },\n\n  CapturingGroup: {\n    enter(\n      { node,\n        parent,\n        replaceWith,\n        skip,\n      },\n      { groupOriginByCopy,\n        groupsByName,\n        multiplexCapturesToLeftByRef,\n        openRefs,\n        reffedNodesByReferencer,\n      }\n    ) {\n      // Has value if we're within a subroutine expansion\n      const origin = groupOriginByCopy.get(node);\n\n      // ## Handle recursion; runs after subroutine expansion\n      if (origin && openRefs.has(node.number)) {\n        // Recursion doesn't affect any following backrefs to its `ref` (unlike other subroutines),\n        // so don't wrap with a capture. The reffed group might have its name removed due to later\n        // subroutine expansion\n        const recursion = setParent(createRecursion(node.number), parent);\n        reffedNodesByReferencer.set(recursion, openRefs.get(node.number));\n        replaceWith(recursion);\n        return;\n      }\n      openRefs.set(node.number, node);\n\n      // ## Track data for backref multiplexing\n      multiplexCapturesToLeftByRef.set(node.number, []);\n      if (node.name) {\n        getOrInsert(multiplexCapturesToLeftByRef, node.name, []);\n      }\n      const multiplexNodes = multiplexCapturesToLeftByRef.get(node.name ?? node.number);\n      for (let i = 0; i < multiplexNodes.length; i++) {\n        // Captures added via subroutine expansion (maybe indirectly because they were descendant\n        // captures of the reffed group or in a nested subroutine expansion) form a set with their\n        // origin group and any other copies of it added via subroutines. Only the most recently\n        // matched within this set is added to backref multiplexing. So search the list of already-\n        // tracked multiplexed nodes for this group name or number to see if there's a node being\n        // replaced by this capture\n        const multiplex = multiplexNodes[i];\n        if (\n          // This group is from subroutine expansion, and there's a multiplex value from either the\n          // origin node or a prior subroutine expansion group with the same origin\n          (origin === multiplex.node || (origin && origin === multiplex.origin)) ||\n          // This group is not from subroutine expansion, and it comes after a subroutine expansion\n          // group that refers to this group\n          node === multiplex.origin\n        ) {\n          multiplexNodes.splice(i, 1);\n          break;\n        }\n      }\n      multiplexCapturesToLeftByRef.get(node.number).push({node, origin});\n      if (node.name) {\n        multiplexCapturesToLeftByRef.get(node.name).push({node, origin});\n      }\n\n      // ## Track data for duplicate names\n      // Pre-ES2025 doesn't allow duplicate names, but ES2025 allows duplicate names that are\n      // unique per mutually exclusive alternation path. However, Oniguruma's handling for named\n      // subpatterns on match results means we can't use this ES2025 feature even when in an ES2025\n      // env. So, if using a duplicate name, remove the name from all but the first instance that\n      // wasn't created by subroutine expansion\n      if (node.name) {\n        const groupsWithSameName = getOrInsert(groupsByName, node.name, new Map());\n        let hasDuplicateNameToRemove = false;\n        if (origin) {\n          // Subroutines and their child captures shouldn't hold duplicate names in the final state\n          hasDuplicateNameToRemove = true;\n        } else {\n          for (const groupInfo of groupsWithSameName.values()) {\n            if (!groupInfo.hasDuplicateNameToRemove) {\n              // Will change to an unnamed capture in a later pass\n              hasDuplicateNameToRemove = true;\n              break;\n            }\n          }\n        }\n        groupsByName.get(node.name).set(node, {node, hasDuplicateNameToRemove});\n      }\n    },\n    exit({node}, {openRefs}) {\n      openRefs.delete(node.number);\n    },\n  },\n\n  Group: {\n    enter({node}, state) {\n      // Flag directives have already been converted to flag groups by the previous pass\n      state.prevFlags = state.currentFlags;\n      if (node.flags) {\n        state.currentFlags = getNewCurrentFlags(state.currentFlags, node.flags);\n      }\n    },\n    exit(_, state) {\n      state.currentFlags = state.prevFlags;\n    },\n  },\n\n  Recursion({node, parent}, {reffedNodesByReferencer}) {\n    // Recursion nodes are created during the current traversal; they're only traversed here if a\n    // recursion node created during traversal is then copied by a subroutine expansion, e.g. with\n    // `(?<a>\\g<a>)\\g<a>`\n    const {ref} = node;\n    // Immediate parent is an alternative or quantifier; can skip\n    let reffed = parent;\n    while ((reffed = reffed.parent)) {\n      if (reffed.type === NodeTypes.CapturingGroup && (reffed.name === ref || reffed.number === ref)) {\n        break;\n      }\n    }\n    // Track the referenced node because `ref`s are rewritten in a subsequent pass; capturing group\n    // names and numbers might change due to subroutine expansion and duplicate group names\n    reffedNodesByReferencer.set(node, reffed);\n  },\n\n  Subroutine({node, parent, replaceWith}, state) {\n    const {ref} = node;\n    const reffedGroupNode = state.subroutineRefMap.get(ref);\n    // Other forms of recursion are handled by the `CapturingGroup` visitor\n    const isGlobalRecursion = ref === 0;\n    const expandedSubroutine = isGlobalRecursion ?\n      createRecursion(0) :\n      // The reffed group might itself contain subroutines, which are expanded during sub-traversal\n      cloneCapturingGroup(reffedGroupNode, state.groupOriginByCopy, null);\n    let replacement = expandedSubroutine;\n    if (!isGlobalRecursion) {\n      // Subroutines take their flags from the reffed group, not the flags surrounding themselves\n      const reffedGroupFlagMods = getCombinedFlagModsFromFlagNodes(getAllParents(reffedGroupNode, node => {\n        return node.type === NodeTypes.Group && !!node.flags;\n      }));\n      const reffedGroupFlags = reffedGroupFlagMods ?\n        getNewCurrentFlags(state.globalFlags, reffedGroupFlagMods) :\n        state.globalFlags;\n      if (!areFlagsEqual(reffedGroupFlags, state.currentFlags)) {\n        replacement = prepContainer(createGroup({\n          flags: getFlagModsFromFlags(reffedGroupFlags),\n        }), [expandedSubroutine]);\n      }\n    }\n    replaceWith(setParent(replacement, parent), {traverse: !isGlobalRecursion});\n  },\n};\n\nconst ThirdPassVisitor = {\n  Backreference({node, parent, replaceWith}, state) {\n    if (node.orphan) {\n      state.highestOrphanBackref = Math.max(state.highestOrphanBackref, node.ref);\n      // Don't renumber; used with `allowOrphanBackrefs`\n      return;\n    }\n    const reffedNodes = state.reffedNodesByReferencer.get(node);\n    const participants = reffedNodes.filter(reffed => canParticipateWithNode(reffed, node));\n    // For the backref's `ref`, use `number` rather than `name` because group names might have been\n    // removed if they're duplicates within their alternation path, or they might be removed later\n    // by the generator (depending on target) if they're duplicates within the overall pattern.\n    // Backrefs must come after groups they ref, so reffed node `number`s are already recalculated\n    if (!participants.length) {\n      // If no participating capture, convert backref to to `(?!)`; backrefs to nonparticipating\n      // groups can't match in Onig but match the empty string in JS\n      replaceWith(setParent(prepContainer(createLookaroundAssertion({negate: true})), parent));\n    } else if (participants.length > 1) {\n      // Multiplex\n      const alts = participants.map(reffed => adoptAndSwapKids(\n        createAlternative(),\n        [createBackreference(reffed.number)]\n      ));\n      replaceWith(setParent(adoptAndSwapKids(createGroup(), alts), parent));\n    } else {\n      node.ref = participants[0].number;\n    }\n  },\n\n  CapturingGroup({node}, state) {\n    // Recalculate the number since the current value might be wrong due to subroutine expansion\n    node.number = ++state.numCapturesToLeft;\n    if (node.name) {\n      // Removing duplicate names here rather than in an earlier pass avoids extra complexity when\n      // handling subroutine expansion and backref multiplexing\n      if (state.groupsByName.get(node.name).get(node).hasDuplicateNameToRemove) {\n        delete node.name;\n      }\n    }\n  },\n\n  Recursion({node}, state) {\n    if (node.ref === 0) {\n      return;\n    }\n    // For the recursion's `ref`, use `number` rather than `name` because group names might have\n    // been removed if they're duplicates within their alternation path, or they might be removed\n    // later by the generator (depending on target) if they're duplicates within the overall\n    // pattern. Since recursion appears within the group it refs, the reffed node's `number` has\n    // already been recalculated\n    node.ref = state.reffedNodesByReferencer.get(node).number;\n  },\n\n  Regex: {\n    exit({node}, state) {\n      // [HACK] Add unnamed captures to the end of the regex if needed to allow orphaned backrefs\n      // to be valid in JS with flag u/v. This is needed to support TextMate grammars, which\n      // replace numbered backrefs in their `end` pattern with values matched by captures in their\n      // `begin` pattern! See <github.com/microsoft/vscode-textmate/blob/7e0ea282f4f25fef12a6c84fa4fa7266f67b58dc/src/rule.ts#L661-L663>\n      // An `end` pattern, prior to this substitution, might have backrefs to a group that doesn't\n      // exist within `end`. This presents a dilemma since both Oniguruma and JS (with flag u/v)\n      // error for backrefs to undefined captures. So adding captures to the end is a solution that\n      // doesn't change what the regex matches, and lets invalid numbered backrefs through. Note:\n      // Orphan backrefs are only allowed if `allowOrphanBackrefs` is enabled\n      const numCapsNeeded = Math.max(state.highestOrphanBackref - state.numCapturesToLeft, 0);\n      for (let i = 0; i < numCapsNeeded; i++) {\n        const emptyCapture = createCapturingGroup();\n        node.pattern.alternatives.at(-1).elements.push(emptyCapture);\n      }\n    },\n  },\n};\n\n// Add `parent` properties to all nodes to help during traversal; also expected by the generator\nfunction addParentProperties(ast) {\n  traverse(ast, {\n    '*'({node, parent}) {\n      node.parent = parent;\n    },\n  });\n}\n\nfunction adoptAndSwapKids(parent, kids) {\n  kids.forEach(kid => kid.parent = parent);\n  parent[getContainerAccessor(parent)] = kids;\n  return parent;\n}\n\nfunction areFlagsEqual(a, b) {\n  return a.dotAll === b.dotAll && a.ignoreCase === b.ignoreCase;\n}\n\nfunction canParticipateWithNode(capture, node) {\n  // Walks to the left (prev siblings), down (sibling descendants), up (parent), then back down\n  // (parent's prev sibling descendants) the tree in a loop\n  let rightmostPoint = node;\n  do {\n    if (rightmostPoint.type === NodeTypes.Pattern) {\n      // End of the line; capture is not in node's alternation path\n      return false;\n    }\n    if (rightmostPoint.type === NodeTypes.Alternative) {\n      // Skip past alts to their parent because we don't want to look at the kids of preceding alts\n      continue;\n    }\n    if (rightmostPoint === capture) {\n      // Capture is ancestor of node\n      return false;\n    }\n    const kidsOfParent = getKids(rightmostPoint.parent);\n    for (const kid of kidsOfParent) {\n      if (kid === rightmostPoint) {\n        // Reached rightmost node in sibling list that we want to consider; break to parent loop\n        break;\n      }\n      if (kid === capture) {\n        return true;\n      }\n      if (hasDescendant(kid, capture)) {\n        return true;\n      }\n    }\n  } while ((rightmostPoint = rightmostPoint.parent));\n  throw new Error('Unexpected path');\n}\n\n// Creates a deep copy of the provided node, with special handling:\n// - Make `parent` props point to their parent in the copy\n// - Update the provided `originMap` for each cloned capturing group (outer and nested)\nfunction cloneCapturingGroup(obj, originMap, up, up2) {\n  const store = Array.isArray(obj) ? [] : {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (key === 'parent') {\n      // If the last cloned item was a container array (for holding kids), use the object above it\n      store.parent = Array.isArray(up) ? up2 : up;\n    } else if (value && typeof value === 'object') {\n      store[key] = cloneCapturingGroup(value, originMap, store, up);\n    } else {\n      if (key === 'type' && value === NodeTypes.CapturingGroup) {\n        // Key is the copied node, value is the origin node\n        originMap.set(store, originMap.get(obj) ?? obj);\n      }\n      store[key] = value;\n    }\n  }\n  return store;\n}\n\n// `Recursion` nodes are used only by the transformer\nfunction createRecursion(ref) {\n  return {\n    type: NodeTypes.Recursion,\n    ref,\n  };\n}\n\nfunction getAllParents(node, filterFn) {\n  const results = [];\n  while ((node = node.parent)) {\n    if (!filterFn || filterFn(node)) {\n      results.push(node);\n    }\n  }\n  return results;\n}\n\n// See also `isValidJsGroupName`\nfunction getAndStoreJsGroupName(name, map) {\n  if (map.has(name)) {\n    return map.get(name);\n  }\n  // Onig group names can't start with `$`, but JS names can\n  const jsName = `$${map.size}_${name.replace(/^[^$_\\p{IDS}]|[^$\\u200C\\u200D\\p{IDC}]/ug, '_')}`;\n  map.set(name, jsName);\n  return jsName;\n}\n\n// Returns the string key for the container that holds the node's kids\nfunction getContainerAccessor(node) {\n  for (const accessor of ['alternatives', 'elements']) {\n    if (node[accessor]) {\n      return accessor;\n    }\n  }\n  return null;\n}\n\nfunction getCombinedFlagModsFromFlagNodes(flagNodes) {\n  const flagProps = ['dotAll', 'ignoreCase'];\n  const combinedFlags = {enable: {}, disable: {}};\n  flagNodes.forEach(({flags}) => {\n    flagProps.forEach(prop => {\n      if (flags.enable?.[prop]) {\n        // Need to remove `disable` since disabled flags take precedence\n        delete combinedFlags.disable[prop];\n        combinedFlags.enable[prop] = true;\n      }\n      if (flags.disable?.[prop]) {\n        combinedFlags.disable[prop] = true;\n      }\n    });\n  });\n  if (!Object.keys(combinedFlags.enable).length) {\n    delete combinedFlags.enable;\n  }\n  if (!Object.keys(combinedFlags.disable).length) {\n    delete combinedFlags.disable;\n  }\n  if (combinedFlags.enable || combinedFlags.disable) {\n    return combinedFlags;\n  }\n  return null;\n}\n\nfunction getFlagModsFromFlags({dotAll, ignoreCase}) {\n  const mods = {};\n  if (dotAll || ignoreCase) {\n    mods.enable = {};\n    dotAll && (mods.enable.dotAll = true);\n    ignoreCase && (mods.enable.ignoreCase = true);\n  }\n  if (!dotAll || !ignoreCase) {\n    mods.disable = {};\n    !dotAll && (mods.disable.dotAll = true);\n    !ignoreCase && (mods.disable.ignoreCase = true);\n  }\n  return mods;\n}\n\nfunction getKids(node) {\n  if (!node) {\n    throw new Error('Node expected');\n  }\n  // [NOTE] Not handling `Regex` kids (`pattern`, `flags`) and `CharacterClassRange` kids (`min`,\n  // `max`) only because not needed by current callers\n  if (node.type === NodeTypes.Quantifier) {\n    return [node.element];\n  }\n  const accessor = getContainerAccessor(node);\n  return accessor && node[accessor];\n}\n\nfunction getLeadingG(els) {\n  const firstToConsider = els.find(el => (\n    el.kind === NodeAssertionKinds.search_start ||\n    isLoneGLookaround(el, {negate: false}) ||\n    !isAlwaysZeroLength(el)\n  ));\n  if (!firstToConsider) {\n    return null;\n  }\n  if (firstToConsider.kind === NodeAssertionKinds.search_start) {\n    return firstToConsider;\n  }\n  if (firstToConsider.type === NodeTypes.LookaroundAssertion) {\n    return firstToConsider.alternatives[0].elements[0];\n  }\n  if (firstToConsider.type === NodeTypes.CapturingGroup || firstToConsider.type === NodeTypes.Group) {\n    const gNodesForGroup = [];\n    // Recursively find `\\G` nodes for all alternatives in the group\n    for (const alt of firstToConsider.alternatives) {\n      const leadingG = getLeadingG(alt.elements);\n      if (!leadingG) {\n        // Don't return `gNodesForGroup` collected so far since this alt didn't qualify\n        return null;\n      }\n      Array.isArray(leadingG) ?\n        gNodesForGroup.push(...leadingG) :\n        gNodesForGroup.push(leadingG);\n    }\n    return gNodesForGroup;\n  }\n  return null;\n}\n\nfunction hasDescendant(node, descendant) {\n  const kids = getKids(node) ?? [];\n  for (const kid of kids) {\n    if (\n      kid === descendant ||\n      hasDescendant(kid, descendant)\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\nCheck whether the node has exactly one alternative with one child element, and optionally that the\nchild satisfies a condition.\n@param {import('oniguruma-parser/parser').AlternativeContainerNode} node\n@param {(node: import('oniguruma-parser/parser').AlternativeElementNode) => boolean} [kidFn]\n@returns {boolean}\n*/\nfunction hasOnlyChild({alternatives}, kidFn) {\n  return (\n    alternatives.length === 1 &&\n    alternatives[0].elements.length === 1 &&\n    (!kidFn || kidFn(alternatives[0].elements[0]))\n  );\n}\n\nfunction isAlwaysZeroLength({type}) {\n  return type === NodeTypes.Assertion ||\n    type === NodeTypes.Directive ||\n    type === NodeTypes.LookaroundAssertion;\n}\n\nfunction isAlwaysNonZeroLength(node) {\n  const types = [\n    NodeTypes.Character,\n    NodeTypes.CharacterClass,\n    NodeTypes.CharacterSet,\n  ];\n  return types.includes(node.type) || (\n    node.type === NodeTypes.Quantifier &&\n    node.min &&\n    types.includes(node.element.type)\n  );\n}\n\nfunction isLoneGLookaround(node, options) {\n  const opts = {\n    negate: null,\n    ...options,\n  };\n  return (\n    node.type === NodeTypes.LookaroundAssertion &&\n    (opts.negate === null || node.negate === opts.negate) &&\n    hasOnlyChild(node, kid => kid.kind === NodeAssertionKinds.search_start)\n  );\n}\n\n// See also `getAndStoreJsGroupName`\nfunction isValidJsGroupName(name) {\n  // JS group names are more restrictive than Onig; see\n  // <developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers>\n  return /^[$_\\p{IDS}][$\\u200C\\u200D\\p{IDC}]*$/u.test(name);\n}\n\n// Returns a single node, either the given node or all nodes wrapped in a noncapturing group\nfunction parseFragment(pattern, options) {\n  const ast = parse(pattern, {\n    ...options,\n    // Providing a custom set of Unicode property names avoids converting some JS Unicode\n    // properties (ex: `\\p{Alpha}`) to Onig POSIX classes\n    unicodePropertyMap: JsUnicodePropertyMap,\n  });\n  addParentProperties(ast);\n  const alts = ast.pattern.alternatives;\n  if (alts.length > 1 || alts[0].elements.length > 1) {\n    return adoptAndSwapKids(createGroup(), alts);\n  }\n  return alts[0].elements[0];\n}\n\nfunction prepContainer(node, kids) {\n  const accessor = getContainerAccessor(node);\n  // Set the parent for the default container of a new node\n  node[accessor][0].parent = node;\n  if (kids) {\n    adoptAndSwapKids(node[accessor][0], kids);\n  }\n  return node;\n}\n\nfunction setNegate(node, negate) {\n  node.negate = negate;\n  return node;\n}\n\nfunction setParent(node, parent) {\n  node.parent = parent;\n  return node;\n}\n\nexport {\n  transform,\n};\n", "import {getOptions} from './options.js';\nimport {getIgnoreCaseMatchChars, UnicodePropertiesWithSpecificCase} from './unicode.js';\nimport {cp, envFlags, getNewCurrentFlags, getOrInsert, isMinTarget, r} from './utils.js';\nimport {createAlternative, createCharacter, createGroup, NodeAssertionKinds, NodeCharacterClassKinds, NodeCharacterSetKinds, NodeLookaroundAssertionKinds, NodeTypes} from 'oniguruma-parser/parser';\nimport {traverse} from 'oniguruma-parser/traverser';\n\n/**\nGenerates a Regex+ compatible `pattern`, `flags`, and `options` from a Regex+ AST.\n@param {import('./transform.js').RegexPlusAst} ast\n@param {import('.').ToRegExpOptions} [options]\n@returns {{\n  pattern: string;\n  flags: string;\n  options: Object;\n  _captureTransfers: Map<number, Array<number>>;\n  _hiddenCaptures: Array<number>;\n}}\n*/\nfunction generate(ast, options) {\n  const opts = getOptions(options);\n  const minTargetEs2024 = isMinTarget(opts.target, 'ES2024');\n  const minTargetEs2025 = isMinTarget(opts.target, 'ES2025');\n  const recursionLimit = opts.rules.recursionLimit;\n  if (!Number.isInteger(recursionLimit) || recursionLimit < 2 || recursionLimit > 20) {\n    throw new Error('Invalid recursionLimit; use 2-20');\n  }\n\n  // If the output can't use flag groups, we need a pre-pass to check for the use of chars with\n  // case in case sensitive/insensitive states. This minimizes the need for case expansions (though\n  // expansions are lossless, even given Unicode case complexities) and allows supporting case\n  // insensitive backrefs in more cases\n  // [TODO] Consider gathering this data in the transformer's final traversal to avoid work here\n  let hasCaseInsensitiveNode = null;\n  let hasCaseSensitiveNode = null;\n  if (!minTargetEs2025) {\n    const iStack = [ast.flags.ignoreCase];\n    traverse(ast, FlagModifierVisitor, {\n      getCurrentModI: () => iStack.at(-1),\n      popModI() {iStack.pop()},\n      pushModI(isIOn) {iStack.push(isIOn)},\n      setHasCasedChar() {\n        if (iStack.at(-1)) {\n          hasCaseInsensitiveNode = true;\n        } else {\n          hasCaseSensitiveNode = true;\n        }\n      },\n    });\n  }\n\n  const appliedGlobalFlags = {\n    dotAll: ast.flags.dotAll,\n    // - Turn global flag i on if a case insensitive node was used and no case sensitive nodes were\n    //   used (to avoid unnecessary node expansion).\n    // - Turn global flag i off if a case sensitive node was used (since case sensitivity can't be\n    //   forced without the use of ES2025 flag groups)\n    ignoreCase: !!((ast.flags.ignoreCase || hasCaseInsensitiveNode) && !hasCaseSensitiveNode),\n  };\n  let lastNode = null;\n  const state = {\n    accuracy: opts.accuracy,\n    appliedGlobalFlags,\n    captureMap: new Map(),\n    currentFlags: {\n      dotAll: ast.flags.dotAll,\n      ignoreCase: ast.flags.ignoreCase,\n    },\n    inCharClass: false,\n    lastNode,\n    originMap: ast._originMap,\n    recursionLimit,\n    useAppliedIgnoreCase: !!(!minTargetEs2025 && hasCaseInsensitiveNode && hasCaseSensitiveNode),\n    useFlagMods: minTargetEs2025,\n    useFlagV: minTargetEs2024,\n    verbose: opts.verbose,\n  };\n  function gen(node) {\n    state.lastNode = lastNode;\n    lastNode = node;\n    switch (node.type) {\n      case NodeTypes.Regex:\n        // Final result is an object; other node types return strings\n        return {\n          pattern: gen(node.pattern),\n          flags: gen(node.flags),\n          options: {...node.options},\n        };\n      case NodeTypes.Alternative:\n        return node.elements.map(gen).join('');\n      case NodeTypes.Assertion:\n        return genAssertion(node);\n      case NodeTypes.Backreference:\n        return genBackreference(node, state);\n      case NodeTypes.CapturingGroup:\n        return genCapturingGroup(node, state, gen);\n      case NodeTypes.Character:\n        return genCharacter(node, state);\n      case NodeTypes.CharacterClass:\n        return genCharacterClass(node, state, gen);\n      case NodeTypes.CharacterClassRange:\n        return genCharacterClassRange(node, state);\n      case NodeTypes.CharacterSet:\n        return genCharacterSet(node, state);\n      case NodeTypes.Flags:\n        return genFlags(node, state);\n      case NodeTypes.Group:\n        return genGroup(node, state, gen);\n      case NodeTypes.LookaroundAssertion:\n        return genLookaroundAssertion(node, state, gen);\n      case NodeTypes.Pattern:\n        return node.alternatives.map(gen).join('|');\n      case NodeTypes.Quantifier:\n        return gen(node.element) + getQuantifierStr(node);\n      case NodeTypes.Recursion:\n        return genRecursion(node, state);\n      default:\n        // Node types `AbsentFunction`, `Directive`, and `Subroutine` are never included in\n        // transformer output\n        throw new Error(`Unexpected node type \"${node.type}\"`);\n    }\n  }\n\n  const result = gen(ast);\n  if (!minTargetEs2024) {\n    // Switch from flag v to u; Regex+ implicitly chooses by default\n    delete result.options.force.v;\n    result.options.disable.v = true;\n    result.options.unicodeSetsPlugin = null;\n  }\n  result._captureTransfers = new Map();\n  result._hiddenCaptures = [];\n  state.captureMap.forEach((value, key) => {\n    if (value.hidden) {\n      result._hiddenCaptures.push(key);\n    }\n    if (value.transferTo) {\n      getOrInsert(result._captureTransfers, value.transferTo, []).push(key);\n    }\n  });\n\n  return result;\n}\n\nconst FlagModifierVisitor = {\n  '*': {\n    enter({node}, state) {\n      if (isAnyGroup(node)) {\n        const currentModI = state.getCurrentModI();\n        state.pushModI(\n          node.flags ?\n            getNewCurrentFlags({ignoreCase: currentModI}, node.flags).ignoreCase :\n            currentModI\n        );\n      }\n    },\n    exit({node}, state) {\n      if (isAnyGroup(node)) {\n        state.popModI();\n      }\n    },\n  },\n  Backreference(_, state) {\n    // Can't know for sure, so assume the backref will include chars with case (best that could be\n    // done is not calling `setHasCasedChar` if the reffed group doesn't contain a char with case\n    // or most kinds of char sets)\n    state.setHasCasedChar();\n  },\n  Character({node}, state) {\n    if (charHasCase(cp(node.value))) {\n      state.setHasCasedChar();\n    }\n  },\n  CharacterClassRange({node, skip}, state) {\n    skip();\n    if (getCasesOutsideCharClassRange(node, {firstOnly: true}).length) {\n      state.setHasCasedChar();\n    }\n  },\n  CharacterSet({node}, state) {\n    if (\n      node.kind === NodeCharacterSetKinds.property &&\n      UnicodePropertiesWithSpecificCase.has(node.value)\n    ) {\n      state.setHasCasedChar();\n    }\n  },\n};\n\nconst BaseEscapeChars = new Set([\n  '$', '(', ')', '*', '+', '.', '?', '[', '\\\\', ']', '^', '{', '|', '}',\n]);\nconst CharClassEscapeChars = new Set([\n  '-', '\\\\', ']', '^',\n  // Literal `[` doesn't require escaping with flag u, but this can help work around regex source\n  // linters and regex syntax processors that expect unescaped `[` to create a nested class\n  '[',\n]);\nconst CharClassEscapeCharsFlagV = new Set([\n  '(', ')', '-', '/', '[', '\\\\', ']', '^', '{', '|', '}',\n  // Double punctuators; also includes already-listed `-` and `^`\n  '!', '#', '$', '%', '&', '*', '+', ',', '.', ':', ';', '<', '=', '>', '?', '@', '`', '~',\n]);\nconst CharCodeEscapeMap = new Map([\n  [ 9, r`\\t`], // horizontal tab\n  [10, r`\\n`], // line feed\n  [11, r`\\v`], // vertical tab\n  [12, r`\\f`], // form feed\n  [13, r`\\r`], // carriage return\n  [0x2028, r`\\u2028`], // line separator\n  [0x2029, r`\\u2029`], // paragraph separator\n  [0xFEFF, r`\\uFEFF`], // ZWNBSP/BOM\n]);\n\nconst casedRe = /^\\p{Cased}$/u;\nfunction charHasCase(char) {\n  return casedRe.test(char);\n}\n\nfunction genAssertion({kind, negate}) {\n  // Can always use `^` and `$` for string boundaries since JS flag m is never relied on; Onig uses\n  // different line break chars\n  if (kind === NodeAssertionKinds.string_end) {\n    return '$';\n  }\n  if (kind === NodeAssertionKinds.string_start) {\n    return '^';\n  }\n  // If a word boundary came through the transformer unaltered, that means `wordIsAscii` or\n  // `asciiWordBoundaries` is enabled\n  if (kind === NodeAssertionKinds.word_boundary) {\n    return negate ? r`\\B` : r`\\b`;\n  }\n  // Kinds `grapheme_boundary`, `line_end`, `line_start`, `search_start`, and `string_end_newline`\n  // are never included in transformer output\n  throw new Error(`Unexpected assertion kind \"${kind}\"`);\n}\n\nfunction genBackreference({ref}, state) {\n  if (typeof ref !== 'number') {\n    throw new Error('Unexpected named backref in transformed AST');\n  }\n  if (\n    !state.useFlagMods &&\n    state.accuracy === 'strict' &&\n    state.currentFlags.ignoreCase &&\n    !state.captureMap.get(ref).ignoreCase\n  ) {\n    throw new Error('Use of case-insensitive backref to case-sensitive group requires target ES2025 or non-strict accuracy');\n  }\n  return '\\\\' + ref;\n}\n\nfunction genCapturingGroup(node, state, gen) {\n  const {name, number, alternatives} = node;\n  const data = {ignoreCase: state.currentFlags.ignoreCase};\n  // Has origin if the capture is from an expanded subroutine\n  const origin = state.originMap.get(node);\n  if (origin) {\n    // All captures from/within expanded subroutines are marked as hidden\n    data.hidden = true;\n    // If a subroutine (or descendant capture) occurs after its origin group, it's marked to have\n    // its captured value transferred to the origin's capture slot. `number` and `origin.number`\n    // are the capture numbers *after* subroutine expansion\n    if (number > origin.number) {\n      data.transferTo = origin.number;\n    }\n  }\n  state.captureMap.set(number, data);\n  return `(${name ? `?<${name}>` : ''}${alternatives.map(gen).join('|')})`;\n}\n\nfunction genCharacter({value}, state) {\n  const char = cp(value);\n  const escaped = getCharEscape(value, {\n    escDigit: state.lastNode.type === NodeTypes.Backreference,\n    inCharClass: state.inCharClass,\n    useFlagV: state.useFlagV,\n  });\n  if (escaped !== char) {\n    return escaped;\n  }\n  if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && charHasCase(char)) {\n    const cases = getIgnoreCaseMatchChars(char);\n    return state.inCharClass ?\n      cases.join('') :\n      (cases.length > 1 ? `[${cases.join('')}]` : cases[0]);\n  }\n  return char;\n}\n\nfunction genCharacterClass(node, state, gen) {\n  const {kind, negate, parent} = node;\n  let {elements} = node;\n  if (kind === NodeCharacterClassKinds.intersection && !state.useFlagV) {\n    throw new Error('Use of class intersection requires min target ES2024');\n  }\n  // Work around WebKit parser bug by moving literal hyphens to the end of the class; see\n  // <github.com/slevithan/oniguruma-to-es/issues/30>\n  if (envFlags.literalHyphenIncorrectlyCreatesRange && state.useFlagV && elements.some(isLiteralHyphen)) {\n    // Remove all hyphens then add one at the end; can't just sort in case of e.g. `[\\d\\-\\-]`\n    elements = elements.filter(kid => !isLiteralHyphen(kid));\n    elements.push(createCharacter(45));\n  }\n  const genClass = () => `[${negate ? '^' : ''}${\n    elements.map(gen).join(kind === NodeCharacterClassKinds.intersection ? '&&' : '')\n  }]`;\n  if (!state.inCharClass) {\n    // Hack to support top-level-nested, negated classes in non-negated classes with target ES2018.\n    // Already established that this isn't an intersection class if `!state.useFlagV`, so don't check again\n    if (!state.useFlagV && !negate) {\n      const negatedChildClasses = elements.filter(\n        kid => kid.type === NodeTypes.CharacterClass && kid.kind === NodeCharacterClassKinds.union && kid.negate\n      );\n      if (negatedChildClasses.length) {\n        const group = createGroup();\n        const groupFirstAlt = group.alternatives[0];\n        group.parent = parent;\n        groupFirstAlt.parent = group;\n        elements = elements.filter(kid => !negatedChildClasses.includes(kid));\n        node.elements = elements;\n        if (elements.length) {\n          node.parent = groupFirstAlt;\n          groupFirstAlt.elements.push(node);\n        } else {\n          group.alternatives.pop();\n        }\n        negatedChildClasses.forEach(cc => {\n          const newAlt = createAlternative();\n          newAlt.parent = group;\n          cc.parent = newAlt;\n          newAlt.elements.push(cc);\n          group.alternatives.push(newAlt);\n        });\n        return gen(group);\n      }\n    }\n    // For the outermost char class, set state\n    state.inCharClass = true;\n    const result = genClass();\n    state.inCharClass = false;\n    return result;\n  }\n  // No first element for implicit class in empty intersection like `[&&]`\n  const firstEl = elements[0];\n  if (\n    // Already established that the parent is a char class via `inCharClass`, so don't check again\n    kind === NodeCharacterClassKinds.union &&\n    !negate &&\n    firstEl &&\n    (\n      ( // Allows many nested classes to work with `target` ES2018 which doesn't support nesting\n        (!state.useFlagV || !state.verbose) &&\n        parent.kind === NodeCharacterClassKinds.union &&\n        !(envFlags.literalHyphenIncorrectlyCreatesRange && state.useFlagV)\n      ) ||\n      ( !state.verbose &&\n        parent.kind === NodeCharacterClassKinds.intersection &&\n        // JS doesn't allow intersection with union or ranges\n        elements.length === 1 &&\n        firstEl.type !== NodeTypes.CharacterClassRange\n      )\n    )\n  ) {\n    // Remove unnecessary nesting; unwrap kids into the parent char class\n    return elements.map(gen).join('');\n  }\n  if (!state.useFlagV && parent.type === NodeTypes.CharacterClass) {\n    throw new Error('Use of nested character class requires min target ES2024');\n  }\n  return genClass();\n}\n\nfunction genCharacterClassRange(node, state) {\n  const min = node.min.value;\n  const max = node.max.value;\n  const escOpts = {\n    escDigit: false,\n    inCharClass: true,\n    useFlagV: state.useFlagV,\n  };\n  const minStr = getCharEscape(min, escOpts);\n  const maxStr = getCharEscape(max, escOpts);\n  const extraChars = new Set();\n  if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase) {\n    // [TODO] Avoid duplication by considering other chars in the parent char class when expanding\n    const charsOutsideRange = getCasesOutsideCharClassRange(node);\n    const ranges = getCodePointRangesFromChars(charsOutsideRange);\n    ranges.forEach(value => {\n      extraChars.add(\n        Array.isArray(value) ?\n          `${getCharEscape(value[0], escOpts)}-${getCharEscape(value[1], escOpts)}` :\n          getCharEscape(value, escOpts)\n      );\n    });\n  }\n  // Create the range without calling `gen` on the `min`/`max` kids\n  return `${minStr}-${maxStr}${[...extraChars].join('')}`;\n}\n\nfunction genCharacterSet({kind, negate, value, key}, state) {\n  if (kind === NodeCharacterSetKinds.dot) {\n    return state.currentFlags.dotAll ?\n      ((state.appliedGlobalFlags.dotAll || state.useFlagMods) ? '.' : '[^]') :\n      // Onig's only line break char is line feed, unlike JS\n      r`[^\\n]`;\n  }\n  if (kind === NodeCharacterSetKinds.digit) {\n    return negate ? r`\\D` : r`\\d`;\n  }\n  if (kind === NodeCharacterSetKinds.property) {\n    if (\n      state.useAppliedIgnoreCase &&\n      state.currentFlags.ignoreCase &&\n      UnicodePropertiesWithSpecificCase.has(value)\n    ) {\n      // Support for this would require heavy Unicode data. Could change e.g. `\\p{Lu}` to `\\p{LC}`\n      // if not using strict `accuracy` (since it's close but not 100%), but this wouldn't work\n      // for e.g. `\\p{Lt}`, and in any case, it's probably user error if using these case-specific\n      // props case-insensitively\n      throw new Error(`Unicode property \"${value}\" can't be case-insensitive when other chars have specific case`);\n    }\n    return `${negate ? r`\\P` : r`\\p`}{${key ? `${key}=` : ''}${value}}`;\n  }\n  if (kind === NodeCharacterSetKinds.word) {\n    return negate ? r`\\W` : r`\\w`;\n  }\n  // Kinds `grapheme`, `hex`, `newline`, `posix`, and `space` are never included in transformer output\n  throw new Error(`Unexpected character set kind \"${kind}\"`);\n}\n\nfunction genFlags(node, state) {\n  return (\n    // The transformer should never turn on the properties for flags d, g, and m since Onig doesn't\n    // have equivs. Flag m is never relied on since Onig uses different line break chars than JS\n    // (node.hasIndices ? 'd' : '') +\n    // (node.global ? 'g' : '') +\n    // (node.multiline ? 'm' : '') +\n    (state.appliedGlobalFlags.ignoreCase ? 'i' : '') +\n    (node.dotAll ? 's' : '') +\n    (node.sticky ? 'y' : '')\n    // Regex+ doesn't allow explicitly adding flags it handles implicitly, so there are no\n    // `unicode` (flag u) or `unicodeSets` (flag v) props; those flags are added separately\n  );\n}\n\nfunction genGroup({atomic, flags, parent, alternatives}, state, gen) {\n  const currentFlags = state.currentFlags;\n  if (flags) {\n    state.currentFlags = getNewCurrentFlags(currentFlags, flags);\n  }\n  const contents = alternatives.map(gen).join('|');\n  const result = (\n    !state.verbose &&\n    alternatives.length === 1 &&\n    parent.type !== NodeTypes.Quantifier &&\n    !atomic &&\n    (!state.useFlagMods || !flags)\n   ) ? contents : `(?${getGroupPrefix(atomic, flags, state.useFlagMods)}${contents})`;\n  state.currentFlags = currentFlags;\n  return result;\n}\n\nfunction genLookaroundAssertion({kind, negate, alternatives}, _, gen) {\n  const prefix = `${kind === NodeLookaroundAssertionKinds.lookahead ? '' : '<'}${negate ? '!' : '='}`;\n  return `(?${prefix}${alternatives.map(gen).join('|')})`;\n}\n\nfunction genRecursion({ref}, state) {\n  const limit = state.recursionLimit;\n  // Using the syntax supported by `regex-recursion`\n  return ref === 0 ? `(?R=${limit})` : r`\\g<${ref}&R=${limit}>`;\n}\n\n/**\nGiven a `CharacterClassRange` node, returns an array of chars that are a case variant of a char in\nthe range, and aren't already in the range.\n*/\nfunction getCasesOutsideCharClassRange(node, options) {\n  const firstOnly = !!options?.firstOnly;\n  const min = node.min.value;\n  const max = node.max.value;\n  const found = [];\n  // Avoid unneeded work. Assumptions (per Unicode 16):\n  // - No case variants cross the Basic Multilingual Plane boundary\n  // - No cased chars appear beyond the Supplementary Multilingual Plane\n  if ((min < 65 && (max === 0xFFFF || max >= 0x1FFFF)) || (min === 0x10000 && max >= 0x1FFFF)) {\n    return found;\n  }\n  for (let i = min; i <= max; i++) {\n    const char = cp(i);\n    if (!charHasCase(char)) {\n      continue;\n    }\n    const charsOutsideRange = getIgnoreCaseMatchChars(char).filter(caseOfChar => {\n      const num = caseOfChar.codePointAt(0);\n      return num < min || num > max;\n    });\n    if (charsOutsideRange.length) {\n      found.push(...charsOutsideRange);\n      if (firstOnly) {\n        break;\n      }\n    }\n  }\n  return found;\n}\n\n// This shouldn't modifiy any char that has case\nfunction getCharEscape(codePoint, {escDigit, inCharClass, useFlagV}) {\n  if (CharCodeEscapeMap.has(codePoint)) {\n    return CharCodeEscapeMap.get(codePoint);\n  }\n  if (\n    // Control chars, etc.; condition modeled on the Chrome developer console's display for strings\n    codePoint < 32 || (codePoint > 126 && codePoint < 160) ||\n    // Unicode planes 4-16; unassigned, special purpose, and private use area\n    codePoint > 0x3FFFF ||\n    // Avoid corrupting a preceding backref by immediately following it with a literal digit\n    (escDigit && isDigitCharCode(codePoint))\n  ) {\n    // Don't convert codePoint `0` to `\\0` since that's corruptible by following literal digits\n    return codePoint > 0xFF ?\n      `\\\\u{${codePoint.toString(16).toUpperCase()}}` :\n      `\\\\x${codePoint.toString(16).toUpperCase().padStart(2, '0')}`;\n  }\n  const escapeChars = inCharClass ?\n    (useFlagV ? CharClassEscapeCharsFlagV : CharClassEscapeChars) :\n    BaseEscapeChars;\n  const char = cp(codePoint);\n  return (escapeChars.has(char) ? '\\\\' : '') + char;\n}\n\nfunction getCodePointRangesFromChars(chars) {\n  const codePoints = chars.map(char => char.codePointAt(0)).sort((a, b) => a - b);\n  const values = [];\n  let start = null;\n  for (let i = 0; i < codePoints.length; i++) {\n    if (codePoints[i + 1] === codePoints[i] + 1) {\n      start ??= codePoints[i];\n    } else if (start === null) {\n      values.push(codePoints[i]);\n    } else {\n      values.push([start, codePoints[i]]);\n      start = null;\n    }\n  }\n  return values;\n}\n\nfunction getGroupPrefix(atomic, flagMods, useFlagMods) {\n  if (atomic) {\n    return '>';\n  }\n  let mods = '';\n  if (flagMods && useFlagMods) {\n    const {enable, disable} = flagMods;\n    mods =\n      (enable?.ignoreCase ? 'i' : '') +\n      (enable?.dotAll ? 's' : '') +\n      (disable ? '-' : '') +\n      (disable?.ignoreCase ? 'i' : '') +\n      (disable?.dotAll ? 's' : '');\n  }\n  return `${mods}:`;\n}\n\nfunction getQuantifierStr({min, max, kind}) {\n  let base;\n  if (!min && max === 1) {\n    base = '?';\n  } else if (!min && max === Infinity) {\n    base = '*';\n  } else if (min === 1 && max === Infinity) {\n    base = '+';\n  } else if (min === max) {\n    base = `{${min}}`;\n  } else {\n    base = `{${min},${max === Infinity ? '' : max}}`;\n  }\n  return base + {\n    greedy: '',\n    lazy: '?',\n    possessive: '+',\n  }[kind];\n}\n\nfunction isAnyGroup({type}) {\n  return type === NodeTypes.Group ||\n    type === NodeTypes.CapturingGroup ||\n    type === NodeTypes.LookaroundAssertion;\n}\n\nfunction isDigitCharCode(value) {\n  return value > 47 && value < 58;\n}\n\nfunction isLiteralHyphen({type, value}) {\n  return type === NodeTypes.Character && value === 45;\n}\n\nexport {\n  generate,\n};\n", "import {getOrInsert, throwIfNot} from './utils.js';\n\n/**\n@typedef {{\n  hiddenCaptures?: Array<number>;\n  lazyCompile?: boolean;\n  strategy?: string?;\n  transfers?: Array<[number, Array<number>]>;\n}} EmulatedRegExpOptions\n*/\n\n/**\nWorks the same as JavaScript's native `RegExp` constructor in all contexts, but can be given\nresults from `toRegExpDetails` to produce the same result as `toRegExp`.\n*/\nclass EmulatedRegExp extends RegExp {\n  /**\n  @type {Map<number, {\n    hidden?: true;\n    transferTo?: number;\n  }>}\n  */\n  #captureMap = new Map();\n\n  /**\n  @type {RegExp | EmulatedRegExp | null}\n  */\n  #compiled = null;\n\n  /**\n  @type {string}\n  */\n  #pattern;\n\n  /**\n  @type {Map<number, string>?}\n  */\n  #nameMap = null;\n\n  /**\n  @type {string?}\n  */\n  #strategy = null;\n\n  /**\n  Can be used to serialize the instance.\n  @type {EmulatedRegExpOptions}\n  */\n  rawOptions = {};\n\n  // Override the getter with one that works with lazy-compiled regexes\n  get source() {\n    return this.#pattern || '(?:)';\n  }\n\n  /**\n  @overload\n  @param {string} pattern\n  @param {string} [flags]\n  @param {EmulatedRegExpOptions} [options]\n  */\n  /**\n  @overload\n  @param {EmulatedRegExp} pattern\n  @param {string} [flags]\n  */\n  constructor(pattern, flags, options) {\n    const lazyCompile = !!options?.lazyCompile;\n    if (pattern instanceof RegExp) {\n      // Argument `options` isn't provided when regexes are copied, including as part of the\n      // internal handling of string methods `matchAll` and `split`\n      if (options) {\n        throw new Error('Cannot provide options when copying a regexp');\n      }\n      const re = pattern; // Alias for readability\n      super(re, flags);\n      this.#pattern = re.source;\n      if (re instanceof EmulatedRegExp) {\n        this.#captureMap = re.#captureMap;\n        this.#nameMap = re.#nameMap;\n        this.#strategy = re.#strategy;\n        this.rawOptions = re.rawOptions;\n      }\n    } else {\n      const opts = {\n        hiddenCaptures: [],\n        strategy: null,\n        transfers: [],\n        ...options,\n      };\n      super(lazyCompile ? '' : pattern, flags);\n      this.#pattern = pattern;\n      this.#captureMap = createCaptureMap(opts.hiddenCaptures, opts.transfers);\n      this.#strategy = opts.strategy;\n      // Don't add default values from `opts` since this gets serialized\n      this.rawOptions = options ?? {};\n    }\n    if (!lazyCompile) {\n      this.#compiled = this;\n    }\n  }\n\n  /**\n  Called internally by all String/RegExp methods that use regexes.\n  @override\n  @param {string} str\n  @returns {RegExpExecArray?}\n  */\n  exec(str) {\n    // Lazy compilation\n    if (!this.#compiled) {\n      const {lazyCompile, ...rest} = this.rawOptions;\n      this.#compiled = new EmulatedRegExp(this.#pattern, this.flags, rest);\n    }\n\n    const useLastIndex = this.global || this.sticky;\n    const pos = this.lastIndex;\n\n    if (this.#strategy === 'clip_search' && useLastIndex && pos) {\n      // Reset since this tests on a sliced string that we want to match at the start of\n      this.lastIndex = 0;\n      // Slicing the string can lead to mismatches when three edge cases are stacked on each other:\n      // 1. An uncommon use of `\\G` that relies on `clip_search`, combined with...\n      // 2. Lookbehind that searches behind the search start (not match start) position...\n      // 3. During a search when the regex's `lastIndex` isn't `0`.\n      // The `clip_search` strategy is therefore only allowed when lookbehind isn't present, if\n      // using strict `accuracy`\n      const match = this.#execCore(str.slice(pos));\n      if (match) {\n        adjustMatchDetailsForOffset(match, pos, str, this.hasIndices);\n        this.lastIndex += pos;\n      }\n      return match;\n    }\n\n    return this.#execCore(str);\n  }\n\n  /**\n  Adds support for hidden and transfer captures.\n  @param {string} str\n  @returns\n  */\n  #execCore(str) {\n    // Support lazy compilation\n    this.#compiled.lastIndex = this.lastIndex;\n    const match = super.exec.call(this.#compiled, str);\n    this.lastIndex = this.#compiled.lastIndex;\n\n    if (!match || !this.#captureMap.size) {\n      return match;\n    }\n\n    const matchCopy = [...match];\n    // Empty all but the first value of the array while preserving its other properties\n    match.length = 1;\n    let indicesCopy;\n    if (this.hasIndices) {\n      indicesCopy = [...match.indices];\n      match.indices.length = 1;\n    }\n    const mappedNums = [0];\n    for (let i = 1; i < matchCopy.length; i++) {\n      const {hidden, transferTo} = this.#captureMap.get(i) ?? {};\n      if (hidden) {\n        mappedNums.push(null);\n      } else {\n        mappedNums.push(match.length);\n        match.push(matchCopy[i]);\n        if (this.hasIndices) {\n          match.indices.push(indicesCopy[i]);\n        }\n      }\n\n      // Only transfer if the capture participated in the match\n      if (transferTo && matchCopy[i] !== undefined) {\n        const to = throwIfNot(mappedNums[transferTo]);\n        match[to] = matchCopy[i];\n        if (this.hasIndices) {\n          match.indices[to] = indicesCopy[i];\n        }\n        if (match.groups) {\n          if (!this.#nameMap) {\n            // Generate and cache the first time it's needed\n            this.#nameMap = createNameMap(this.source);\n          }\n          const name = this.#nameMap.get(transferTo);\n          if (name) {\n            match.groups[name] = matchCopy[i];\n            if (this.hasIndices) {\n              match.indices.groups[name] = indicesCopy[i];\n            }\n          }\n        }\n      }\n    }\n\n    return match;\n  }\n}\n\nfunction adjustMatchDetailsForOffset(match, offset, input, hasIndices) {\n  match.index += offset;\n  match.input = input;\n  if (hasIndices) {\n    const indices = match.indices;\n    for (let i = 0; i < indices.length; i++) {\n      const arr = indices[i];\n      if (arr) {\n        // Replace the array rather than updating values since the keys of `match.indices` and\n        // `match.indices.groups` share their value arrays by reference. Need to be precise in case\n        // they were previously altered separately\n        indices[i] = [arr[0] + offset, arr[1] + offset];\n      }\n    }\n    const groupIndices = indices.groups;\n    if (groupIndices) {\n      Object.keys(groupIndices).forEach(key => {\n        const arr = groupIndices[key];\n        if (arr) {\n          groupIndices[key] = [arr[0] + offset, arr[1] + offset];\n        }\n      });\n    }\n  }\n}\n\n/**\nBuild the capturing group map, with hidden/transfer groups marked to indicate their submatches\nshould get special handling in match results.\n@param {Array<number>} hiddenCaptures\n@param {Array<[number, Array<number>]>} transfers\n@returns {Map<number, {\n  hidden?: true;\n  transferTo?: number;\n}>}\n*/\nfunction createCaptureMap(hiddenCaptures, transfers) {\n  const captureMap = new Map();\n  for (const num of hiddenCaptures) {\n    captureMap.set(num, {\n      hidden: true,\n    });\n  }\n  for (const [to, from] of transfers) {\n    for (const num of from) {\n      getOrInsert(captureMap, num, {}).transferTo = to;\n    }\n  }\n  return captureMap;\n}\n\n/**\n@param {string} pattern\n@returns {Map<number, string>}\n*/\nfunction createNameMap(pattern) {\n  const re = /(?<capture>\\((?:\\?<(?![=!])(?<name>[^>]+)>|(?!\\?)))|\\\\?./gsu;\n  const map = new Map();\n  let numCharClassesOpen = 0;\n  let numCaptures = 0;\n  let match;\n  while ((match = re.exec(pattern))) {\n    const {0: m, groups: {capture, name}} = match;\n    // Relies on no unescaped literal `[` in char classes (valid in JS if not using flag v), but\n    // this library's generator never produces unescaped literal `[` even with `target` ES2018 (see\n    // `CharClassEscapeChars`)\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n      if (capture) {\n        numCaptures++;\n        if (name) {\n          map.set(numCaptures, name);\n        }\n      }\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n  return map;\n}\n\nexport {\n  EmulatedRegExp,\n};\n", "import {transform} from './transform.js';\nimport {generate} from './generate.js';\nimport {Accuracy, getOptions, Target} from './options.js';\nimport {EmulatedRegExp} from './subclass.js';\nimport {JsUnicodePropertyMap} from './unicode.js';\nimport {parse} from 'oniguruma-parser/parser';\nimport {atomic, possessive} from 'regex/internals';\nimport {recursion} from 'regex-recursion';\n\n// The validation and transformation for Oniguruma's unique syntax and behavior differences\n// compared to native JS RegExp is layered into all steps of the compilation process:\n// 1. Parser: Uses `oniguruma-parser` to build an Oniguruma AST, which accounts for many\n//    differences between Oniguruma and JS.\n// 2. Transformer: Converts the Oniguruma AST to a Regex+ AST that preserves all Oniguruma\n//    behavior. This is true even in cases of non-native-JS features that are supported by both\n//    Regex+ and Oniguruma but with subtly different behavior in each (subroutines, flag x).\n// 3. Generator: Converts the Regex+ AST to a Regex+ pattern, flags, and options.\n// 4. Postprocessing: Regex+ internals and plugins are used to transpile several remaining features\n//    (atomic groups, possessive quantifiers, recursion). Regex+ uses a strict superset of JS\n//    RegExp syntax, so using it allows this library to benefit from not reinventing the wheel for\n//    complex features that Regex+ already knows how to transpile to JS.\n\n/**\n@typedef {{\n  accuracy?: keyof Accuracy;\n  avoidSubclass?: boolean;\n  flags?: string;\n  global?: boolean;\n  hasIndices?: boolean;\n  lazyCompileLength?: number;\n  rules?: {\n    allowOrphanBackrefs?: boolean;\n    asciiWordBoundaries?: boolean;\n    captureGroup?: boolean;\n    recursionLimit?: number;\n    singleline?: boolean;\n  };\n  target?: keyof Target;\n  verbose?: boolean;\n}} ToRegExpOptions\n*/\n\n/**\nAccepts an Oniguruma pattern and returns an equivalent JavaScript `RegExp`.\n@param {string} pattern Oniguruma regex pattern.\n@param {ToRegExpOptions} [options]\n@returns {RegExp | EmulatedRegExp}\n*/\nfunction toRegExp(pattern, options) {\n  const d = toRegExpDetails(pattern, options);\n  if (d.options) {\n    return new EmulatedRegExp(d.pattern, d.flags, d.options);\n  }\n  return new RegExp(d.pattern, d.flags);\n}\n\n/**\nAccepts an Oniguruma pattern and returns the details for an equivalent JavaScript `RegExp`.\n@param {string} pattern Oniguruma regex pattern.\n@param {ToRegExpOptions} [options]\n@returns {{\n  pattern: string;\n  flags: string;\n  options?: import('./subclass.js').EmulatedRegExpOptions;\n}}\n*/\nfunction toRegExpDetails(pattern, options) {\n  const opts = getOptions(options);\n  const onigurumaAst = parse(pattern, {\n    flags: opts.flags,\n    normalizeUnknownPropertyNames: true,\n    rules: {\n      captureGroup: opts.rules.captureGroup,\n      singleline: opts.rules.singleline,\n    },\n    skipBackrefValidation: opts.rules.allowOrphanBackrefs,\n    unicodePropertyMap: JsUnicodePropertyMap,\n  });\n  const regexPlusAst = transform(onigurumaAst, {\n    accuracy: opts.accuracy,\n    asciiWordBoundaries: opts.rules.asciiWordBoundaries,\n    avoidSubclass: opts.avoidSubclass,\n    bestEffortTarget: opts.target,\n  });\n  const generated = generate(regexPlusAst, opts);\n  const recursionResult = recursion(generated.pattern, {\n    captureTransfers: generated._captureTransfers,\n    hiddenCaptures: generated._hiddenCaptures,\n    mode: 'external',\n  });\n  const possessiveResult = possessive(recursionResult.pattern);\n  const atomicResult = atomic(possessiveResult.pattern, {\n    captureTransfers: recursionResult.captureTransfers,\n    hiddenCaptures: recursionResult.hiddenCaptures,\n  });\n  const details = {\n    pattern: atomicResult.pattern,\n    flags: `${opts.hasIndices ? 'd' : ''}${opts.global ? 'g' : ''}${generated.flags}${generated.options.disable.v ? 'u' : 'v'}`,\n  };\n  if (opts.avoidSubclass) {\n    if (opts.lazyCompileLength !== Infinity) {\n      throw new Error('Lazy compilation requires subclass');\n    }\n  } else {\n    // Sort isn't required; only for readability when serialized\n    const hiddenCaptures = atomicResult.hiddenCaptures.sort((a, b) => a - b);\n    // Change the map to the `EmulatedRegExp` format, serializable as JSON\n    const transfers = Array.from(atomicResult.captureTransfers);\n    const strategy = regexPlusAst._strategy;\n    const lazyCompile = details.pattern.length >= opts.lazyCompileLength;\n    if (hiddenCaptures.length || transfers.length || strategy || lazyCompile) {\n      details.options = {\n        ...(hiddenCaptures.length && {hiddenCaptures}),\n        ...(transfers.length && {transfers}),\n        ...(strategy && {strategy}),\n        ...(lazyCompile && {lazyCompile}),\n      };\n    }\n  }\n  return details;\n}\n\n// function toOnigurumaAst(pattern, options) {\n//   return parse(pattern, {\n//     flags: options?.flags ?? '',\n//     normalizeUnknownPropertyNames: true,\n//     rules: options?.rules ?? {},\n//     unicodePropertyMap: JsUnicodePropertyMap,\n//   });\n// }\n\n// function toRegexPlusAst(pattern, options) {\n//   return transform(toOnigurumaAst(pattern, options));\n// }\n\nexport {\n  EmulatedRegExp,\n  toRegExp,\n  toRegExpDetails,\n  // toOnigurumaAst,\n  // toRegexPlusAst,\n};\n"],
  "mappings": "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",
  "names": ["range", "slug", "node", "recursion", "createAlternative", "createGroup", "NodeAssertionKinds", "NodeCharacterClassKinds", "NodeCharacterSetKinds", "NodeLookaroundAssertionKinds", "NodeTypes", "traverse", "atomic", "parse"]
}
