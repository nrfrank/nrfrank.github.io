{
  "version": 3,
  "sources": ["../../src/parser/parse.js"],
  "sourcesContent": ["import {TokenCharacterSetKinds, TokenDirectiveKinds, TokenGroupKinds, tokenize, TokenQuantifierKinds, TokenTypes} from '../tokenizer/tokenize.js';\nimport {getOrInsert, PosixClassNames, r, throwIfNot} from '../utils.js';\n\n/**\n@typedef {\n  'AbsentFunction' |\n  'Alternative' |\n  'Assertion' |\n  'Backreference' |\n  'CapturingGroup' |\n  'Character' |\n  'CharacterClass' |\n  'CharacterClassRange' |\n  'CharacterSet' |\n  'Directive' |\n  'Flags' |\n  'Group' |\n  'LookaroundAssertion' |\n  'Pattern' |\n  'Quantifier' |\n  'Regex' |\n  'Subroutine'\n} NodeType\n*/\nconst NodeTypes = /** @type {const} */ ({\n  AbsentFunction: 'AbsentFunction',\n  Alternative: 'Alternative',\n  Assertion: 'Assertion',\n  Backreference: 'Backreference',\n  CapturingGroup: 'CapturingGroup',\n  Character: 'Character',\n  CharacterClass: 'CharacterClass',\n  CharacterClassRange: 'CharacterClassRange',\n  CharacterSet: 'CharacterSet',\n  Directive: 'Directive',\n  Flags: 'Flags',\n  Group: 'Group',\n  LookaroundAssertion: 'LookaroundAssertion',\n  Pattern: 'Pattern',\n  Quantifier: 'Quantifier',\n  Regex: 'Regex',\n  Subroutine: 'Subroutine',\n  // Type `Recursion` is used only by the `oniguruma-to-es` transformer for Regex+ ASTs\n  // [TODO] Refactor to remove this type: <github.com/slevithan/oniguruma-parser/issues/3>\n  Recursion: 'Recursion',\n});\n\n/**\n@typedef {RegexNode} OnigurumaAst\n@typedef {\n  AbsentFunctionNode |\n  AlternativeNode |\n  AssertionNode |\n  BackreferenceNode |\n  CapturingGroupNode |\n  CharacterNode |\n  CharacterClassNode |\n  CharacterClassRangeNode |\n  CharacterSetNode |\n  DirectiveNode |\n  FlagsNode |\n  GroupNode |\n  LookaroundAssertionNode |\n  PatternNode |\n  QuantifierNode |\n  RegexNode |\n  SubroutineNode\n} Node\n@typedef {\n  AbsentFunctionNode |\n  CapturingGroupNode |\n  GroupNode |\n  LookaroundAssertionNode |\n  PatternNode\n} AlternativeContainerNode\n@typedef {\n  AbsentFunctionNode |\n  AssertionNode |\n  BackreferenceNode |\n  CapturingGroupNode |\n  CharacterNode |\n  CharacterClassNode |\n  CharacterSetNode |\n  DirectiveNode |\n  GroupNode |\n  LookaroundAssertionNode |\n  QuantifierNode |\n  SubroutineNode\n} AlternativeElementNode\n@typedef {\n  CharacterNode |\n  CharacterClassNode |\n  CharacterClassRangeNode |\n  CharacterSetNode\n} CharacterClassElementNode\n@typedef {\n  AbsentFunctionNode |\n  BackreferenceNode |\n  CapturingGroupNode |\n  CharacterNode |\n  CharacterClassNode |\n  CharacterSetNode |\n  GroupNode |\n  QuantifierNode |\n  SubroutineNode\n} QuantifiableNode\n*/\n\n// See <github.com/slevithan/oniguruma-to-es/issues/13>\nconst NodeAbsentFunctionKinds = /** @type {const} */ ({\n  repeater: 'repeater',\n});\n\nconst NodeAssertionKinds = /** @type {const} */ ({\n  grapheme_boundary: 'grapheme_boundary',\n  line_end: 'line_end',\n  line_start: 'line_start',\n  search_start: 'search_start',\n  string_end: 'string_end',\n  string_end_newline: 'string_end_newline',\n  string_start: 'string_start',\n  word_boundary: 'word_boundary',\n});\n\nconst NodeCharacterClassKinds = /** @type {const} */ ({\n  union: 'union',\n  intersection: 'intersection',\n});\n\n// Identical values\nconst NodeCharacterSetKinds = TokenCharacterSetKinds;\nconst NodeDirectiveKinds = TokenDirectiveKinds;\nconst NodeQuantifierKinds = TokenQuantifierKinds;\n\nconst NodeLookaroundAssertionKinds = /** @type {const} */ ({\n  lookahead: 'lookahead',\n  lookbehind: 'lookbehind',\n});\n\n/**\n@param {string} pattern Oniguruma pattern.\n@param {{\n  flags?: string;\n  normalizeUnknownPropertyNames?: boolean;\n  rules?: {\n    captureGroup?: boolean;\n    singleline?: boolean;\n  };\n  skipBackrefValidation?: boolean;\n  skipLookbehindValidation?: boolean;\n  skipPropertyNameValidation?: boolean;\n  unicodePropertyMap?: Map<string, string>?;\n}} [options]\n@returns {OnigurumaAst}\n*/\nfunction parse(pattern, options = {}) {\n  const opts = {\n    flags: '',\n    normalizeUnknownPropertyNames: false,\n    skipBackrefValidation: false,\n    skipLookbehindValidation: false,\n    skipPropertyNameValidation: false,\n    unicodePropertyMap: null,\n    ...options,\n    rules: {\n      captureGroup: false, // `ONIG_OPTION_CAPTURE_GROUP`\n      singleline: false, // `ONIG_OPTION_SINGLELINE`\n      ...options.rules,\n    },\n  };\n  const tokenized = tokenize(pattern, {\n    // Limit to the tokenizer's options\n    flags: opts.flags,\n    rules: {\n      captureGroup: opts.rules.captureGroup,\n      singleline: opts.rules.singleline,\n    },\n  });\n  const context = {\n    capturingGroups: [],\n    current: 0,\n    hasNumberedRef: false,\n    namedGroupsByName: new Map(),\n    normalizeUnknownPropertyNames: opts.normalizeUnknownPropertyNames,\n    parent: null,\n    skipBackrefValidation: opts.skipBackrefValidation,\n    skipLookbehindValidation: opts.skipLookbehindValidation,\n    skipPropertyNameValidation: opts.skipPropertyNameValidation,\n    subroutines: [],\n    token: null,\n    tokens: tokenized.tokens,\n    unicodePropertyMap: opts.unicodePropertyMap,\n    walk,\n  };\n  function walk(parent, state) {\n    const token = tokenized.tokens[context.current];\n    context.parent = parent;\n    context.token = token;\n    // Advance for the next iteration\n    context.current++;\n    switch (token.type) {\n      case TokenTypes.Alternator:\n        // Top-level only; groups handle their own alternators\n        return createAlternative();\n      case TokenTypes.Assertion:\n        return createAssertionFromToken(token);\n      case TokenTypes.Backreference:\n        return parseBackreference(context);\n      case TokenTypes.Character:\n        return createCharacter(token.value, {useLastValid: !!state.isCheckingRangeEnd});\n      case TokenTypes.CharacterClassHyphen:\n        return parseCharacterClassHyphen(context, state);\n      case TokenTypes.CharacterClassOpen:\n        return parseCharacterClassOpen(context, state);\n      case TokenTypes.CharacterSet:\n        return parseCharacterSet(context);\n      case TokenTypes.Directive:\n        return createDirective(\n          throwIfNot(NodeDirectiveKinds[token.kind], `Unexpected directive kind \"${token.kind}\"`),\n          {flags: token.flags}\n        );\n      case TokenTypes.GroupOpen:\n        return parseGroupOpen(context, state);\n      case TokenTypes.Quantifier:\n        return parseQuantifier(context);\n      case TokenTypes.Subroutine:\n        return parseSubroutine(context);\n      default:\n        throw new Error(`Unexpected token type \"${token.type}\"`);\n    }\n  }\n  const ast = createRegex(createPattern(), createFlags(tokenized.flags));\n  let top = ast.pattern.alternatives[0];\n  while (context.current < tokenized.tokens.length) {\n    const node = walk(top, {});\n    if (node.type === NodeTypes.Alternative) {\n      ast.pattern.alternatives.push(node);\n      top = node;\n    } else {\n      top.elements.push(node);\n    }\n  }\n  // `context` updated by preceding `walk` loop\n  const {capturingGroups, hasNumberedRef, namedGroupsByName, subroutines} = context;\n  // Validation that requires knowledge about the complete pattern\n  if (hasNumberedRef && namedGroupsByName.size && !opts.rules.captureGroup) {\n    throw new Error('Numbered backref/subroutine not allowed when using named capture');\n  }\n  for (const {ref} of subroutines) {\n    if (typeof ref === 'number') {\n      // Relative nums are already resolved\n      if (ref > capturingGroups.length) {\n        throw new Error(`Subroutine uses a group number that's not defined`);\n      }\n    } else if (!namedGroupsByName.has(ref)) {\n      throw new Error(r`Subroutine uses a group name that's not defined \"\\g<${ref}>\"`);\n    } else if (namedGroupsByName.get(ref).length > 1) {\n      throw new Error(r`Subroutine uses a duplicate group name \"\\g<${ref}>\"`);\n    }\n  }\n  return ast;\n}\n\n// Supported (if the backref appears to the right of the reffed capture's opening paren):\n// - `\\k<name>`, `\\k'name'`\n// - When named capture not used:\n//   - `\\n`, `\\nn`, `\\nnn`\n//   - `\\k<n>`, `\\k'n'\n//   - `\\k<-n>`, `\\k'-n'`\n// Unsupported:\n// - `\\k<+n>`, `\\k'+n'` - Note that, Unlike Oniguruma, Onigmo doesn't support this as special\n//   syntax and therefore considers it a valid group name.\n// - Backref with recursion level (with num or name): `\\k<n+level>`, `\\k<n-level>`, etc.\n//   (Onigmo also supports `\\k<-n+level>`, `\\k<-n-level>`, etc.)\n// Backrefs in Onig use multiplexing for duplicate group names (the rules can be complicated when\n// overlapping with subroutines), but a `Backreference`'s simple `ref` prop doesn't capture these\n// details so multiplexed ref pointers need to be derived when working with the AST\nfunction parseBackreference(context) {\n  const {raw} = context.token;\n  const hasKWrapper = /^\\\\k[<']/.test(raw);\n  const ref = hasKWrapper ? raw.slice(3, -1) : raw.slice(1);\n  const fromNum = (num, isRelative = false) => {\n    const numCapturesToLeft = context.capturingGroups.length;\n    let orphan = false;\n    // Note: It's not an error for numbered backrefs to come before their referenced group in Onig,\n    // but an error is the best path for this library because:\n    // 1. Most placements are mistakes and can never match (based on the Onig behavior for backrefs\n    //    to nonparticipating groups).\n    // 2. Erroring matches the behavior of named backrefs.\n    // 3. The edge cases where they're matchable rely on rules for backref resetting within\n    //    quantified groups that are different in JS and aren't emulatable. Note that it's not a\n    //    backref in the first place if using `\\10` or higher and not as many capturing groups are\n    //    defined to the left (it's an octal or identity escape).\n    // [TODO] Ideally this would be refactored to include the backref in the AST when it's not an\n    // error in Onig (due to the reffed group being defined to the right), and the error handling\n    // would move to the `oniguruma-to-es` transformer\n    if (num > numCapturesToLeft) {\n      // [WARNING] Skipping the error breaks assumptions and might create edge case issues, since\n      // backrefs are required to come after their captures; unfortunately this option is needed\n      // for TextMate grammars\n      if (context.skipBackrefValidation) {\n        orphan = true;\n      } else {\n        throw new Error(`Not enough capturing groups defined to the left \"${raw}\"`);\n      }\n    }\n    context.hasNumberedRef = true;\n    return createBackreference(isRelative ? numCapturesToLeft + 1 - num : num, {orphan});\n  };\n  if (hasKWrapper) {\n    const numberedRef = /^(?<sign>-?)0*(?<num>[1-9]\\d*)$/.exec(ref);\n    if (numberedRef) {\n      return fromNum(+numberedRef.groups.num, !!numberedRef.groups.sign);\n    }\n    // Invalid in a backref name even when valid in a group name\n    if (/[-+]/.test(ref)) {\n      throw new Error(`Invalid backref name \"${raw}\"`);\n    }\n    if (!context.namedGroupsByName.has(ref)) {\n      throw new Error(`Group name not defined to the left \"${raw}\"`);\n    }\n    return createBackreference(ref);\n  }\n  return fromNum(+ref);\n}\n\nfunction parseCharacterClassHyphen(context, state) {\n  const {parent, tokens, walk} = context;\n  const prevSiblingNode = parent.elements.at(-1);\n  const nextToken = tokens[context.current];\n  if (\n    !state.isCheckingRangeEnd &&\n    prevSiblingNode &&\n    prevSiblingNode.type !== NodeTypes.CharacterClass &&\n    prevSiblingNode.type !== NodeTypes.CharacterClassRange &&\n    nextToken &&\n    nextToken.type !== TokenTypes.CharacterClassOpen &&\n    nextToken.type !== TokenTypes.CharacterClassClose &&\n    nextToken.type !== TokenTypes.CharacterClassIntersector\n  ) {\n    const nextNode = walk(parent, {\n      ...state,\n      isCheckingRangeEnd: true,\n    });\n    if (prevSiblingNode.type === NodeTypes.Character && nextNode.type === NodeTypes.Character) {\n      parent.elements.pop();\n      return createCharacterClassRange(prevSiblingNode, nextNode);\n    }\n    throw new Error('Invalid character class range');\n  }\n  // Literal hyphen\n  return createCharacter(45);\n}\n\nfunction parseCharacterClassOpen(context, state) {\n  const {token, tokens, walk} = context;\n  const firstClassToken = tokens[context.current];\n  const intersections = [createCharacterClass()];\n  let nextToken = throwIfUnclosedCharacterClass(firstClassToken);\n  while (nextToken.type !== TokenTypes.CharacterClassClose) {\n    if (nextToken.type === TokenTypes.CharacterClassIntersector) {\n      intersections.push(createCharacterClass());\n      // Skip the intersector\n      context.current++;\n    } else {\n      const cc = intersections.at(-1);\n      cc.elements.push(walk(cc, state));\n    }\n    nextToken = throwIfUnclosedCharacterClass(tokens[context.current], firstClassToken);\n  }\n  const node = createCharacterClass({negate: token.negate});\n  if (intersections.length === 1) {\n    node.elements = intersections[0].elements;\n  } else {\n    node.kind = NodeCharacterClassKinds.intersection;\n    node.elements = intersections.map(cc => cc.elements.length === 1 ? cc.elements[0] : cc);\n  }\n  // Skip the closing square bracket\n  context.current++;\n  return node;\n}\n\nfunction parseCharacterSet({token, normalizeUnknownPropertyNames, skipPropertyNameValidation, unicodePropertyMap}) {\n  let {kind, negate, value} = token;\n  if (kind === TokenCharacterSetKinds.property) {\n    const normalized = slug(value);\n    // Don't treat as POSIX if it's in the provided list of Unicode property names\n    if (PosixClassNames.has(normalized) && !unicodePropertyMap?.has(normalized)) {\n      kind = TokenCharacterSetKinds.posix;\n      value = normalized;\n    } else {\n      return createUnicodeProperty(value, {\n        negate,\n        normalizeUnknownPropertyNames,\n        skipPropertyNameValidation,\n        unicodePropertyMap,\n      });\n    }\n  }\n  if (kind === TokenCharacterSetKinds.posix) {\n    return createPosixClass(value, {negate});\n  }\n  return createCharacterSet(kind, {negate});\n}\n\nfunction parseGroupOpen(context, state) {\n  const {token, tokens, capturingGroups, namedGroupsByName, skipLookbehindValidation, walk} = context;\n  let node = createByGroupKind(token);\n  const isAbsentFunction = node.type === NodeTypes.AbsentFunction;\n  const isLookbehind = node.kind === NodeLookaroundAssertionKinds.lookbehind;\n  const isNegLookbehind = isLookbehind && node.negate;\n  // Track capturing group details for backrefs and subroutines (before parsing the group's\n  // contents so nested groups with the same name are tracked in order)\n  if (node.type === NodeTypes.CapturingGroup) {\n    capturingGroups.push(node);\n    if (node.name) {\n      getOrInsert(namedGroupsByName, node.name, []).push(node);\n    }\n  }\n  // Don't allow nested absent functions\n  if (isAbsentFunction && state.isInAbsentFunction) {\n    // Is officially unsupported in Onig but doesn't throw, gives strange results\n    throw new Error('Nested absent function not supported by Oniguruma');\n  }\n  let nextToken = throwIfUnclosedGroup(tokens[context.current]);\n  while (nextToken.type !== TokenTypes.GroupClose) {\n    if (nextToken.type === TokenTypes.Alternator) {\n      node.alternatives.push(createAlternative());\n      // Skip the alternator\n      context.current++;\n    } else {\n      const alt = node.alternatives.at(-1);\n      const child = walk(alt, {\n        ...state,\n        isInAbsentFunction: state.isInAbsentFunction || isAbsentFunction,\n        isInLookbehind: state.isInLookbehind || isLookbehind,\n        isInNegLookbehind: state.isInNegLookbehind || isNegLookbehind,\n      });\n      alt.elements.push(child);\n      // Centralized validation of lookbehind contents\n      if ((isLookbehind || state.isInLookbehind) && !skipLookbehindValidation) {\n        // JS supports all features within lookbehind, but Onig doesn't. Absent functions of form\n        // `(?~|)` and `(?~|\u2026)` are also invalid in lookbehind (the `(?~\u2026)` and `(?~|\u2026|\u2026)` forms\n        // are allowed), but all forms with `(?~|` throw since they aren't yet supported\n        const msg = 'Lookbehind includes a pattern not allowed by Oniguruma';\n        if (isNegLookbehind || state.isInNegLookbehind) {\n          // - Invalid: `(?=\u2026)`, `(?!\u2026)`, capturing groups\n          // - Valid: `(?<=\u2026)`, `(?<!\u2026)`\n          if (\n            child.kind === NodeLookaroundAssertionKinds.lookahead ||\n            child.type === NodeTypes.CapturingGroup\n          ) {\n            throw new Error(msg);\n          }\n        } else {\n          // - Invalid: `(?=\u2026)`, `(?!\u2026)`, `(?<!\u2026)`\n          // - Valid: `(?<=\u2026)`, capturing groups\n          if (\n            child.kind === NodeLookaroundAssertionKinds.lookahead ||\n            (child.kind === NodeLookaroundAssertionKinds.lookbehind && child.negate)\n          ) {\n            throw new Error(msg);\n          }\n        }\n      }\n    }\n    nextToken = throwIfUnclosedGroup(tokens[context.current]);\n  }\n  // Skip the closing parenthesis\n  context.current++;\n  return node;\n}\n\nfunction parseQuantifier({token, parent}) {\n  const {min, max, kind} = token;\n  const quantifiedNode = parent.elements.at(-1);\n  if (\n    !quantifiedNode ||\n    quantifiedNode.type === NodeTypes.Assertion ||\n    quantifiedNode.type === NodeTypes.Directive ||\n    quantifiedNode.type === NodeTypes.LookaroundAssertion\n  ) {\n    throw new Error(`Quantifier requires a repeatable token`);\n  }\n  const node = createQuantifier(\n    quantifiedNode,\n    min,\n    max,\n    throwIfNot(NodeQuantifierKinds[kind], `Unexpected quantifier kind \"${kind}\"`)\n  );\n  parent.elements.pop();\n  return node;\n}\n\n// Onig subroutine behavior:\n// - Subroutines can appear before the groups they reference; ex: `\\g<1>(a)` is valid.\n// - Multiple subroutines can reference the same group.\n// - Subroutines can reference groups that themselves contain subroutines, followed to any depth.\n// - Subroutines can be used recursively, and `\\g<0>` recursively references the whole pattern.\n// - Subroutines can use relative references (backward or forward); ex: `\\g<+1>(.)\\g<-1>`.\n// - Subroutines don't get their own capturing group numbers; ex: `(.)\\g<1>\\2` is invalid.\n// - Subroutines use the flags that apply to their referenced group, so e.g.\n//   `(?-i)(?<a>a)(?i)\\g<a>` is fully case sensitive.\n// - Differences from PCRE/Perl/Regex+ subroutines:\n//   - Subroutines can't reference duplicate group names (though duplicate names are valid if no\n//     subroutines reference them).\n//   - Subroutines can't use absolute or relative numbers if named capture is used anywhere.\n//   - Named backrefs must be to the right of their group definition, so the backref in\n//     `\\g<a>\\k<a>(?<a>)` is invalid (not directly related to subroutines).\n//   - Subroutines don't restore capturing group match values (for backrefs) upon exit, so e.g.\n//     `(?<a>(?<b>[ab]))\\g<a>\\k<b>` matches `abb` but not `aba`; same for numbered.\n// The interaction of backref multiplexing (an Onig-specific feature) and subroutines is complex:\n// - Only the most recent value matched by a capturing group and its subroutines is considered for\n//   backref multiplexing, and this also applies to capturing groups nested within a group that's\n//   referenced by a subroutine.\n// - Although a subroutine can't reference a group with a duplicate name, it can reference a group\n//   with a nested capture whose name is duplicated (e.g. outside of the referenced group).\n//   - These duplicate names can then multiplex; but only the most recent value matched from within\n//     the outer group (or the subroutines that reference it) is available for multiplexing.\n//   - Ex: With `(?<a>(?<b>[123]))\\g<a>\\g<a>(?<b>0)\\k<b>`, the backref `\\k<b>` can only match `0`\n//     or whatever was matched by the most recently matched subroutine. If you took out `(?<b>0)`,\n//     no multiplexing would occur.\nfunction parseSubroutine(context) {\n  const {token, capturingGroups, subroutines} = context;\n  let ref = token.raw.slice(3, -1);\n  const numberedRef = /^(?<sign>[-+]?)0*(?<num>[1-9]\\d*)$/.exec(ref);\n  if (numberedRef) {\n    const num = +numberedRef.groups.num;\n    const numCapturesToLeft = capturingGroups.length;\n    context.hasNumberedRef = true;\n    ref = {\n      '': num,\n      '+': numCapturesToLeft + num,\n      '-': numCapturesToLeft + 1 - num,\n    }[numberedRef.groups.sign];\n    if (ref < 1) {\n      throw new Error('Invalid subroutine number');\n    }\n  // Special case for full-pattern recursion; can't be `+0`, `-0`, `00`, etc.\n  } else if (ref === '0') {\n    ref = 0;\n  }\n  const node = createSubroutine(ref);\n  subroutines.push(node);\n  return node;\n}\n\n/**\n@typedef {{\n  type: 'AbsentFunction';\n  kind: keyof NodeAbsentFunctionKinds;\n  alternatives: Array<AlternativeNode>;\n}} AbsentFunctionNode\n*/\n/**\n@param {keyof NodeAbsentFunctionKinds} kind\n@returns {AbsentFunctionNode}\n*/\nfunction createAbsentFunction(kind) {\n  if (kind !== NodeAbsentFunctionKinds.repeater) {\n    throw new Error(`Unexpected absent function kind \"${kind}\"`);\n  }\n  return {\n    type: NodeTypes.AbsentFunction,\n    kind,\n    alternatives: [createAlternative()],\n  };\n}\n\n/**\n@typedef {{\n  type: 'Alternative';\n  elements: Array<AlternativeElementNode>;\n}} AlternativeNode\n*/\n/**\n@returns {AlternativeNode}\n*/\nfunction createAlternative() {\n  return {\n    type: NodeTypes.Alternative,\n    elements: [],\n  };\n}\n\n/**\n@typedef {{\n  type: 'Assertion';\n  kind: keyof NodeAssertionKinds;\n  negate?: boolean;\n}} AssertionNode\n*/\n/**\n@param {keyof NodeAssertionKinds} kind\n@param {{\n  negate?: boolean;\n}} [options]\n@returns {AssertionNode}\n*/\nfunction createAssertion(kind, options) {\n  const node = {\n    type: NodeTypes.Assertion,\n    kind,\n  };\n  if (kind === NodeAssertionKinds.word_boundary || kind === NodeAssertionKinds.grapheme_boundary) {\n    node.negate = !!options?.negate;\n  }\n  return node;\n}\n\nfunction createAssertionFromToken({kind}) {\n  return createAssertion(\n    throwIfNot({\n      '^': NodeAssertionKinds.line_start,\n      '$': NodeAssertionKinds.line_end,\n      '\\\\A': NodeAssertionKinds.string_start,\n      '\\\\b': NodeAssertionKinds.word_boundary,\n      '\\\\B': NodeAssertionKinds.word_boundary,\n      '\\\\G': NodeAssertionKinds.search_start,\n      '\\\\y': NodeAssertionKinds.grapheme_boundary,\n      '\\\\Y': NodeAssertionKinds.grapheme_boundary,\n      '\\\\z': NodeAssertionKinds.string_end,\n      '\\\\Z': NodeAssertionKinds.string_end_newline,\n    }[kind], `Unexpected assertion kind \"${kind}\"`),\n    {negate: kind === r`\\B` || kind === r`\\Y`}\n  );\n}\n\n/**\n@typedef {{\n  type: 'Backreference';\n  ref: string | number;\n  orphan?: boolean;\n}} BackreferenceNode\n*/\n/**\n@param {string | number} ref\n@param {{\n  orphan?: boolean;\n}} [options]\n@returns {BackreferenceNode}\n*/\nfunction createBackreference(ref, options) {\n  const orphan = !!options?.orphan;\n  return {\n    type: NodeTypes.Backreference,\n    ref,\n    ...(orphan && {orphan}),\n  };\n}\n\nfunction createByGroupKind({flags, kind, name, negate, number}) {\n  switch (kind) {\n    case TokenGroupKinds.absent_repeater:\n      return createAbsentFunction(NodeAbsentFunctionKinds.repeater);\n    case TokenGroupKinds.atomic:\n      return createGroup({atomic: true});\n    case TokenGroupKinds.capturing:\n      return createCapturingGroup(number, name);\n    case TokenGroupKinds.group:\n      return createGroup({flags});\n    case TokenGroupKinds.lookahead:\n    case TokenGroupKinds.lookbehind:\n      return createLookaroundAssertion({\n        behind: kind === TokenGroupKinds.lookbehind,\n        negate,\n      });\n    default:\n      throw new Error(`Unexpected group kind \"${kind}\"`);\n  }\n}\n\n/**\n@typedef {{\n  type: 'CapturingGroup';\n  number: number;\n  name?: string;\n  alternatives: Array<AlternativeNode>;\n}} CapturingGroupNode\n*/\n/**\n@param {number} number\n@param {string} [name]\n@returns {CapturingGroupNode}\n*/\nfunction createCapturingGroup(number, name) {\n  const hasName = name !== undefined;\n  if (hasName && !isValidGroupName(name)) {\n    throw new Error(`Group name \"${name}\" invalid in Oniguruma`);\n  }\n  return {\n    type: NodeTypes.CapturingGroup,\n    number,\n    ...(hasName && {name}),\n    alternatives: [createAlternative()],\n  };\n}\n\n/**\n@typedef {{\n  type: 'Character';\n  value: number;\n}} CharacterNode\n*/\n/**\n@param {number} charCode\n@param {{\n  useLastValid?: boolean;\n}} [options]\n@returns {CharacterNode}\n*/\nfunction createCharacter(charCode, options) {\n  const opts = {\n    useLastValid: false,\n    ...options,\n  };\n  if (charCode > 0x10FFFF) {\n    const hex = charCode.toString(16);\n    if (opts.useLastValid) {\n      charCode = 0x10FFFF;\n    } else if (charCode > 0x13FFFF) {\n      throw new Error(`Invalid code point out of range \"\\\\x{${hex}}\"`);\n    } else {\n      throw new Error(`Invalid code point out of range in JS \"\\\\x{${hex}}\"`);\n    }\n  }\n  return {\n    type: NodeTypes.Character,\n    value: charCode,\n  };\n}\n\n/**\n@typedef {{\n  type: 'CharacterClass';\n  kind: keyof NodeCharacterClassKinds;\n  negate: boolean;\n  elements: Array<CharacterClassElementNode>;\n}} CharacterClassNode\n*/\n/**\n@param {{\n  kind?: keyof NodeCharacterClassKinds;\n  negate?: boolean;\n}} [options]\n@returns {CharacterClassNode}\n*/\nfunction createCharacterClass(options) {\n  const opts = {\n    kind: NodeCharacterClassKinds.union,\n    negate: false,\n    ...options,\n  };\n  return {\n    type: NodeTypes.CharacterClass,\n    kind: opts.kind,\n    negate: opts.negate,\n    elements: [],\n  };\n}\n\n/**\n@typedef {{\n  type: 'CharacterClassRange';\n  min: CharacterNode;\n  max: CharacterNode;\n}} CharacterClassRangeNode\n*/\n/**\n@param {CharacterNode} min\n@param {CharacterNode} max\n@returns {CharacterClassRangeNode}\n*/\nfunction createCharacterClassRange(min, max) {\n  if (max.value < min.value) {\n    throw new Error('Character class range out of order');\n  }\n  return {\n    type: NodeTypes.CharacterClassRange,\n    min,\n    max,\n  };\n}\n\n/**\n@typedef {{\n  type: 'CharacterSet';\n  kind: keyof NodeCharacterSetKinds;\n  value?: string;\n  negate?: boolean;\n  variableLength?: boolean;\n}} CharacterSetNode\n*/\n/**\n@param {keyof Omit<NodeCharacterSetKinds, 'posix' | 'property'>} kind\n@param {{\n  negate?: boolean;\n}} [options]\n@returns {\n  Omit<CharacterSetNode, 'value'> & {\n    kind: keyof Omit<NodeCharacterSetKinds, 'posix' | 'property'>;\n  }\n}\n*/\nfunction createCharacterSet(kind, options) {\n  const negate = !!options?.negate;\n  const node = {\n    type: NodeTypes.CharacterSet,\n    kind: throwIfNot(NodeCharacterSetKinds[kind], `Unexpected character set kind \"${kind}\"`),\n  };\n  if (\n    kind === TokenCharacterSetKinds.digit ||\n    kind === TokenCharacterSetKinds.hex ||\n    kind === TokenCharacterSetKinds.newline ||\n    kind === TokenCharacterSetKinds.space ||\n    kind === TokenCharacterSetKinds.word\n  ) {\n    node.negate = negate;\n  }\n  if (\n    kind === TokenCharacterSetKinds.grapheme ||\n    (kind === TokenCharacterSetKinds.newline && !negate)\n  ) {\n    node.variableLength = true;\n  }\n  return node;\n}\n\n/**\n@typedef {{\n  type: 'Directive';\n  kind: keyof NodeDirectiveKinds;\n  flags?: FlagGroupModifiers;\n}} DirectiveNode\n*/\n/**\n@param {keyof NodeDirectiveKinds} kind\n@param {{\n  flags?: FlagGroupModifiers;\n}} [options]\n@returns {DirectiveNode}\n*/\nfunction createDirective(kind, options) {\n  const node = {\n    type: NodeTypes.Directive,\n    kind,\n  };\n  // Can't optimize by simply creating a `Group` with a `flags` prop and wrapping the remainder of\n  // the open group or pattern in it, because the flag modifier's effect might extend across\n  // alternation. Ex: `a(?i)b|c` is equivalent to `a(?i:b)|(?i:c)`, not `a(?i:b|c)`\n  if (kind === NodeDirectiveKinds.flags) {\n    node.flags = options.flags;\n  }\n  return node;\n}\n\n/**\n@typedef {{\n  type: 'Flags';\n} & import('../tokenizer/tokenize.js').RegexFlags} FlagsNode\n*/\n/**\n@param {import('../tokenizer/tokenize.js').RegexFlags} flags\n@returns {FlagsNode}\n*/\nfunction createFlags(flags) {\n  return {\n    type: NodeTypes.Flags,\n    ...flags,\n  };\n}\n\n/**\n@typedef {{\n  enable?: import('../tokenizer/tokenize.js').FlagGroupSwitches;\n  disable?: import('../tokenizer/tokenize.js').FlagGroupSwitches;\n}} FlagGroupModifiers\n@typedef {{\n  type: 'Group';\n  atomic?: boolean;\n  flags?: FlagGroupModifiers;\n  alternatives: Array<AlternativeNode>;\n}} GroupNode\n*/\n/**\n@param {{\n  atomic?: boolean;\n  flags?: FlagGroupModifiers;\n}} [options]\n@returns {GroupNode}\n*/\nfunction createGroup(options) {\n  const atomic = options?.atomic;\n  const flags = options?.flags;\n  return {\n    type: NodeTypes.Group,\n    ...(atomic && {atomic}),\n    ...(flags && {flags}),\n    alternatives: [createAlternative()],\n  };\n}\n\n/**\n@typedef {{\n  type: 'LookaroundAssertion';\n  kind: keyof NodeLookaroundAssertionKinds;\n  negate: boolean;\n  alternatives: Array<AlternativeNode>;\n}} LookaroundAssertionNode\n*/\n/**\n@param {{\n  behind?: boolean;\n  negate?: boolean;\n}} [options]\n@returns {LookaroundAssertionNode}\n*/\nfunction createLookaroundAssertion(options) {\n  const opts = {\n    behind: false,\n    negate: false,\n    ...options,\n  };\n  return {\n    type: NodeTypes.LookaroundAssertion,\n    kind: opts.behind ? NodeLookaroundAssertionKinds.lookbehind : NodeLookaroundAssertionKinds.lookahead,\n    negate: opts.negate,\n    alternatives: [createAlternative()],\n  };\n}\n\n/**\n@typedef {{\n  type: 'Pattern';\n  alternatives: Array<AlternativeNode>;\n}} PatternNode\n*/\n/**\n@returns {PatternNode}\n*/\nfunction createPattern() {\n  return {\n    type: NodeTypes.Pattern,\n    alternatives: [createAlternative()],\n  };\n}\n\n/**\n@param {string} name\n@param {{\n  negate?: boolean;\n}} [options]\n@returns {\n  CharacterSetNode & {\n    kind: 'posix';\n    value: string;\n    negate: boolean;\n  }\n}\n*/\nfunction createPosixClass(name, options) {\n  const negate = !!options?.negate;\n  if (!PosixClassNames.has(name)) {\n    throw new Error(`Invalid POSIX class \"${name}\"`);\n  }\n  return {\n    type: NodeTypes.CharacterSet,\n    kind: NodeCharacterSetKinds.posix,\n    value: name,\n    negate,\n  };\n}\n\n/**\n@typedef {{\n  type: 'Quantifier';\n  min: number;\n  max: number;\n  kind: keyof NodeQuantifierKinds;\n  element: QuantifiableNode;\n}} QuantifierNode\n*/\n/**\n@param {QuantifiableNode} element\n@param {number} min\n@param {number} max\n@param {keyof NodeQuantifierKinds} [kind]\n@returns {QuantifierNode}\n*/\nfunction createQuantifier(element, min, max, kind = NodeQuantifierKinds.greedy) {\n  const node = {\n    type: NodeTypes.Quantifier,\n    min,\n    max,\n    kind,\n    element,\n  };\n  if (max < min) {\n    return {\n      ...node,\n      min: max,\n      max: min,\n      kind: NodeQuantifierKinds.possessive,\n    };\n  }\n  return node;\n}\n\n/**\n@typedef {{\n  type: 'Regex';\n  pattern: PatternNode;\n  flags: FlagsNode;\n}} RegexNode\n*/\n/**\n@param {PatternNode} pattern\n@param {FlagsNode} flags\n@returns {RegexNode}\n*/\nfunction createRegex(pattern, flags) {\n  return {\n    type: NodeTypes.Regex,\n    pattern,\n    flags,\n  };\n}\n\n/**\n@typedef {{\n  type: 'Subroutine';\n  ref: string | number;\n}} SubroutineNode\n*/\n/**\n@param {string | number} ref\n@returns {SubroutineNode}\n*/\nfunction createSubroutine(ref) {\n  return {\n    type: NodeTypes.Subroutine,\n    ref,\n  };\n}\n\n/**\n@param {string} name\n@param {{\n  negate?: boolean;\n  normalizeUnknownPropertyNames?: boolean;\n  skipPropertyNameValidation?: boolean;\n  unicodePropertyMap?: Map<string, string>?;\n}} [options]\n@returns {\n  CharacterSetNode & {\n    kind: 'property';\n    value: string;\n    negate: boolean;\n  }\n}\n*/\nfunction createUnicodeProperty(name, options) {\n  const opts = {\n    negate: false,\n    normalizeUnknownPropertyNames: false,\n    skipPropertyNameValidation: false,\n    unicodePropertyMap: null,\n    ...options,\n  };\n  let normalized = opts.unicodePropertyMap?.get(slug(name));\n  if (!normalized) {\n    if (opts.normalizeUnknownPropertyNames) {\n      normalized = normalizeUnicodePropertyName(name);\n    // Let the name through as-is if no map provided and normalization not requested\n    } else if (opts.unicodePropertyMap && !opts.skipPropertyNameValidation) {\n      throw new Error(r`Invalid Unicode property \"\\p{${name}}\"`);\n    }\n  }\n  return {\n    type: NodeTypes.CharacterSet,\n    kind: NodeCharacterSetKinds.property,\n    value: normalized ?? name,\n    negate: opts.negate,\n  }\n}\n\nfunction isValidGroupName(name) {\n  // Note that backrefs and subroutines might contextually use `-` and `+` to indicate relative\n  // index or recursion level\n  return /^[\\p{Alpha}\\p{Pc}][^)]*$/u.test(name);\n}\n\nfunction normalizeUnicodePropertyName(name) {\n  // In Onig, Unicode property names ignore case, spaces, hyphens, and underscores. Use best effort\n  // to reformat the name to follow official values (covers a lot, but isn't able to map for all\n  // possible formatting differences)\n  return name.\n    trim().\n    replace(/[- _]+/g, '_').\n    replace(/[A-Z][a-z]+(?=[A-Z])/g, '$&_'). // `PropertyName` to `Property_Name`\n    replace(/[A-Za-z]+/g, m => m[0].toUpperCase() + m.slice(1).toLowerCase());\n}\n\n/**\nGenerates a Unicode property lookup name: lowercase, without spaces, hyphens, or underscores.\n@param {string} name Unicode property name.\n@returns {string}\n*/\nfunction slug(name) {\n  return name.replace(/[- _]+/g, '').toLowerCase();\n}\n\nfunction throwIfUnclosedCharacterClass(token, firstClassToken) {\n  return throwIfNot(\n    token,\n    // Easier to understand error when applicable\n    `${firstClassToken?.value === 93 ? 'Empty' : 'Unclosed'} character class`\n  );\n}\n\nfunction throwIfUnclosedGroup(token) {\n  return throwIfNot(token, 'Unclosed group');\n}\n\nexport {\n  createAbsentFunction,\n  createAlternative,\n  createAssertion,\n  createBackreference,\n  createCapturingGroup,\n  createCharacter,\n  createCharacterClass,\n  createCharacterClassRange,\n  createCharacterSet,\n  createDirective,\n  createFlags,\n  createGroup,\n  createLookaroundAssertion,\n  createPattern,\n  createPosixClass,\n  createQuantifier,\n  createRegex,\n  createSubroutine,\n  createUnicodeProperty,\n  NodeAbsentFunctionKinds,\n  NodeAssertionKinds,\n  NodeCharacterClassKinds,\n  NodeCharacterSetKinds,\n  NodeDirectiveKinds,\n  NodeLookaroundAssertionKinds,\n  NodeTypes,\n  NodeQuantifierKinds,\n  parse,\n  slug,\n};\n"],
  "mappings": "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",
  "names": ["TokenCharacterSetKinds", "TokenDirectiveKinds", "TokenGroupKinds", "tokenize", "TokenQuantifierKinds", "TokenTypes", "getOrInsert", "PosixClassNames", "r", "throwIfNot", "NodeTypes", "NodeAbsentFunctionKinds", "NodeAssertionKinds", "NodeCharacterClassKinds", "NodeCharacterSetKinds", "NodeDirectiveKinds", "NodeQuantifierKinds", "NodeLookaroundAssertionKinds", "parse", "pattern", "options", "opts", "tokenized", "context", "walk", "parent", "state", "token", "createAlternative", "createAssertionFromToken", "parseBackreference", "createCharacter", "parseCharacterClassHyphen", "parseCharacterClassOpen", "parseCharacterSet", "createDirective", "parseGroupOpen", "parseQuantifier", "parseSubroutine", "ast", "createRegex", "createPattern", "createFlags", "top", "node", "capturingGroups", "hasNumberedRef", "namedGroupsByName", "subroutines", "ref", "raw", "hasKWrapper", "fromNum", "num", "isRelative", "numCapturesToLeft", "orphan", "createBackreference", "numberedRef", "tokens", "prevSiblingNode", "nextToken", "nextNode", "createCharacterClassRange", "firstClassToken", "intersections", "createCharacterClass", "throwIfUnclosedCharacterClass", "cc", "normalizeUnknownPropertyNames", "skipPropertyNameValidation", "unicodePropertyMap", "kind", "negate", "value", "normalized", "slug", "createUnicodeProperty", "createPosixClass", "createCharacterSet", "skipLookbehindValidation", "createByGroupKind", "isAbsentFunction", "isLookbehind", "isNegLookbehind", "throwIfUnclosedGroup", "alt", "child", "msg", "min", "max", "quantifiedNode", "createQuantifier", "createSubroutine", "createAbsentFunction", "createAssertion", "flags", "name", "number", "createGroup", "createCapturingGroup", "createLookaroundAssertion", "hasName", "isValidGroupName", "charCode", "hex", "atomic", "element", "normalizeUnicodePropertyName", "m"]
}
