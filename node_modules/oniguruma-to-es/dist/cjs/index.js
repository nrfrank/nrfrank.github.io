var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.js
var index_exports = {};
__export(index_exports, {
  EmulatedRegExp: () => EmulatedRegExp,
  toRegExp: () => toRegExp,
  toRegExpDetails: () => toRegExpDetails
});
module.exports = __toCommonJS(index_exports);

// src/utils.js
var cp = String.fromCodePoint;
var r = String.raw;
var envFlags = {
  flagGroups: (() => {
    try {
      new RegExp("(?i:)");
    } catch {
      return false;
    }
    return true;
  })(),
  unicodeSets: (() => {
    try {
      new RegExp("", "v");
    } catch {
      return false;
    }
    return true;
  })()
};
envFlags.literalHyphenIncorrectlyCreatesRange = (() => {
  if (!envFlags.unicodeSets) {
    return false;
  }
  try {
    new RegExp(r`[\d\-a]`, "v");
  } catch {
    return true;
  }
  return false;
})();
function getNewCurrentFlags(current, { enable, disable }) {
  return {
    dotAll: !disable?.dotAll && !!(enable?.dotAll || current.dotAll),
    ignoreCase: !disable?.ignoreCase && !!(enable?.ignoreCase || current.ignoreCase)
  };
}
function getOrInsert(map, key, defaultValue) {
  if (!map.has(key)) {
    map.set(key, defaultValue);
  }
  return map.get(key);
}
function isMinTarget(target, min) {
  return EsVersion[target] >= EsVersion[min];
}
function throwIfNot(value, msg) {
  if (!value) {
    throw new Error(msg ?? "Value expected");
  }
  return value;
}

// src/options.js
var EsVersion = {
  ES2025: 2025,
  ES2024: 2024,
  ES2018: 2018
};
var Target = (
  /** @type {const} */
  {
    auto: "auto",
    ES2025: "ES2025",
    ES2024: "ES2024",
    ES2018: "ES2018"
  }
);
function getOptions(options = {}) {
  if ({}.toString.call(options) !== "[object Object]") {
    throw new Error("Unexpected options");
  }
  if (options.target !== void 0 && !Target[options.target]) {
    throw new Error(`Unexpected target "${options.target}"`);
  }
  const opts = {
    // Sets the level of emulation rigor/strictness.
    accuracy: "default",
    // Disables advanced emulation that relies on returning a `RegExp` subclass, resulting in
    // certain patterns not being emulatable.
    avoidSubclass: false,
    // Oniguruma flags; a string with `i`, `m`, `x`, `D`, `S`, `W` in any order (all optional).
    // Oniguruma's `m` is equivalent to JavaScript's `s` (`dotAll`).
    flags: "",
    // Include JavaScript flag `g` (`global`) in the result.
    global: false,
    // Include JavaScript flag `d` (`hasIndices`) in the result.
    hasIndices: false,
    // Delay regex construction until first use if the transpiled pattern is at least this length.
    lazyCompileLength: Infinity,
    // JavaScript version used for generated regexes. Using `auto` detects the best value based on
    // your environment. Later targets allow faster processing, simpler generated source, and
    // support for additional features.
    target: "auto",
    // Disables optimizations that simplify the pattern when it doesn't change the meaning.
    verbose: false,
    ...options,
    // Advanced options that override standard behavior, error checking, and flags when enabled.
    rules: {
      // Useful with TextMate grammars that merge backreferences across patterns.
      allowOrphanBackrefs: false,
      // Use ASCII-based `\b` and `\B`, which increases search performance of generated regexes.
      asciiWordBoundaries: false,
      // Allow unnamed captures and numbered calls (backreferences and subroutines) when using
      // named capture. This is Oniguruma option `ONIG_OPTION_CAPTURE_GROUP`; on by default in
      // `vscode-oniguruma`.
      captureGroup: false,
      // Change the recursion depth limit from Oniguruma's `20` to an integer `2`â€“`20`.
      recursionLimit: 20,
      // `^` as `\A`; `$` as`\Z`. Improves search performance of generated regexes without changing
      // meaning if searching line by line. This is Oniguruma option `ONIG_OPTION_SINGLELINE`.
      singleline: false,
      ...options.rules
    }
  };
  if (opts.target === "auto") {
    opts.target = envFlags.flagGroups ? "ES2025" : envFlags.unicodeSets ? "ES2024" : "ES2018";
  }
  return opts;
}

// node_modules/.pnpm/oniguruma-parser@0.5.4/node_modules/oniguruma-parser/dist/utils.js
var e = String.fromCodePoint;
var o = String.raw;
var i = /* @__PURE__ */ new Set(["alnum", "alpha", "ascii", "blank", "cntrl", "digit", "graph", "lower", "print", "punct", "space", "upper", "word", "xdigit"]);
function s(t, r4, n) {
  return t.has(r4) || t.set(r4, n), t.get(r4);
}
function c(t, r4) {
  if (!t) throw new Error(r4 ?? "Value expected");
  return t;
}

// node_modules/.pnpm/oniguruma-parser@0.5.4/node_modules/oniguruma-parser/dist/tokenizer/tokenize.js
var o2 = { Alternator: "Alternator", Assertion: "Assertion", Backreference: "Backreference", Character: "Character", CharacterClassClose: "CharacterClassClose", CharacterClassHyphen: "CharacterClassHyphen", CharacterClassIntersector: "CharacterClassIntersector", CharacterClassOpen: "CharacterClassOpen", CharacterSet: "CharacterSet", Directive: "Directive", GroupClose: "GroupClose", GroupOpen: "GroupOpen", Subroutine: "Subroutine", Quantifier: "Quantifier", EscapedNumber: "EscapedNumber" };
var h = { any: "any", digit: "digit", dot: "dot", grapheme: "grapheme", hex: "hex", newline: "newline", posix: "posix", property: "property", space: "space", word: "word" };
var x = { flags: "flags", keep: "keep" };
var g = { absent_repeater: "absent_repeater", atomic: "atomic", capturing: "capturing", group: "group", lookahead: "lookahead", lookbehind: "lookbehind" };
var C = { greedy: "greedy", lazy: "lazy", possessive: "possessive" };
var y = /* @__PURE__ */ new Map([["a", 7], ["b", 8], ["e", 27], ["f", 12], ["n", 10], ["r", 13], ["t", 9], ["v", 11]]);
var E = o`\[\^?`;
var $ = `c.? | C(?:-.?)?|${o`[pP]\{(?:\^?[-\x20_]*[A-Za-z][-\x20\w]*\})?`}|${o`x[89A-Fa-f]\p{AHex}(?:\\x[89A-Fa-f]\p{AHex})*`}|${o`u(?:\p{AHex}{4})? | x\{[^\}]*\}? | x\p{AHex}{0,2}`}|${o`o\{[^\}]*\}?`}|${o`\d{1,3}`}`;
var I = /[?*+][?+]?|\{(?:\d+(?:,\d*)?|,\d+)\}\??/;
var k = new RegExp(o`
  \\ (?:
    ${$}
    | [gk]<[^>]*>?
    | [gk]'[^']*'?
    | .
  )
  | \( (?:
    \? (?:
      [:=!>({]
      | <[=!]
      | <[^>]*>
      | '[^']*'
      | ~\|?
      | #(?:[^)\\]|\\.?)*
      | [^:)]*[:)]
    )?
    | \*
  )?
  | ${I.source}
  | ${E}
  | .
`.replace(/\s+/g, ""), "gsu");
var A = new RegExp(o`
  \\ (?:
    ${$}
    | .
  )
  | \[:(?:\^?\p{Alpha}+|\^):\]
  | ${E}
  | &&
  | .
`.replace(/\s+/g, ""), "gsu");
function P(e2, t = {}) {
  const n = { flags: "", ...t, rules: { captureGroup: false, singleline: false, ...t.rules } };
  if (typeof e2 != "string") throw new Error("String expected as pattern");
  const i2 = z(n.flags), a = [i2.extended], p = { captureGroup: n.rules.captureGroup, getCurrentModX: () => a.at(-1), numOpenGroups: 0, popModX() {
    a.pop();
  }, pushModX(c2) {
    a.push(c2);
  }, replaceCurrentModX(c2) {
    a[a.length - 1] = c2;
  }, singleline: n.rules.singleline };
  let r4 = [], u;
  for (k.lastIndex = 0; u = k.exec(e2); ) {
    const c2 = F(p, e2, u[0], k.lastIndex);
    c2.tokens ? r4.push(...c2.tokens) : c2.token && r4.push(c2.token), c2.lastIndex !== void 0 && (k.lastIndex = c2.lastIndex);
  }
  const l = [];
  let f2 = 0;
  r4.forEach((c2) => {
    c2.type === o2.GroupOpen && (c2.kind === g.capturing ? c2.number = ++f2 : c2.raw === "(" && l.push(c2));
  }), f2 || l.forEach((c2, S2) => {
    c2.kind = g.capturing, c2.number = S2 + 1;
  });
  const G2 = f2 || l.length;
  return r4 = r4.map((c2) => c2.type === o2.EscapedNumber ? j(c2, G2) : c2).flat(), { tokens: r4, flags: i2 };
}
function F(e2, t, n, i2) {
  const [a, p] = n;
  if (a === "[") {
    const r4 = M(t, n, i2);
    return { tokens: r4.tokens, lastIndex: r4.lastIndex };
  }
  if (a === "\\") {
    if ("AbBGyYzZ".includes(p)) return { token: s2(o2.Assertion, n, { kind: n }) };
    if (/^\\g[<']/.test(n)) {
      if (!/^\\g(?:<[^>]+>|'[^']+')$/.test(n)) throw new Error(`Invalid group name "${n}"`);
      return { token: s2(o2.Subroutine, n) };
    }
    if (/^\\k[<']/.test(n)) {
      if (!/^\\k(?:<[^>]+>|'[^']+')$/.test(n)) throw new Error(`Invalid group name "${n}"`);
      return { token: s2(o2.Backreference, n) };
    }
    if (p === "K") return { token: s2(o2.Directive, n, { kind: x.keep }) };
    if (p === "N" || p === "R") return { token: s2(o2.CharacterSet, n, { kind: h.newline, negate: p === "N" }) };
    if (p === "O") return { token: s2(o2.CharacterSet, n, { kind: h.any }) };
    if (p === "X") return { token: s2(o2.CharacterSet, n, { kind: h.grapheme }) };
    const r4 = O(n, { inCharClass: false });
    return Array.isArray(r4) ? { tokens: r4 } : { token: r4 };
  }
  if (a === "(") {
    if (n === "(*") throw new Error(`Unsupported named callout "${n}"`);
    if (n === "(?{") throw new Error(`Unsupported callout "${n}"`);
    if (n.startsWith("(?#")) {
      if (t[i2] !== ")") throw new Error('Unclosed comment group "(?#"');
      return { lastIndex: i2 + 1 };
    }
    if (/^\(\?[-imx]+[:)]$/.test(n)) return { token: W(n, e2) };
    if (e2.pushModX(e2.getCurrentModX()), e2.numOpenGroups++, n === "(" && !e2.captureGroup || n === "(?:") return { token: s2(o2.GroupOpen, n, { kind: g.group }) };
    if (n === "(?>") return { token: s2(o2.GroupOpen, n, { kind: g.atomic }) };
    if (n === "(?=" || n === "(?!" || n === "(?<=" || n === "(?<!") return { token: s2(o2.GroupOpen, n, { kind: n[2] === "<" ? g.lookbehind : g.lookahead, negate: n.endsWith("!") }) };
    if (n === "(" && e2.captureGroup || n.startsWith("(?<") && n.endsWith(">") || n.startsWith("(?'") && n.endsWith("'")) {
      const r4 = s2(o2.GroupOpen, n, { kind: g.capturing });
      return n !== "(" && (r4.name = n.slice(3, -1)), { token: r4 };
    }
    if (n.startsWith("(?~")) {
      if (n === "(?~|") throw new Error(`Unsupported absent function kind "${n}"`);
      return { token: s2(o2.GroupOpen, n, { kind: g.absent_repeater }) };
    }
    throw n === "(?(" ? new Error(`Unsupported conditional "${n}"`) : new Error(`Invalid or unsupported group option "${n}"`);
  }
  if (n === ")") {
    if (e2.popModX(), e2.numOpenGroups--, e2.numOpenGroups < 0) throw new Error('Unmatched ")"');
    return { token: s2(o2.GroupClose, n) };
  }
  if (n === "#" && e2.getCurrentModX()) {
    const r4 = t.indexOf(`
`, i2);
    return { lastIndex: r4 === -1 ? t.length : r4 };
  }
  if (/^\s$/.test(n) && e2.getCurrentModX()) {
    const r4 = /\s+/y;
    return r4.lastIndex = i2, { lastIndex: r4.exec(t) ? r4.lastIndex : i2 };
  }
  if (n === ".") return { token: s2(o2.CharacterSet, n, { kind: h.dot }) };
  if (n === "^" || n === "$") {
    const r4 = e2.singleline ? { "^": o`\A`, $: o`\Z` }[n] : n;
    return { token: s2(o2.Assertion, n, { kind: r4 }) };
  }
  return n === "|" ? { token: s2(o2.Alternator, n) } : I.test(n) ? { token: X(n) } : (v(n), { token: s2(o2.Character, n, { value: n.codePointAt(0) }) });
}
function M(e2, t, n) {
  const i2 = [s2(o2.CharacterClassOpen, t, { negate: t[1] === "^" })];
  let a = 1, p;
  for (A.lastIndex = n; p = A.exec(e2); ) {
    const r4 = p[0];
    if (r4[0] === "[" && r4[1] !== ":") a++, i2.push(s2(o2.CharacterClassOpen, r4, { negate: r4[1] === "^" }));
    else if (r4 === "]") {
      if (i2.at(-1).type === o2.CharacterClassOpen) i2.push(s2(o2.Character, r4, { value: 93 }));
      else if (a--, i2.push(s2(o2.CharacterClassClose, r4)), !a) break;
    } else {
      const u = w(r4);
      Array.isArray(u) ? i2.push(...u) : i2.push(u);
    }
  }
  return { tokens: i2, lastIndex: A.lastIndex || e2.length };
}
function w(e2) {
  if (e2[0] === "\\") return O(e2, { inCharClass: true });
  if (e2[0] === "[") {
    const t = /\[:(?<negate>\^?)(?<name>[a-z]+):\]/.exec(e2);
    if (!t || !i.has(t.groups.name)) throw new Error(`Invalid POSIX class "${e2}"`);
    return s2(o2.CharacterSet, e2, { kind: h.posix, value: t.groups.name, negate: !!t.groups.negate });
  }
  return e2 === "-" ? s2(o2.CharacterClassHyphen, e2) : e2 === "&&" ? s2(o2.CharacterClassIntersector, e2) : (v(e2), s2(o2.Character, e2, { value: e2.codePointAt(0) }));
}
function O(e2, { inCharClass: t }) {
  const n = e2[1];
  if (n === "c" || n === "C") return U(e2);
  if ("dDhHsSwW".includes(n)) return H(e2);
  if (e2.startsWith(o`\o{`)) throw new Error(`Incomplete, invalid, or unsupported octal code point "${e2}"`);
  if (/^\\[pP]\{/.test(e2)) {
    if (e2.length === 3) throw new Error(`Incomplete or invalid Unicode property "${e2}"`);
    return D(e2);
  }
  if (/^\\x[89A-Fa-f]\p{AHex}/u.test(e2)) try {
    const i2 = e2.split(/\\x/).slice(1).map((u) => parseInt(u, 16)), a = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }).decode(new Uint8Array(i2)), p = new TextEncoder();
    return [...a].map((u) => {
      const l = [...p.encode(u)].map((f2) => `\\x${f2.toString(16)}`).join("");
      return s2(o2.Character, l, { value: u.codePointAt(0) });
    });
  } catch {
    throw new Error(`Multibyte code "${e2}" incomplete or invalid in Oniguruma`);
  }
  if (n === "u" || n === "x") return s2(o2.Character, e2, { value: N(e2) });
  if (y.has(n)) return s2(o2.Character, e2, { value: y.get(n) });
  if (/\d/.test(n)) return s2(o2.EscapedNumber, e2, { inCharClass: t });
  if (e2 === "\\") throw new Error(o`Incomplete escape "\"`);
  if (n === "M") throw new Error(`Unsupported meta "${e2}"`);
  if ([...e2].length === 2) return s2(o2.Character, e2, { value: e2.codePointAt(1) });
  throw new Error(`Unexpected escape "${e2}"`);
}
function s2(e2, t, n) {
  return { type: e2, raw: t, ...n };
}
function U(e2) {
  const t = e2[1] === "c" ? e2[2] : e2[3];
  if (!t || !/[A-Za-z]/.test(t)) throw new Error(`Unsupported control character "${e2}"`);
  return s2(o2.Character, e2, { value: t.toUpperCase().codePointAt(0) - 64 });
}
function W(e2, t) {
  let { on: n, off: i2 } = /^\(\?(?<on>[imx]*)(?:-(?<off>[-imx]*))?/.exec(e2).groups;
  i2 ??= "";
  const a = (t.getCurrentModX() || n.includes("x")) && !i2.includes("x"), p = b(n), r4 = b(i2), u = {};
  if (p && (u.enable = p), r4 && (u.disable = r4), e2.endsWith(")")) return t.replaceCurrentModX(a), s2(o2.Directive, e2, { kind: x.flags, flags: u });
  if (e2.endsWith(":")) {
    t.pushModX(a), t.numOpenGroups++;
    const l = s2(o2.GroupOpen, e2, { kind: g.group });
    return (p || r4) && (l.flags = u), l;
  }
  throw new Error(`Unexpected flag modifier "${e2}"`);
}
function X(e2) {
  const t = {};
  if (e2[0] === "{") {
    const { min: n, max: i2 } = /^\{(?<min>\d*)(?:,(?<max>\d*))?/.exec(e2).groups, a = 1e5;
    if (+n > a || +i2 > a) throw new Error("Quantifier value unsupported in Oniguruma");
    t.min = +n, t.max = i2 === void 0 ? +n : i2 === "" ? 1 / 0 : +i2, t.kind = e2.endsWith("?") ? C.lazy : C.greedy;
  } else t.min = e2[0] === "+" ? 1 : 0, t.max = e2[0] === "?" ? 1 : 1 / 0, t.kind = e2[1] === "+" ? C.possessive : e2[1] === "?" ? C.lazy : C.greedy;
  return s2(o2.Quantifier, e2, t);
}
function H(e2) {
  const t = e2[1].toLowerCase();
  return s2(o2.CharacterSet, e2, { kind: { d: h.digit, h: h.hex, s: h.space, w: h.word }[t], negate: e2[1] !== t });
}
function D(e2) {
  const { p: t, neg: n, value: i2 } = /^\\(?<p>[pP])\{(?<neg>\^?)(?<value>[^}]+)/.exec(e2).groups, a = t === "P" && !n || t === "p" && !!n;
  return s2(o2.CharacterSet, e2, { kind: h.property, value: i2, negate: a });
}
function b(e2) {
  const t = {};
  return e2.includes("i") && (t.ignoreCase = true), e2.includes("m") && (t.dotAll = true), e2.includes("x") && (t.extended = true), Object.keys(t).length ? t : null;
}
function z(e2) {
  if (!/^[imxDPSW]*$/.test(e2)) throw new Error(`Flags "${e2}" includes unsupported value`);
  const t = { ignoreCase: false, dotAll: false, extended: false, digitIsAscii: false, posixIsAscii: false, spaceIsAscii: false, wordIsAscii: false };
  for (const n of e2) t[{ i: "ignoreCase", m: "dotAll", x: "extended", D: "digitIsAscii", P: "posixIsAscii", S: "spaceIsAscii", W: "wordIsAscii" }[n]] = true;
  return t;
}
function N(e2) {
  if (/^(?:\\u(?!\p{AHex}{4})|\\x(?!\p{AHex}{1,2}|\{\p{AHex}{1,8}\}))/u.test(e2)) throw new Error(`Incomplete or invalid escape "${e2}"`);
  const t = e2[2] === "{" ? /^\\x\{\s*(?<hex>\p{AHex}+)/u.exec(e2).groups.hex : e2.slice(2);
  return parseInt(t, 16);
}
function j(e2, t) {
  const { raw: n, inCharClass: i2 } = e2, a = n.slice(1);
  if (!i2 && (a !== "0" && a.length === 1 || a[0] !== "0" && +a <= t)) return [s2(o2.Backreference, n)];
  const p = [], r4 = a.match(/^[0-7]+|\d/g);
  for (let u = 0; u < r4.length; u++) {
    const l = r4[u];
    let f2;
    if (u === 0 && l !== "8" && l !== "9") {
      if (f2 = parseInt(l, 8), f2 > 127) throw new Error(o`Octal encoded byte above 177 unsupported "${n}"`);
    } else f2 = l.codePointAt(0);
    p.push(s2(o2.Character, (u === 0 ? "\\" : "") + l, { value: f2 }));
  }
  return p;
}
function v(e2) {
  if ([...e2].length !== 1) throw new Error(`Expected "${e2}" to be a single code point`);
}

// node_modules/.pnpm/oniguruma-parser@0.5.4/node_modules/oniguruma-parser/dist/parser/parse.js
var s3 = { AbsentFunction: "AbsentFunction", Alternative: "Alternative", Assertion: "Assertion", Backreference: "Backreference", CapturingGroup: "CapturingGroup", Character: "Character", CharacterClass: "CharacterClass", CharacterClassRange: "CharacterClassRange", CharacterSet: "CharacterSet", Directive: "Directive", Flags: "Flags", Group: "Group", LookaroundAssertion: "LookaroundAssertion", Pattern: "Pattern", Quantifier: "Quantifier", Regex: "Regex", Subroutine: "Subroutine", Recursion: "Recursion" };
var F2 = { repeater: "repeater" };
var f = { grapheme_boundary: "grapheme_boundary", line_end: "line_end", line_start: "line_start", search_start: "search_start", string_end: "string_end", string_end_newline: "string_end_newline", string_start: "string_start", word_boundary: "word_boundary" };
var L = { union: "union", intersection: "intersection" };
var A2 = h;
var E2 = x;
var _ = C;
var b2 = { lookahead: "lookahead", lookbehind: "lookbehind" };
function ne(e2, r4 = {}) {
  const n = { flags: "", normalizeUnknownPropertyNames: false, skipBackrefValidation: false, skipLookbehindValidation: false, skipPropertyNameValidation: false, unicodePropertyMap: null, ...r4, rules: { captureGroup: false, singleline: false, ...r4.rules } }, a = P(e2, { flags: n.flags, rules: { captureGroup: n.rules.captureGroup, singleline: n.rules.singleline } }), t = { capturingGroups: [], current: 0, hasNumberedRef: false, namedGroupsByName: /* @__PURE__ */ new Map(), normalizeUnknownPropertyNames: n.normalizeUnknownPropertyNames, parent: null, skipBackrefValidation: n.skipBackrefValidation, skipLookbehindValidation: n.skipLookbehindValidation, skipPropertyNameValidation: n.skipPropertyNameValidation, subroutines: [], token: null, tokens: a.tokens, unicodePropertyMap: n.unicodePropertyMap, walk: o3 };
  function o3(p, m) {
    const d = a.tokens[t.current];
    switch (t.parent = p, t.token = d, t.current++, d.type) {
      case o2.Alternator:
        return k2();
      case o2.Assertion:
        return le(d);
      case o2.Backreference:
        return te(t);
      case o2.Character:
        return I2(d.value, { useLastValid: !!m.isCheckingRangeEnd });
      case o2.CharacterClassHyphen:
        return ae(t, m);
      case o2.CharacterClassOpen:
        return oe(t, m);
      case o2.CharacterSet:
        return se(t);
      case o2.Directive:
        return K(c(E2[d.kind], `Unexpected directive kind "${d.kind}"`), { flags: d.flags });
      case o2.GroupOpen:
        return ie(t, m);
      case o2.Quantifier:
        return ue(t);
      case o2.Subroutine:
        return ce(t);
      default:
        throw new Error(`Unexpected token type "${d.type}"`);
    }
  }
  const i2 = q(D2(), O2(a.flags));
  let c2 = i2.pattern.alternatives[0];
  for (; t.current < a.tokens.length; ) {
    const p = o3(c2, {});
    p.type === s3.Alternative ? (i2.pattern.alternatives.push(p), c2 = p) : c2.elements.push(p);
  }
  const { capturingGroups: u, hasNumberedRef: h2, namedGroupsByName: y2, subroutines: N2 } = t;
  if (h2 && y2.size && !n.rules.captureGroup) throw new Error("Numbered backref/subroutine not allowed when using named capture");
  for (const { ref: p } of N2) if (typeof p == "number") {
    if (p > u.length) throw new Error("Subroutine uses a group number that's not defined");
  } else if (y2.has(p)) {
    if (y2.get(p).length > 1) throw new Error(o`Subroutine uses a duplicate group name "\g<${p}>"`);
  } else throw new Error(o`Subroutine uses a group name that's not defined "\g<${p}>"`);
  return i2;
}
function te(e2) {
  const { raw: r4 } = e2.token, n = /^\\k[<']/.test(r4), a = n ? r4.slice(3, -1) : r4.slice(1), t = (o3, i2 = false) => {
    const c2 = e2.capturingGroups.length;
    let u = false;
    if (o3 > c2) if (e2.skipBackrefValidation) u = true;
    else throw new Error(`Not enough capturing groups defined to the left "${r4}"`);
    return e2.hasNumberedRef = true, P2(i2 ? c2 + 1 - o3 : o3, { orphan: u });
  };
  if (n) {
    const o3 = /^(?<sign>-?)0*(?<num>[1-9]\d*)$/.exec(a);
    if (o3) return t(+o3.groups.num, !!o3.groups.sign);
    if (/[-+]/.test(a)) throw new Error(`Invalid backref name "${r4}"`);
    if (!e2.namedGroupsByName.has(a)) throw new Error(`Group name not defined to the left "${r4}"`);
    return P2(a);
  }
  return t(+a);
}
function ae(e2, r4) {
  const { parent: n, tokens: a, walk: t } = e2, o3 = n.elements.at(-1), i2 = a[e2.current];
  if (!r4.isCheckingRangeEnd && o3 && o3.type !== s3.CharacterClass && o3.type !== s3.CharacterClassRange && i2 && i2.type !== o2.CharacterClassOpen && i2.type !== o2.CharacterClassClose && i2.type !== o2.CharacterClassIntersector) {
    const c2 = t(n, { ...r4, isCheckingRangeEnd: true });
    if (o3.type === s3.Character && c2.type === s3.Character) return n.elements.pop(), z2(o3, c2);
    throw new Error("Invalid character class range");
  }
  return I2(45);
}
function oe(e2, r4) {
  const { token: n, tokens: a, walk: t } = e2, o3 = a[e2.current], i2 = [G()];
  let c2 = J(o3);
  for (; c2.type !== o2.CharacterClassClose; ) {
    if (c2.type === o2.CharacterClassIntersector) i2.push(G()), e2.current++;
    else {
      const h2 = i2.at(-1);
      h2.elements.push(t(h2, r4));
    }
    c2 = J(a[e2.current], o3);
  }
  const u = G({ negate: n.negate });
  return i2.length === 1 ? u.elements = i2[0].elements : (u.kind = L.intersection, u.elements = i2.map((h2) => h2.elements.length === 1 ? h2.elements[0] : h2)), e2.current++, u;
}
function se({ token: e2, normalizeUnknownPropertyNames: r4, skipPropertyNameValidation: n, unicodePropertyMap: a }) {
  let { kind: t, negate: o3, value: i2 } = e2;
  if (t === h.property) {
    const c2 = $2(i2);
    if (i.has(c2) && !a?.has(c2)) t = h.posix, i2 = c2;
    else return Y(i2, { negate: o3, normalizeUnknownPropertyNames: r4, skipPropertyNameValidation: n, unicodePropertyMap: a });
  }
  return t === h.posix ? M2(i2, { negate: o3 }) : T(t, { negate: o3 });
}
function ie(e2, r4) {
  const { token: n, tokens: a, capturingGroups: t, namedGroupsByName: o3, skipLookbehindValidation: i2, walk: c2 } = e2;
  let u = pe(n);
  const h2 = u.type === s3.AbsentFunction, y2 = u.kind === b2.lookbehind, N2 = y2 && u.negate;
  if (u.type === s3.CapturingGroup && (t.push(u), u.name && s(o3, u.name, []).push(u)), h2 && r4.isInAbsentFunction) throw new Error("Nested absent function not supported by Oniguruma");
  let p = W2(a[e2.current]);
  for (; p.type !== o2.GroupClose; ) {
    if (p.type === o2.Alternator) u.alternatives.push(k2()), e2.current++;
    else {
      const m = u.alternatives.at(-1), d = c2(m, { ...r4, isInAbsentFunction: r4.isInAbsentFunction || h2, isInLookbehind: r4.isInLookbehind || y2, isInNegLookbehind: r4.isInNegLookbehind || N2 });
      if (m.elements.push(d), (y2 || r4.isInLookbehind) && !i2) {
        const R = "Lookbehind includes a pattern not allowed by Oniguruma";
        if (N2 || r4.isInNegLookbehind) {
          if (d.kind === b2.lookahead || d.type === s3.CapturingGroup) throw new Error(R);
        } else if (d.kind === b2.lookahead || d.kind === b2.lookbehind && d.negate) throw new Error(R);
      }
    }
    p = W2(a[e2.current]);
  }
  return e2.current++, u;
}
function ue({ token: e2, parent: r4 }) {
  const { min: n, max: a, kind: t } = e2, o3 = r4.elements.at(-1);
  if (!o3 || o3.type === s3.Assertion || o3.type === s3.Directive || o3.type === s3.LookaroundAssertion) throw new Error("Quantifier requires a repeatable token");
  const i2 = Z(o3, n, a, c(_[t], `Unexpected quantifier kind "${t}"`));
  return r4.elements.pop(), i2;
}
function ce(e2) {
  const { token: r4, capturingGroups: n, subroutines: a } = e2;
  let t = r4.raw.slice(3, -1);
  const o3 = /^(?<sign>[-+]?)0*(?<num>[1-9]\d*)$/.exec(t);
  if (o3) {
    const c2 = +o3.groups.num, u = n.length;
    if (e2.hasNumberedRef = true, t = { "": c2, "+": u + c2, "-": u + 1 - c2 }[o3.groups.sign], t < 1) throw new Error("Invalid subroutine number");
  } else t === "0" && (t = 0);
  const i2 = H2(t);
  return a.push(i2), i2;
}
function B(e2) {
  if (e2 !== F2.repeater) throw new Error(`Unexpected absent function kind "${e2}"`);
  return { type: s3.AbsentFunction, kind: e2, alternatives: [k2()] };
}
function k2() {
  return { type: s3.Alternative, elements: [] };
}
function V(e2, r4) {
  const n = { type: s3.Assertion, kind: e2 };
  return (e2 === f.word_boundary || e2 === f.grapheme_boundary) && (n.negate = !!r4?.negate), n;
}
function le({ kind: e2 }) {
  return V(c({ "^": f.line_start, $: f.line_end, "\\A": f.string_start, "\\b": f.word_boundary, "\\B": f.word_boundary, "\\G": f.search_start, "\\y": f.grapheme_boundary, "\\Y": f.grapheme_boundary, "\\z": f.string_end, "\\Z": f.string_end_newline }[e2], `Unexpected assertion kind "${e2}"`), { negate: e2 === o`\B` || e2 === o`\Y` });
}
function P2(e2, r4) {
  const n = !!r4?.orphan;
  return { type: s3.Backreference, ref: e2, ...n && { orphan: n } };
}
function pe({ flags: e2, kind: r4, name: n, negate: a, number: t }) {
  switch (r4) {
    case g.absent_repeater:
      return B(F2.repeater);
    case g.atomic:
      return S({ atomic: true });
    case g.capturing:
      return x2(t, n);
    case g.group:
      return S({ flags: e2 });
    case g.lookahead:
    case g.lookbehind:
      return Q({ behind: r4 === g.lookbehind, negate: a });
    default:
      throw new Error(`Unexpected group kind "${r4}"`);
  }
}
function x2(e2, r4) {
  const n = r4 !== void 0;
  if (n && !de(r4)) throw new Error(`Group name "${r4}" invalid in Oniguruma`);
  return { type: s3.CapturingGroup, number: e2, ...n && { name: r4 }, alternatives: [k2()] };
}
function I2(e2, r4) {
  const n = { useLastValid: false, ...r4 };
  if (e2 > 1114111) {
    const a = e2.toString(16);
    if (n.useLastValid) e2 = 1114111;
    else throw e2 > 1310719 ? new Error(`Invalid code point out of range "\\x{${a}}"`) : new Error(`Invalid code point out of range in JS "\\x{${a}}"`);
  }
  return { type: s3.Character, value: e2 };
}
function G(e2) {
  const r4 = { kind: L.union, negate: false, ...e2 };
  return { type: s3.CharacterClass, kind: r4.kind, negate: r4.negate, elements: [] };
}
function z2(e2, r4) {
  if (r4.value < e2.value) throw new Error("Character class range out of order");
  return { type: s3.CharacterClassRange, min: e2, max: r4 };
}
function T(e2, r4) {
  const n = !!r4?.negate, a = { type: s3.CharacterSet, kind: c(A2[e2], `Unexpected character set kind "${e2}"`) };
  return (e2 === h.digit || e2 === h.hex || e2 === h.newline || e2 === h.space || e2 === h.word) && (a.negate = n), (e2 === h.grapheme || e2 === h.newline && !n) && (a.variableLength = true), a;
}
function K(e2, r4) {
  const n = { type: s3.Directive, kind: e2 };
  return e2 === E2.flags && (n.flags = r4.flags), n;
}
function O2(e2) {
  return { type: s3.Flags, ...e2 };
}
function S(e2) {
  const r4 = e2?.atomic, n = e2?.flags;
  return { type: s3.Group, ...r4 && { atomic: r4 }, ...n && { flags: n }, alternatives: [k2()] };
}
function Q(e2) {
  const r4 = { behind: false, negate: false, ...e2 };
  return { type: s3.LookaroundAssertion, kind: r4.behind ? b2.lookbehind : b2.lookahead, negate: r4.negate, alternatives: [k2()] };
}
function D2() {
  return { type: s3.Pattern, alternatives: [k2()] };
}
function M2(e2, r4) {
  const n = !!r4?.negate;
  if (!i.has(e2)) throw new Error(`Invalid POSIX class "${e2}"`);
  return { type: s3.CharacterSet, kind: A2.posix, value: e2, negate: n };
}
function Z(e2, r4, n, a = _.greedy) {
  const t = { type: s3.Quantifier, min: r4, max: n, kind: a, element: e2 };
  return n < r4 ? { ...t, min: n, max: r4, kind: _.possessive } : t;
}
function q(e2, r4) {
  return { type: s3.Regex, pattern: e2, flags: r4 };
}
function H2(e2) {
  return { type: s3.Subroutine, ref: e2 };
}
function Y(e2, r4) {
  const n = { negate: false, normalizeUnknownPropertyNames: false, skipPropertyNameValidation: false, unicodePropertyMap: null, ...r4 };
  let a = n.unicodePropertyMap?.get($2(e2));
  if (!a) {
    if (n.normalizeUnknownPropertyNames) a = fe(e2);
    else if (n.unicodePropertyMap && !n.skipPropertyNameValidation) throw new Error(o`Invalid Unicode property "\p{${e2}}"`);
  }
  return { type: s3.CharacterSet, kind: A2.property, value: a ?? e2, negate: n.negate };
}
function de(e2) {
  return /^[\p{Alpha}\p{Pc}][^)]*$/u.test(e2);
}
function fe(e2) {
  return e2.trim().replace(/[- _]+/g, "_").replace(/[A-Z][a-z]+(?=[A-Z])/g, "$&_").replace(/[A-Za-z]+/g, (r4) => r4[0].toUpperCase() + r4.slice(1).toLowerCase());
}
function $2(e2) {
  return e2.replace(/[- _]+/g, "").toLowerCase();
}
function J(e2, r4) {
  return c(e2, `${r4?.value === 93 ? "Empty" : "Unclosed"} character class`);
}
function W2(e2) {
  return c(e2, "Unclosed group");
}

// src/unicode.js
var asciiSpaceChar = "[	-\r ]";
var defaultWordChar = r`[\p{L}\p{M}\p{N}\p{Pc}]`;
var CharsWithoutIgnoreCaseExpansion = /* @__PURE__ */ new Set([
  cp(304),
  // Ä°
  cp(305)
  // Ä±
]);
function getIgnoreCaseMatchChars(char) {
  if (CharsWithoutIgnoreCaseExpansion.has(char)) {
    return [char];
  }
  const set = /* @__PURE__ */ new Set();
  const lower = char.toLowerCase();
  const upper = lower.toUpperCase();
  const title = LowerToTitleCaseMap.get(lower);
  const altLower = LowerToAlternativeLowerCaseMap.get(lower);
  const altUpper = LowerToAlternativeUpperCaseMap.get(lower);
  if ([...upper].length === 1) {
    set.add(upper);
  }
  altUpper && set.add(altUpper);
  title && set.add(title);
  set.add(lower);
  altLower && set.add(altLower);
  return [...set];
}
var JsUnicodePropertyMap = /* @__PURE__ */ new Map(
  `C Other
Cc Control cntrl
Cf Format
Cn Unassigned
Co Private_Use
Cs Surrogate
L Letter
LC Cased_Letter
Ll Lowercase_Letter
Lm Modifier_Letter
Lo Other_Letter
Lt Titlecase_Letter
Lu Uppercase_Letter
M Mark Combining_Mark
Mc Spacing_Mark
Me Enclosing_Mark
Mn Nonspacing_Mark
N Number
Nd Decimal_Number digit
Nl Letter_Number
No Other_Number
P Punctuation punct
Pc Connector_Punctuation
Pd Dash_Punctuation
Pe Close_Punctuation
Pf Final_Punctuation
Pi Initial_Punctuation
Po Other_Punctuation
Ps Open_Punctuation
S Symbol
Sc Currency_Symbol
Sk Modifier_Symbol
Sm Math_Symbol
So Other_Symbol
Z Separator
Zl Line_Separator
Zp Paragraph_Separator
Zs Space_Separator
ASCII
ASCII_Hex_Digit AHex
Alphabetic Alpha
Any
Assigned
Bidi_Control Bidi_C
Bidi_Mirrored Bidi_M
Case_Ignorable CI
Cased
Changes_When_Casefolded CWCF
Changes_When_Casemapped CWCM
Changes_When_Lowercased CWL
Changes_When_NFKC_Casefolded CWKCF
Changes_When_Titlecased CWT
Changes_When_Uppercased CWU
Dash
Default_Ignorable_Code_Point DI
Deprecated Dep
Diacritic Dia
Emoji
Emoji_Component EComp
Emoji_Modifier EMod
Emoji_Modifier_Base EBase
Emoji_Presentation EPres
Extended_Pictographic ExtPict
Extender Ext
Grapheme_Base Gr_Base
Grapheme_Extend Gr_Ext
Hex_Digit Hex
IDS_Binary_Operator IDSB
IDS_Trinary_Operator IDST
ID_Continue IDC
ID_Start IDS
Ideographic Ideo
Join_Control Join_C
Logical_Order_Exception LOE
Lowercase Lower
Math
Noncharacter_Code_Point NChar
Pattern_Syntax Pat_Syn
Pattern_White_Space Pat_WS
Quotation_Mark QMark
Radical
Regional_Indicator RI
Sentence_Terminal STerm
Soft_Dotted SD
Terminal_Punctuation Term
Unified_Ideograph UIdeo
Uppercase Upper
Variation_Selector VS
White_Space space
XID_Continue XIDC
XID_Start XIDS`.split(/\s/).map((p) => [$2(p), p])
);
var LowerToAlternativeLowerCaseMap = /* @__PURE__ */ new Map([
  ["s", cp(383)],
  // s, Å¿
  [cp(383), "s"]
  // Å¿, s
]);
var LowerToAlternativeUpperCaseMap = /* @__PURE__ */ new Map([
  [cp(223), cp(7838)],
  // ÃŸ, áºž
  [cp(107), cp(8490)],
  // k, â„ª (Kelvin)
  [cp(229), cp(8491)],
  // Ã¥, â„« (Angstrom)
  [cp(969), cp(8486)]
  // Ï‰, â„¦ (Ohm)
]);
var LowerToTitleCaseMap = new Map([
  titleEntry(453),
  titleEntry(456),
  titleEntry(459),
  titleEntry(498),
  ...titleRange(8072, 8079),
  ...titleRange(8088, 8095),
  ...titleRange(8104, 8111),
  titleEntry(8124),
  titleEntry(8140),
  titleEntry(8188)
]);
var PosixClassMap = /* @__PURE__ */ new Map([
  ["alnum", r`[\p{Alpha}\p{Nd}]`],
  ["alpha", r`\p{Alpha}`],
  ["ascii", r`\p{ASCII}`],
  ["blank", r`[\p{Zs}\t]`],
  ["cntrl", r`\p{Cc}`],
  ["digit", r`\p{Nd}`],
  ["graph", r`[\P{space}&&\P{Cc}&&\P{Cn}&&\P{Cs}]`],
  ["lower", r`\p{Lower}`],
  ["print", r`[[\P{space}&&\P{Cc}&&\P{Cn}&&\P{Cs}]\p{Zs}]`],
  ["punct", r`[\p{P}\p{S}]`],
  // Updated value from Oniguruma 6.9.9; not Unicode `\p{punct}`
  ["space", r`\p{space}`],
  ["upper", r`\p{Upper}`],
  ["word", r`[\p{Alpha}\p{M}\p{Nd}\p{Pc}]`],
  ["xdigit", r`\p{AHex}`]
]);
function range(start, end) {
  const range2 = [];
  for (let i2 = start; i2 <= end; i2++) {
    range2.push(i2);
  }
  return range2;
}
function titleEntry(codePoint) {
  const char = cp(codePoint);
  return [char.toLowerCase(), char];
}
function titleRange(start, end) {
  return range(start, end).map((codePoint) => titleEntry(codePoint));
}
var UnicodePropertiesWithSpecificCase = /* @__PURE__ */ new Set([
  "Lower",
  "Lowercase",
  "Upper",
  "Uppercase",
  "Ll",
  "Lowercase_Letter",
  "Lt",
  "Titlecase_Letter",
  "Lu",
  "Uppercase_Letter"
  // The `Changes_When_*` properties (and their aliases) could be included, but they're very rare.
  // Some other properties include a handful of chars with specific cases only, but these chars are
  // generally extreme edge cases and using such properties case insensitively generally produces
  // undesired behavior anyway
]);

// node_modules/.pnpm/emoji-regex-xs@1.0.0/node_modules/emoji-regex-xs/index.mjs
var r2 = String.raw;
var seq = r2`(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation})`;
var sTags = r2`\u{E0061}-\u{E007A}`;
var emoji_regex_xs_default = () => new RegExp(r2`[\u{1F1E6}-\u{1F1FF}]{2}|\u{1F3F4}[${sTags}]{2}[\u{E0030}-\u{E0039}${sTags}]{1,3}\u{E007F}|${seq}(?:\u200D${seq})*`, "gu");

// node_modules/.pnpm/oniguruma-parser@0.5.4/node_modules/oniguruma-parser/dist/traverser/traverse.js
function T2(A3, C2, p = null) {
  function x3(e2, i2) {
    for (let r4 = 0; r4 < e2.length; r4++) {
      const a = l(e2[r4], i2, r4, e2);
      r4 = Math.max(-1, r4 + a);
    }
  }
  function l(e2, i2 = null, r4 = null, a = null) {
    const f2 = "Container expected";
    let c2 = 0, n = false;
    const u = { node: e2, parent: i2, key: r4, container: a, root: A3, remove() {
      c(a, f2).splice(Math.max(0, r4 + c2), 1), c2--, n = true;
    }, removeAllNextSiblings() {
      return c(a, f2).splice(r4 + 1);
    }, removeAllPrevSiblings() {
      const s4 = r4 + c2;
      return c2 -= s4, c(a, f2).splice(0, Math.max(0, s4));
    }, replaceWith(s4, g2 = {}) {
      const b3 = !!g2.traverse;
      a ? a[Math.max(0, r4 + c2)] = s4 : i2[r4] = s4, b3 && l(s4, i2, r4, a), n = true;
    }, replaceWithMultiple(s4, g2 = {}) {
      const b3 = !!g2.traverse;
      if (c(a, f2).splice(Math.max(0, r4 + c2), 1, ...s4), c2 += s4.length - 1, b3) {
        let S2 = 0;
        for (let o3 = 0; o3 < s4.length; o3++) S2 += l(s4[o3], i2, r4 + o3 + S2, a);
      }
      n = true;
    }, skip() {
      n = true;
    } }, h2 = C2["*"], m = C2[e2.type], k3 = typeof h2 == "function" ? h2 : h2?.enter, M3 = typeof m == "function" ? m : m?.enter;
    if (k3?.(u, p), M3?.(u, p), !n) switch (e2.type) {
      case s3.Regex:
        l(e2.pattern, e2, "pattern"), l(e2.flags, e2, "flags");
        break;
      case s3.Alternative:
      case s3.CharacterClass:
        x3(e2.elements, e2);
        break;
      case s3.Assertion:
      case s3.Backreference:
      case s3.Character:
      case s3.CharacterSet:
      case s3.Directive:
      case s3.Flags:
      case s3.Recursion:
      case s3.Subroutine:
        break;
      case s3.AbsentFunction:
      case s3.CapturingGroup:
      case s3.Group:
      case s3.Pattern:
        x3(e2.alternatives, e2);
        break;
      case s3.CharacterClassRange:
        l(e2.min, e2, "min"), l(e2.max, e2, "max");
        break;
      case s3.LookaroundAssertion:
        x3(e2.alternatives, e2);
        break;
      case s3.Quantifier:
        l(e2.element, e2, "element");
        break;
      default:
        throw new Error(`Unexpected node type "${e2.type}"`);
    }
    return h2?.exit?.(u, p), m?.exit?.(u, p), c2;
  }
  l(A3);
}

// src/transform.js
function transform(ast, options) {
  const opts = {
    // A couple edge cases exist where options `accuracy` and `bestEffortTarget` are used:
    // - `CharacterSet` kind `grapheme` (`\X`): An exact representation would require heavy Unicode
    //   data; a best-effort approximation requires knowing the target.
    // - `CharacterSet` kind `posix` with values `graph` and `print`: Their complex Unicode-based
    //   representations would be hard to change to ASCII-based after the fact in the generator
    //   based on `target`/`accuracy`, so produce the appropriate structure here.
    accuracy: "default",
    asciiWordBoundaries: false,
    avoidSubclass: false,
    bestEffortTarget: "ES2025",
    ...options
  };
  addParentProperties(ast);
  const firstPassState = {
    accuracy: opts.accuracy,
    asciiWordBoundaries: opts.asciiWordBoundaries,
    avoidSubclass: opts.avoidSubclass,
    flagDirectivesByAlt: /* @__PURE__ */ new Map(),
    jsGroupNameMap: /* @__PURE__ */ new Map(),
    minTargetEs2024: isMinTarget(opts.bestEffortTarget, "ES2024"),
    passedLookbehind: false,
    strategy: null,
    // Subroutines can appear before the groups they ref, so collect reffed nodes for a second pass 
    subroutineRefMap: /* @__PURE__ */ new Map(),
    supportedGNodes: /* @__PURE__ */ new Set(),
    digitIsAscii: ast.flags.digitIsAscii,
    spaceIsAscii: ast.flags.spaceIsAscii,
    wordIsAscii: ast.flags.wordIsAscii
  };
  T2(ast, FirstPassVisitor, firstPassState);
  const globalFlags = {
    dotAll: ast.flags.dotAll,
    ignoreCase: ast.flags.ignoreCase
  };
  const secondPassState = {
    currentFlags: globalFlags,
    prevFlags: null,
    globalFlags,
    groupOriginByCopy: /* @__PURE__ */ new Map(),
    groupsByName: /* @__PURE__ */ new Map(),
    multiplexCapturesToLeftByRef: /* @__PURE__ */ new Map(),
    openRefs: /* @__PURE__ */ new Map(),
    reffedNodesByReferencer: /* @__PURE__ */ new Map(),
    subroutineRefMap: firstPassState.subroutineRefMap
  };
  T2(ast, SecondPassVisitor, secondPassState);
  const thirdPassState = {
    groupsByName: secondPassState.groupsByName,
    highestOrphanBackref: 0,
    numCapturesToLeft: 0,
    reffedNodesByReferencer: secondPassState.reffedNodesByReferencer
  };
  T2(ast, ThirdPassVisitor, thirdPassState);
  ast._originMap = secondPassState.groupOriginByCopy;
  ast._strategy = firstPassState.strategy;
  return ast;
}
var FirstPassVisitor = {
  AbsentFunction({ node, parent, replaceWith }) {
    const { kind, alternatives } = node;
    if (kind === F2.repeater) {
      const group = prepContainer(S(), [
        adoptAndSwapKids(Q({ negate: true }), alternatives),
        Y("Any")
      ]);
      const quantifier = Z(group, 0, Infinity);
      group.parent = quantifier;
      replaceWith(setParent(prepContainer(S(), [quantifier]), parent), { traverse: true });
    } else {
      throw new Error(`Unexpected absent function kind "${kind}"`);
    }
  },
  Alternative: {
    enter({ node, parent, key }, { flagDirectivesByAlt }) {
      const flagDirectives = node.elements.filter((el) => el.kind === E2.flags);
      for (let i2 = key + 1; i2 < parent.alternatives.length; i2++) {
        const forwardSiblingAlt = parent.alternatives[i2];
        getOrInsert(flagDirectivesByAlt, forwardSiblingAlt, []).push(...flagDirectives);
      }
    },
    exit({ node }, { flagDirectivesByAlt }) {
      if (flagDirectivesByAlt.get(node)?.length) {
        const flags = getCombinedFlagModsFromFlagNodes(flagDirectivesByAlt.get(node));
        if (flags) {
          const flagGroup = setParent(prepContainer(S({ flags }), node.elements), node);
          node.elements = [flagGroup];
        }
      }
    }
  },
  Assertion({ node, parent, key, container, root, remove, replaceWith }, state) {
    const { kind, negate } = node;
    const { asciiWordBoundaries, avoidSubclass, supportedGNodes, wordIsAscii } = state;
    if (kind === f.grapheme_boundary) {
      throw new Error(`Unsupported grapheme boundary "\\${negate ? "Y" : "y"}"`);
    } else if (kind === f.line_end) {
      replaceWith(setParent(parseFragment(r`(?=\z|\n)`), parent));
    } else if (kind === f.line_start) {
      replaceWith(setParent(parseFragment(r`(?<=\A|\n(?!\z))`, { skipLookbehindValidation: true }), parent));
    } else if (kind === f.search_start) {
      if (supportedGNodes.has(node)) {
        root.flags.sticky = true;
        remove();
      } else {
        const prev = container[key - 1];
        if (prev && isAlwaysNonZeroLength(prev)) {
          replaceWith(setParent(prepContainer(Q({ negate: true })), parent));
        } else if (avoidSubclass) {
          throw new Error(r`Uses "\G" in a way that requires a subclass`);
        } else {
          replaceWith(setParent(V(f.string_start), parent));
          state.strategy = "clip_search";
        }
      }
    } else if (kind === f.string_end || kind === f.string_start) {
    } else if (kind === f.string_end_newline) {
      replaceWith(setParent(parseFragment(r`(?=\n?\z)`), parent));
    } else if (kind === f.word_boundary) {
      if (!wordIsAscii && !asciiWordBoundaries) {
        const b3 = `(?:(?<=${defaultWordChar})(?!${defaultWordChar})|(?<!${defaultWordChar})(?=${defaultWordChar}))`;
        const B2 = `(?:(?<=${defaultWordChar})(?=${defaultWordChar})|(?<!${defaultWordChar})(?!${defaultWordChar}))`;
        replaceWith(setParent(parseFragment(negate ? B2 : b3), parent));
      }
    } else {
      throw new Error(`Unexpected assertion kind "${kind}"`);
    }
  },
  Backreference({ node }, { jsGroupNameMap }) {
    let { ref } = node;
    if (typeof ref === "string" && !isValidJsGroupName(ref)) {
      ref = getAndStoreJsGroupName(ref, jsGroupNameMap);
      node.ref = ref;
    }
  },
  CapturingGroup({ node }, { jsGroupNameMap, subroutineRefMap }) {
    let { name } = node;
    if (name && !isValidJsGroupName(name)) {
      name = getAndStoreJsGroupName(name, jsGroupNameMap);
      node.name = name;
    }
    subroutineRefMap.set(node.number, node);
    if (name) {
      subroutineRefMap.set(name, node);
    }
  },
  CharacterClassRange({ node, parent, replaceWith }) {
    if (parent.kind === L.intersection) {
      replaceWith(setParent(adoptAndSwapKids(G(), [node]), parent), { traverse: true });
    }
  },
  CharacterSet({ node, parent, replaceWith }, { accuracy, minTargetEs2024, digitIsAscii, spaceIsAscii, wordIsAscii }) {
    const { kind, negate, value } = node;
    if (digitIsAscii && (kind === A2.digit || value === "digit")) {
      replaceWith(setParent(T(A2.digit, { negate }), parent));
      return;
    }
    if (spaceIsAscii && (kind === A2.space || value === "space")) {
      replaceWith(setParent(setNegate(parseFragment(asciiSpaceChar), negate), parent));
      return;
    }
    if (wordIsAscii && (kind === A2.word || value === "word")) {
      replaceWith(setParent(T(A2.word, { negate }), parent));
      return;
    }
    if (kind === A2.any) {
      replaceWith(setParent(Y("Any"), parent));
    } else if (kind === A2.digit) {
      replaceWith(setParent(Y("Nd", { negate }), parent));
    } else if (kind === A2.dot) {
    } else if (kind === A2.grapheme) {
      if (accuracy === "strict") {
        throw new Error(r`Use of "\X" requires non-strict accuracy`);
      }
      const emoji = minTargetEs2024 ? r`\p{RGI_Emoji}` : emoji_regex_xs_default().source.replace(/\\u\{/g, `\\x{`);
      replaceWith(setParent(parseFragment(r`(?>\r\n|${emoji}|\P{M}\p{M}*)`, { skipPropertyNameValidation: true }), parent));
    } else if (kind === A2.hex) {
      replaceWith(setParent(Y("AHex", { negate }), parent));
    } else if (kind === A2.newline) {
      replaceWith(setParent(parseFragment(negate ? "[^\n]" : "(?>\r\n?|[\n\v\f\x85\u2028\u2029])"), parent));
    } else if (kind === A2.posix) {
      if (!minTargetEs2024 && (value === "graph" || value === "print")) {
        if (accuracy === "strict") {
          throw new Error(`POSIX class "${value}" requires min target ES2024 or non-strict accuracy`);
        }
        let ascii = {
          graph: "!-~",
          print: " -~"
        }[value];
        if (negate) {
          ascii = `\0-${cp(ascii.codePointAt(0) - 1)}${cp(ascii.codePointAt(2) + 1)}-\u{10FFFF}`;
        }
        replaceWith(setParent(parseFragment(`[${ascii}]`), parent));
      } else {
        replaceWith(setParent(setNegate(parseFragment(PosixClassMap.get(value)), negate), parent));
      }
    } else if (kind === A2.property) {
      if (!JsUnicodePropertyMap.has($2(value))) {
        node.key = "sc";
      }
    } else if (kind === A2.space) {
      replaceWith(setParent(Y("space", { negate }), parent));
    } else if (kind === A2.word) {
      replaceWith(setParent(setNegate(parseFragment(defaultWordChar), negate), parent));
    } else {
      throw new Error(`Unexpected character set kind "${kind}"`);
    }
  },
  Directive({ node, parent, root, remove, replaceWith, removeAllPrevSiblings, removeAllNextSiblings }) {
    const { kind, flags } = node;
    if (kind === E2.flags) {
      if (!flags.enable && !flags.disable) {
        remove();
      } else {
        replaceWith(setParent(prepContainer(S({ flags }), removeAllNextSiblings()), parent), { traverse: true });
      }
    } else if (kind === E2.keep) {
      const firstAltFirstEl = root.pattern.alternatives[0].elements[0];
      const hasWrapperGroup = (
        // Not emulatable if within a `CapturingGroup`
        hasOnlyChild(root.pattern, (kid) => kid.type === s3.Group) && firstAltFirstEl.alternatives.length === 1
      );
      const topLevel = hasWrapperGroup ? firstAltFirstEl : root.pattern;
      if (parent.parent !== topLevel || topLevel.alternatives.length > 1) {
        throw new Error(r`Uses "\K" in a way that's unsupported`);
      }
      replaceWith(setParent(prepContainer(Q({ behind: true }), removeAllPrevSiblings()), parent));
    } else {
      throw new Error(`Unexpected directive kind "${kind}"`);
    }
  },
  Flags({ node, parent }) {
    if (node.posixIsAscii) {
      throw new Error('Unsupported flag "P"');
    }
    [
      "digitIsAscii",
      // Flag D
      "extended",
      // Flag x
      "posixIsAscii",
      // Flag P
      "spaceIsAscii",
      // Flag S
      "wordIsAscii"
      // Flag W
    ].forEach((f2) => delete node[f2]);
    Object.assign(node, {
      // JS flag g; no Onig equiv
      global: false,
      // JS flag d; no Onig equiv
      hasIndices: false,
      // JS flag m; no Onig equiv but its behavior is always on in Onig. Onig's only line break
      // char is line feed, unlike JS, so this flag isn't used since it would produce inaccurate
      // results (also allows `^` and `$` to be used in the generator for string start and end)
      multiline: false,
      // JS flag y; no Onig equiv, but used for `\G` emulation
      sticky: node.sticky ?? false
      // Note: Regex+ doesn't allow explicitly adding flags it handles implicitly, so leave out
      // properties `unicode` (JS flag u) and `unicodeSets` (JS flag v). Keep the existing values
      // for `ignoreCase` (flag i) and `dotAll` (JS flag s, but Onig flag m)
    });
    parent.options = {
      disable: {
        // Onig uses different rules for flag x than Regex+, so disable the implicit flag
        x: true,
        // Onig has no flag to control "named capture only" mode but contextually applies its
        // behavior when named capturing is used, so disable Regex+'s implicit flag for it
        n: true
      },
      force: {
        // Always add flag v because we're generating an AST that relies on it (it enables JS
        // support for Onig features nested classes, intersection, Unicode properties, etc.).
        // However, the generator might disable flag v based on its `target` option
        v: true
      }
    };
  },
  Group({ node }) {
    if (!node.flags) {
      return;
    }
    const { enable, disable } = node.flags;
    enable?.extended && delete enable.extended;
    disable?.extended && delete disable.extended;
    enable?.dotAll && disable?.dotAll && delete enable.dotAll;
    enable?.ignoreCase && disable?.ignoreCase && delete enable.ignoreCase;
    enable && !Object.keys(enable).length && delete node.flags.enable;
    disable && !Object.keys(disable).length && delete node.flags.disable;
    !node.flags.enable && !node.flags.disable && delete node.flags;
  },
  LookaroundAssertion({ node }, state) {
    const { kind } = node;
    if (kind === b2.lookbehind) {
      state.passedLookbehind = true;
    }
  },
  Pattern: {
    enter({ node }, { supportedGNodes }) {
      const leadingGs = [];
      let hasAltWithLeadG = false;
      let hasAltWithoutLeadG = false;
      for (const alt of node.alternatives) {
        if (alt.elements.length === 1 && alt.elements[0].kind === f.search_start) {
          alt.elements.pop();
        } else {
          const leadingG = getLeadingG(alt.elements);
          if (leadingG) {
            hasAltWithLeadG = true;
            Array.isArray(leadingG) ? leadingGs.push(...leadingG) : leadingGs.push(leadingG);
          } else {
            hasAltWithoutLeadG = true;
          }
        }
      }
      if (hasAltWithLeadG && !hasAltWithoutLeadG) {
        leadingGs.forEach((g2) => supportedGNodes.add(g2));
      }
    },
    exit(_2, { accuracy, passedLookbehind, strategy }) {
      if (accuracy === "strict" && passedLookbehind && strategy) {
        throw new Error(r`Uses "\G" in a way that requires non-strict accuracy`);
      }
    }
  },
  Quantifier({ node }) {
    if (node.element.type === s3.Quantifier) {
      const group = setParent(prepContainer(S(), [node.element]), node);
      node.element = group;
    }
  },
  Subroutine({ node }, { jsGroupNameMap }) {
    let { ref } = node;
    if (typeof ref === "string" && !isValidJsGroupName(ref)) {
      ref = getAndStoreJsGroupName(ref, jsGroupNameMap);
      node.ref = ref;
    }
  }
};
var SecondPassVisitor = {
  Backreference({ node }, { multiplexCapturesToLeftByRef, reffedNodesByReferencer }) {
    const { orphan, ref } = node;
    if (!orphan) {
      reffedNodesByReferencer.set(node, [...multiplexCapturesToLeftByRef.get(ref).map(({ node: node2 }) => node2)]);
    }
  },
  CapturingGroup: {
    enter({
      node,
      parent,
      replaceWith,
      skip
    }, {
      groupOriginByCopy,
      groupsByName,
      multiplexCapturesToLeftByRef,
      openRefs,
      reffedNodesByReferencer
    }) {
      const origin = groupOriginByCopy.get(node);
      if (origin && openRefs.has(node.number)) {
        const recursion2 = setParent(createRecursion(node.number), parent);
        reffedNodesByReferencer.set(recursion2, openRefs.get(node.number));
        replaceWith(recursion2);
        return;
      }
      openRefs.set(node.number, node);
      multiplexCapturesToLeftByRef.set(node.number, []);
      if (node.name) {
        getOrInsert(multiplexCapturesToLeftByRef, node.name, []);
      }
      const multiplexNodes = multiplexCapturesToLeftByRef.get(node.name ?? node.number);
      for (let i2 = 0; i2 < multiplexNodes.length; i2++) {
        const multiplex = multiplexNodes[i2];
        if (
          // This group is from subroutine expansion, and there's a multiplex value from either the
          // origin node or a prior subroutine expansion group with the same origin
          origin === multiplex.node || origin && origin === multiplex.origin || // This group is not from subroutine expansion, and it comes after a subroutine expansion
          // group that refers to this group
          node === multiplex.origin
        ) {
          multiplexNodes.splice(i2, 1);
          break;
        }
      }
      multiplexCapturesToLeftByRef.get(node.number).push({ node, origin });
      if (node.name) {
        multiplexCapturesToLeftByRef.get(node.name).push({ node, origin });
      }
      if (node.name) {
        const groupsWithSameName = getOrInsert(groupsByName, node.name, /* @__PURE__ */ new Map());
        let hasDuplicateNameToRemove = false;
        if (origin) {
          hasDuplicateNameToRemove = true;
        } else {
          for (const groupInfo of groupsWithSameName.values()) {
            if (!groupInfo.hasDuplicateNameToRemove) {
              hasDuplicateNameToRemove = true;
              break;
            }
          }
        }
        groupsByName.get(node.name).set(node, { node, hasDuplicateNameToRemove });
      }
    },
    exit({ node }, { openRefs }) {
      openRefs.delete(node.number);
    }
  },
  Group: {
    enter({ node }, state) {
      state.prevFlags = state.currentFlags;
      if (node.flags) {
        state.currentFlags = getNewCurrentFlags(state.currentFlags, node.flags);
      }
    },
    exit(_2, state) {
      state.currentFlags = state.prevFlags;
    }
  },
  Recursion({ node, parent }, { reffedNodesByReferencer }) {
    const { ref } = node;
    let reffed = parent;
    while (reffed = reffed.parent) {
      if (reffed.type === s3.CapturingGroup && (reffed.name === ref || reffed.number === ref)) {
        break;
      }
    }
    reffedNodesByReferencer.set(node, reffed);
  },
  Subroutine({ node, parent, replaceWith }, state) {
    const { ref } = node;
    const reffedGroupNode = state.subroutineRefMap.get(ref);
    const isGlobalRecursion = ref === 0;
    const expandedSubroutine = isGlobalRecursion ? createRecursion(0) : (
      // The reffed group might itself contain subroutines, which are expanded during sub-traversal
      cloneCapturingGroup(reffedGroupNode, state.groupOriginByCopy, null)
    );
    let replacement = expandedSubroutine;
    if (!isGlobalRecursion) {
      const reffedGroupFlagMods = getCombinedFlagModsFromFlagNodes(getAllParents(reffedGroupNode, (node2) => {
        return node2.type === s3.Group && !!node2.flags;
      }));
      const reffedGroupFlags = reffedGroupFlagMods ? getNewCurrentFlags(state.globalFlags, reffedGroupFlagMods) : state.globalFlags;
      if (!areFlagsEqual(reffedGroupFlags, state.currentFlags)) {
        replacement = prepContainer(S({
          flags: getFlagModsFromFlags(reffedGroupFlags)
        }), [expandedSubroutine]);
      }
    }
    replaceWith(setParent(replacement, parent), { traverse: !isGlobalRecursion });
  }
};
var ThirdPassVisitor = {
  Backreference({ node, parent, replaceWith }, state) {
    if (node.orphan) {
      state.highestOrphanBackref = Math.max(state.highestOrphanBackref, node.ref);
      return;
    }
    const reffedNodes = state.reffedNodesByReferencer.get(node);
    const participants = reffedNodes.filter((reffed) => canParticipateWithNode(reffed, node));
    if (!participants.length) {
      replaceWith(setParent(prepContainer(Q({ negate: true })), parent));
    } else if (participants.length > 1) {
      const alts = participants.map((reffed) => adoptAndSwapKids(
        k2(),
        [P2(reffed.number)]
      ));
      replaceWith(setParent(adoptAndSwapKids(S(), alts), parent));
    } else {
      node.ref = participants[0].number;
    }
  },
  CapturingGroup({ node }, state) {
    node.number = ++state.numCapturesToLeft;
    if (node.name) {
      if (state.groupsByName.get(node.name).get(node).hasDuplicateNameToRemove) {
        delete node.name;
      }
    }
  },
  Recursion({ node }, state) {
    if (node.ref === 0) {
      return;
    }
    node.ref = state.reffedNodesByReferencer.get(node).number;
  },
  Regex: {
    exit({ node }, state) {
      const numCapsNeeded = Math.max(state.highestOrphanBackref - state.numCapturesToLeft, 0);
      for (let i2 = 0; i2 < numCapsNeeded; i2++) {
        const emptyCapture = x2();
        node.pattern.alternatives.at(-1).elements.push(emptyCapture);
      }
    }
  }
};
function addParentProperties(ast) {
  T2(ast, {
    "*"({ node, parent }) {
      node.parent = parent;
    }
  });
}
function adoptAndSwapKids(parent, kids) {
  kids.forEach((kid) => kid.parent = parent);
  parent[getContainerAccessor(parent)] = kids;
  return parent;
}
function areFlagsEqual(a, b3) {
  return a.dotAll === b3.dotAll && a.ignoreCase === b3.ignoreCase;
}
function canParticipateWithNode(capture, node) {
  let rightmostPoint = node;
  do {
    if (rightmostPoint.type === s3.Pattern) {
      return false;
    }
    if (rightmostPoint.type === s3.Alternative) {
      continue;
    }
    if (rightmostPoint === capture) {
      return false;
    }
    const kidsOfParent = getKids(rightmostPoint.parent);
    for (const kid of kidsOfParent) {
      if (kid === rightmostPoint) {
        break;
      }
      if (kid === capture) {
        return true;
      }
      if (hasDescendant(kid, capture)) {
        return true;
      }
    }
  } while (rightmostPoint = rightmostPoint.parent);
  throw new Error("Unexpected path");
}
function cloneCapturingGroup(obj, originMap, up, up2) {
  const store = Array.isArray(obj) ? [] : {};
  for (const [key, value] of Object.entries(obj)) {
    if (key === "parent") {
      store.parent = Array.isArray(up) ? up2 : up;
    } else if (value && typeof value === "object") {
      store[key] = cloneCapturingGroup(value, originMap, store, up);
    } else {
      if (key === "type" && value === s3.CapturingGroup) {
        originMap.set(store, originMap.get(obj) ?? obj);
      }
      store[key] = value;
    }
  }
  return store;
}
function createRecursion(ref) {
  return {
    type: s3.Recursion,
    ref
  };
}
function getAllParents(node, filterFn) {
  const results = [];
  while (node = node.parent) {
    if (!filterFn || filterFn(node)) {
      results.push(node);
    }
  }
  return results;
}
function getAndStoreJsGroupName(name, map) {
  if (map.has(name)) {
    return map.get(name);
  }
  const jsName = `$${map.size}_${name.replace(/^[^$_\p{IDS}]|[^$\u200C\u200D\p{IDC}]/ug, "_")}`;
  map.set(name, jsName);
  return jsName;
}
function getContainerAccessor(node) {
  for (const accessor of ["alternatives", "elements"]) {
    if (node[accessor]) {
      return accessor;
    }
  }
  return null;
}
function getCombinedFlagModsFromFlagNodes(flagNodes) {
  const flagProps = ["dotAll", "ignoreCase"];
  const combinedFlags = { enable: {}, disable: {} };
  flagNodes.forEach(({ flags }) => {
    flagProps.forEach((prop) => {
      if (flags.enable?.[prop]) {
        delete combinedFlags.disable[prop];
        combinedFlags.enable[prop] = true;
      }
      if (flags.disable?.[prop]) {
        combinedFlags.disable[prop] = true;
      }
    });
  });
  if (!Object.keys(combinedFlags.enable).length) {
    delete combinedFlags.enable;
  }
  if (!Object.keys(combinedFlags.disable).length) {
    delete combinedFlags.disable;
  }
  if (combinedFlags.enable || combinedFlags.disable) {
    return combinedFlags;
  }
  return null;
}
function getFlagModsFromFlags({ dotAll, ignoreCase }) {
  const mods = {};
  if (dotAll || ignoreCase) {
    mods.enable = {};
    dotAll && (mods.enable.dotAll = true);
    ignoreCase && (mods.enable.ignoreCase = true);
  }
  if (!dotAll || !ignoreCase) {
    mods.disable = {};
    !dotAll && (mods.disable.dotAll = true);
    !ignoreCase && (mods.disable.ignoreCase = true);
  }
  return mods;
}
function getKids(node) {
  if (!node) {
    throw new Error("Node expected");
  }
  if (node.type === s3.Quantifier) {
    return [node.element];
  }
  const accessor = getContainerAccessor(node);
  return accessor && node[accessor];
}
function getLeadingG(els) {
  const firstToConsider = els.find((el) => el.kind === f.search_start || isLoneGLookaround(el, { negate: false }) || !isAlwaysZeroLength(el));
  if (!firstToConsider) {
    return null;
  }
  if (firstToConsider.kind === f.search_start) {
    return firstToConsider;
  }
  if (firstToConsider.type === s3.LookaroundAssertion) {
    return firstToConsider.alternatives[0].elements[0];
  }
  if (firstToConsider.type === s3.CapturingGroup || firstToConsider.type === s3.Group) {
    const gNodesForGroup = [];
    for (const alt of firstToConsider.alternatives) {
      const leadingG = getLeadingG(alt.elements);
      if (!leadingG) {
        return null;
      }
      Array.isArray(leadingG) ? gNodesForGroup.push(...leadingG) : gNodesForGroup.push(leadingG);
    }
    return gNodesForGroup;
  }
  return null;
}
function hasDescendant(node, descendant) {
  const kids = getKids(node) ?? [];
  for (const kid of kids) {
    if (kid === descendant || hasDescendant(kid, descendant)) {
      return true;
    }
  }
  return false;
}
function hasOnlyChild({ alternatives }, kidFn) {
  return alternatives.length === 1 && alternatives[0].elements.length === 1 && (!kidFn || kidFn(alternatives[0].elements[0]));
}
function isAlwaysZeroLength({ type }) {
  return type === s3.Assertion || type === s3.Directive || type === s3.LookaroundAssertion;
}
function isAlwaysNonZeroLength(node) {
  const types = [
    s3.Character,
    s3.CharacterClass,
    s3.CharacterSet
  ];
  return types.includes(node.type) || node.type === s3.Quantifier && node.min && types.includes(node.element.type);
}
function isLoneGLookaround(node, options) {
  const opts = {
    negate: null,
    ...options
  };
  return node.type === s3.LookaroundAssertion && (opts.negate === null || node.negate === opts.negate) && hasOnlyChild(node, (kid) => kid.kind === f.search_start);
}
function isValidJsGroupName(name) {
  return /^[$_\p{IDS}][$\u200C\u200D\p{IDC}]*$/u.test(name);
}
function parseFragment(pattern, options) {
  const ast = ne(pattern, {
    ...options,
    // Providing a custom set of Unicode property names avoids converting some JS Unicode
    // properties (ex: `\p{Alpha}`) to Onig POSIX classes
    unicodePropertyMap: JsUnicodePropertyMap
  });
  addParentProperties(ast);
  const alts = ast.pattern.alternatives;
  if (alts.length > 1 || alts[0].elements.length > 1) {
    return adoptAndSwapKids(S(), alts);
  }
  return alts[0].elements[0];
}
function prepContainer(node, kids) {
  const accessor = getContainerAccessor(node);
  node[accessor][0].parent = node;
  if (kids) {
    adoptAndSwapKids(node[accessor][0], kids);
  }
  return node;
}
function setNegate(node, negate) {
  node.negate = negate;
  return node;
}
function setParent(node, parent) {
  node.parent = parent;
  return node;
}

// src/generate.js
function generate(ast, options) {
  const opts = getOptions(options);
  const minTargetEs2024 = isMinTarget(opts.target, "ES2024");
  const minTargetEs2025 = isMinTarget(opts.target, "ES2025");
  const recursionLimit = opts.rules.recursionLimit;
  if (!Number.isInteger(recursionLimit) || recursionLimit < 2 || recursionLimit > 20) {
    throw new Error("Invalid recursionLimit; use 2-20");
  }
  let hasCaseInsensitiveNode = null;
  let hasCaseSensitiveNode = null;
  if (!minTargetEs2025) {
    const iStack = [ast.flags.ignoreCase];
    T2(ast, FlagModifierVisitor, {
      getCurrentModI: () => iStack.at(-1),
      popModI() {
        iStack.pop();
      },
      pushModI(isIOn) {
        iStack.push(isIOn);
      },
      setHasCasedChar() {
        if (iStack.at(-1)) {
          hasCaseInsensitiveNode = true;
        } else {
          hasCaseSensitiveNode = true;
        }
      }
    });
  }
  const appliedGlobalFlags = {
    dotAll: ast.flags.dotAll,
    // - Turn global flag i on if a case insensitive node was used and no case sensitive nodes were
    //   used (to avoid unnecessary node expansion).
    // - Turn global flag i off if a case sensitive node was used (since case sensitivity can't be
    //   forced without the use of ES2025 flag groups)
    ignoreCase: !!((ast.flags.ignoreCase || hasCaseInsensitiveNode) && !hasCaseSensitiveNode)
  };
  let lastNode = null;
  const state = {
    accuracy: opts.accuracy,
    appliedGlobalFlags,
    captureMap: /* @__PURE__ */ new Map(),
    currentFlags: {
      dotAll: ast.flags.dotAll,
      ignoreCase: ast.flags.ignoreCase
    },
    inCharClass: false,
    lastNode,
    originMap: ast._originMap,
    recursionLimit,
    useAppliedIgnoreCase: !!(!minTargetEs2025 && hasCaseInsensitiveNode && hasCaseSensitiveNode),
    useFlagMods: minTargetEs2025,
    useFlagV: minTargetEs2024,
    verbose: opts.verbose
  };
  function gen(node) {
    state.lastNode = lastNode;
    lastNode = node;
    switch (node.type) {
      case s3.Regex:
        return {
          pattern: gen(node.pattern),
          flags: gen(node.flags),
          options: { ...node.options }
        };
      case s3.Alternative:
        return node.elements.map(gen).join("");
      case s3.Assertion:
        return genAssertion(node);
      case s3.Backreference:
        return genBackreference(node, state);
      case s3.CapturingGroup:
        return genCapturingGroup(node, state, gen);
      case s3.Character:
        return genCharacter(node, state);
      case s3.CharacterClass:
        return genCharacterClass(node, state, gen);
      case s3.CharacterClassRange:
        return genCharacterClassRange(node, state);
      case s3.CharacterSet:
        return genCharacterSet(node, state);
      case s3.Flags:
        return genFlags(node, state);
      case s3.Group:
        return genGroup(node, state, gen);
      case s3.LookaroundAssertion:
        return genLookaroundAssertion(node, state, gen);
      case s3.Pattern:
        return node.alternatives.map(gen).join("|");
      case s3.Quantifier:
        return gen(node.element) + getQuantifierStr(node);
      case s3.Recursion:
        return genRecursion(node, state);
      default:
        throw new Error(`Unexpected node type "${node.type}"`);
    }
  }
  const result = gen(ast);
  if (!minTargetEs2024) {
    delete result.options.force.v;
    result.options.disable.v = true;
    result.options.unicodeSetsPlugin = null;
  }
  result._captureTransfers = /* @__PURE__ */ new Map();
  result._hiddenCaptures = [];
  state.captureMap.forEach((value, key) => {
    if (value.hidden) {
      result._hiddenCaptures.push(key);
    }
    if (value.transferTo) {
      getOrInsert(result._captureTransfers, value.transferTo, []).push(key);
    }
  });
  return result;
}
var FlagModifierVisitor = {
  "*": {
    enter({ node }, state) {
      if (isAnyGroup(node)) {
        const currentModI = state.getCurrentModI();
        state.pushModI(
          node.flags ? getNewCurrentFlags({ ignoreCase: currentModI }, node.flags).ignoreCase : currentModI
        );
      }
    },
    exit({ node }, state) {
      if (isAnyGroup(node)) {
        state.popModI();
      }
    }
  },
  Backreference(_2, state) {
    state.setHasCasedChar();
  },
  Character({ node }, state) {
    if (charHasCase(cp(node.value))) {
      state.setHasCasedChar();
    }
  },
  CharacterClassRange({ node, skip }, state) {
    skip();
    if (getCasesOutsideCharClassRange(node, { firstOnly: true }).length) {
      state.setHasCasedChar();
    }
  },
  CharacterSet({ node }, state) {
    if (node.kind === A2.property && UnicodePropertiesWithSpecificCase.has(node.value)) {
      state.setHasCasedChar();
    }
  }
};
var BaseEscapeChars = /* @__PURE__ */ new Set([
  "$",
  "(",
  ")",
  "*",
  "+",
  ".",
  "?",
  "[",
  "\\",
  "]",
  "^",
  "{",
  "|",
  "}"
]);
var CharClassEscapeChars = /* @__PURE__ */ new Set([
  "-",
  "\\",
  "]",
  "^",
  // Literal `[` doesn't require escaping with flag u, but this can help work around regex source
  // linters and regex syntax processors that expect unescaped `[` to create a nested class
  "["
]);
var CharClassEscapeCharsFlagV = /* @__PURE__ */ new Set([
  "(",
  ")",
  "-",
  "/",
  "[",
  "\\",
  "]",
  "^",
  "{",
  "|",
  "}",
  // Double punctuators; also includes already-listed `-` and `^`
  "!",
  "#",
  "$",
  "%",
  "&",
  "*",
  "+",
  ",",
  ".",
  ":",
  ";",
  "<",
  "=",
  ">",
  "?",
  "@",
  "`",
  "~"
]);
var CharCodeEscapeMap = /* @__PURE__ */ new Map([
  [9, r`\t`],
  // horizontal tab
  [10, r`\n`],
  // line feed
  [11, r`\v`],
  // vertical tab
  [12, r`\f`],
  // form feed
  [13, r`\r`],
  // carriage return
  [8232, r`\u2028`],
  // line separator
  [8233, r`\u2029`],
  // paragraph separator
  [65279, r`\uFEFF`]
  // ZWNBSP/BOM
]);
var casedRe = /^\p{Cased}$/u;
function charHasCase(char) {
  return casedRe.test(char);
}
function genAssertion({ kind, negate }) {
  if (kind === f.string_end) {
    return "$";
  }
  if (kind === f.string_start) {
    return "^";
  }
  if (kind === f.word_boundary) {
    return negate ? r`\B` : r`\b`;
  }
  throw new Error(`Unexpected assertion kind "${kind}"`);
}
function genBackreference({ ref }, state) {
  if (typeof ref !== "number") {
    throw new Error("Unexpected named backref in transformed AST");
  }
  if (!state.useFlagMods && state.accuracy === "strict" && state.currentFlags.ignoreCase && !state.captureMap.get(ref).ignoreCase) {
    throw new Error("Use of case-insensitive backref to case-sensitive group requires target ES2025 or non-strict accuracy");
  }
  return "\\" + ref;
}
function genCapturingGroup(node, state, gen) {
  const { name, number, alternatives } = node;
  const data = { ignoreCase: state.currentFlags.ignoreCase };
  const origin = state.originMap.get(node);
  if (origin) {
    data.hidden = true;
    if (number > origin.number) {
      data.transferTo = origin.number;
    }
  }
  state.captureMap.set(number, data);
  return `(${name ? `?<${name}>` : ""}${alternatives.map(gen).join("|")})`;
}
function genCharacter({ value }, state) {
  const char = cp(value);
  const escaped = getCharEscape(value, {
    escDigit: state.lastNode.type === s3.Backreference,
    inCharClass: state.inCharClass,
    useFlagV: state.useFlagV
  });
  if (escaped !== char) {
    return escaped;
  }
  if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && charHasCase(char)) {
    const cases = getIgnoreCaseMatchChars(char);
    return state.inCharClass ? cases.join("") : cases.length > 1 ? `[${cases.join("")}]` : cases[0];
  }
  return char;
}
function genCharacterClass(node, state, gen) {
  const { kind, negate, parent } = node;
  let { elements } = node;
  if (kind === L.intersection && !state.useFlagV) {
    throw new Error("Use of class intersection requires min target ES2024");
  }
  if (envFlags.literalHyphenIncorrectlyCreatesRange && state.useFlagV && elements.some(isLiteralHyphen)) {
    elements = elements.filter((kid) => !isLiteralHyphen(kid));
    elements.push(I2(45));
  }
  const genClass = () => `[${negate ? "^" : ""}${elements.map(gen).join(kind === L.intersection ? "&&" : "")}]`;
  if (!state.inCharClass) {
    if (!state.useFlagV && !negate) {
      const negatedChildClasses = elements.filter(
        (kid) => kid.type === s3.CharacterClass && kid.kind === L.union && kid.negate
      );
      if (negatedChildClasses.length) {
        const group = S();
        const groupFirstAlt = group.alternatives[0];
        group.parent = parent;
        groupFirstAlt.parent = group;
        elements = elements.filter((kid) => !negatedChildClasses.includes(kid));
        node.elements = elements;
        if (elements.length) {
          node.parent = groupFirstAlt;
          groupFirstAlt.elements.push(node);
        } else {
          group.alternatives.pop();
        }
        negatedChildClasses.forEach((cc) => {
          const newAlt = k2();
          newAlt.parent = group;
          cc.parent = newAlt;
          newAlt.elements.push(cc);
          group.alternatives.push(newAlt);
        });
        return gen(group);
      }
    }
    state.inCharClass = true;
    const result = genClass();
    state.inCharClass = false;
    return result;
  }
  const firstEl = elements[0];
  if (
    // Already established that the parent is a char class via `inCharClass`, so don't check again
    kind === L.union && !negate && firstEl && // Allows many nested classes to work with `target` ES2018 which doesn't support nesting
    ((!state.useFlagV || !state.verbose) && parent.kind === L.union && !(envFlags.literalHyphenIncorrectlyCreatesRange && state.useFlagV) || !state.verbose && parent.kind === L.intersection && // JS doesn't allow intersection with union or ranges
    elements.length === 1 && firstEl.type !== s3.CharacterClassRange)
  ) {
    return elements.map(gen).join("");
  }
  if (!state.useFlagV && parent.type === s3.CharacterClass) {
    throw new Error("Use of nested character class requires min target ES2024");
  }
  return genClass();
}
function genCharacterClassRange(node, state) {
  const min = node.min.value;
  const max = node.max.value;
  const escOpts = {
    escDigit: false,
    inCharClass: true,
    useFlagV: state.useFlagV
  };
  const minStr = getCharEscape(min, escOpts);
  const maxStr = getCharEscape(max, escOpts);
  const extraChars = /* @__PURE__ */ new Set();
  if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase) {
    const charsOutsideRange = getCasesOutsideCharClassRange(node);
    const ranges = getCodePointRangesFromChars(charsOutsideRange);
    ranges.forEach((value) => {
      extraChars.add(
        Array.isArray(value) ? `${getCharEscape(value[0], escOpts)}-${getCharEscape(value[1], escOpts)}` : getCharEscape(value, escOpts)
      );
    });
  }
  return `${minStr}-${maxStr}${[...extraChars].join("")}`;
}
function genCharacterSet({ kind, negate, value, key }, state) {
  if (kind === A2.dot) {
    return state.currentFlags.dotAll ? state.appliedGlobalFlags.dotAll || state.useFlagMods ? "." : "[^]" : (
      // Onig's only line break char is line feed, unlike JS
      r`[^\n]`
    );
  }
  if (kind === A2.digit) {
    return negate ? r`\D` : r`\d`;
  }
  if (kind === A2.property) {
    if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && UnicodePropertiesWithSpecificCase.has(value)) {
      throw new Error(`Unicode property "${value}" can't be case-insensitive when other chars have specific case`);
    }
    return `${negate ? r`\P` : r`\p`}{${key ? `${key}=` : ""}${value}}`;
  }
  if (kind === A2.word) {
    return negate ? r`\W` : r`\w`;
  }
  throw new Error(`Unexpected character set kind "${kind}"`);
}
function genFlags(node, state) {
  return (
    // The transformer should never turn on the properties for flags d, g, and m since Onig doesn't
    // have equivs. Flag m is never relied on since Onig uses different line break chars than JS
    // (node.hasIndices ? 'd' : '') +
    // (node.global ? 'g' : '') +
    // (node.multiline ? 'm' : '') +
    (state.appliedGlobalFlags.ignoreCase ? "i" : "") + (node.dotAll ? "s" : "") + (node.sticky ? "y" : "")
  );
}
function genGroup({ atomic: atomic2, flags, parent, alternatives }, state, gen) {
  const currentFlags = state.currentFlags;
  if (flags) {
    state.currentFlags = getNewCurrentFlags(currentFlags, flags);
  }
  const contents = alternatives.map(gen).join("|");
  const result = !state.verbose && alternatives.length === 1 && parent.type !== s3.Quantifier && !atomic2 && (!state.useFlagMods || !flags) ? contents : `(?${getGroupPrefix(atomic2, flags, state.useFlagMods)}${contents})`;
  state.currentFlags = currentFlags;
  return result;
}
function genLookaroundAssertion({ kind, negate, alternatives }, _2, gen) {
  const prefix = `${kind === b2.lookahead ? "" : "<"}${negate ? "!" : "="}`;
  return `(?${prefix}${alternatives.map(gen).join("|")})`;
}
function genRecursion({ ref }, state) {
  const limit = state.recursionLimit;
  return ref === 0 ? `(?R=${limit})` : r`\g<${ref}&R=${limit}>`;
}
function getCasesOutsideCharClassRange(node, options) {
  const firstOnly = !!options?.firstOnly;
  const min = node.min.value;
  const max = node.max.value;
  const found = [];
  if (min < 65 && (max === 65535 || max >= 131071) || min === 65536 && max >= 131071) {
    return found;
  }
  for (let i2 = min; i2 <= max; i2++) {
    const char = cp(i2);
    if (!charHasCase(char)) {
      continue;
    }
    const charsOutsideRange = getIgnoreCaseMatchChars(char).filter((caseOfChar) => {
      const num = caseOfChar.codePointAt(0);
      return num < min || num > max;
    });
    if (charsOutsideRange.length) {
      found.push(...charsOutsideRange);
      if (firstOnly) {
        break;
      }
    }
  }
  return found;
}
function getCharEscape(codePoint, { escDigit, inCharClass, useFlagV }) {
  if (CharCodeEscapeMap.has(codePoint)) {
    return CharCodeEscapeMap.get(codePoint);
  }
  if (
    // Control chars, etc.; condition modeled on the Chrome developer console's display for strings
    codePoint < 32 || codePoint > 126 && codePoint < 160 || // Unicode planes 4-16; unassigned, special purpose, and private use area
    codePoint > 262143 || // Avoid corrupting a preceding backref by immediately following it with a literal digit
    escDigit && isDigitCharCode(codePoint)
  ) {
    return codePoint > 255 ? `\\u{${codePoint.toString(16).toUpperCase()}}` : `\\x${codePoint.toString(16).toUpperCase().padStart(2, "0")}`;
  }
  const escapeChars = inCharClass ? useFlagV ? CharClassEscapeCharsFlagV : CharClassEscapeChars : BaseEscapeChars;
  const char = cp(codePoint);
  return (escapeChars.has(char) ? "\\" : "") + char;
}
function getCodePointRangesFromChars(chars) {
  const codePoints = chars.map((char) => char.codePointAt(0)).sort((a, b3) => a - b3);
  const values = [];
  let start = null;
  for (let i2 = 0; i2 < codePoints.length; i2++) {
    if (codePoints[i2 + 1] === codePoints[i2] + 1) {
      start ??= codePoints[i2];
    } else if (start === null) {
      values.push(codePoints[i2]);
    } else {
      values.push([start, codePoints[i2]]);
      start = null;
    }
  }
  return values;
}
function getGroupPrefix(atomic2, flagMods, useFlagMods) {
  if (atomic2) {
    return ">";
  }
  let mods = "";
  if (flagMods && useFlagMods) {
    const { enable, disable } = flagMods;
    mods = (enable?.ignoreCase ? "i" : "") + (enable?.dotAll ? "s" : "") + (disable ? "-" : "") + (disable?.ignoreCase ? "i" : "") + (disable?.dotAll ? "s" : "");
  }
  return `${mods}:`;
}
function getQuantifierStr({ min, max, kind }) {
  let base;
  if (!min && max === 1) {
    base = "?";
  } else if (!min && max === Infinity) {
    base = "*";
  } else if (min === 1 && max === Infinity) {
    base = "+";
  } else if (min === max) {
    base = `{${min}}`;
  } else {
    base = `{${min},${max === Infinity ? "" : max}}`;
  }
  return base + {
    greedy: "",
    lazy: "?",
    possessive: "+"
  }[kind];
}
function isAnyGroup({ type }) {
  return type === s3.Group || type === s3.CapturingGroup || type === s3.LookaroundAssertion;
}
function isDigitCharCode(value) {
  return value > 47 && value < 58;
}
function isLiteralHyphen({ type, value }) {
  return type === s3.Character && value === 45;
}

// src/subclass.js
var EmulatedRegExp = class _EmulatedRegExp extends RegExp {
  /**
  @type {Map<number, {
    hidden?: true;
    transferTo?: number;
  }>}
  */
  #captureMap = /* @__PURE__ */ new Map();
  /**
  @type {RegExp | EmulatedRegExp | null}
  */
  #compiled = null;
  /**
  @type {string}
  */
  #pattern;
  /**
  @type {Map<number, string>?}
  */
  #nameMap = null;
  /**
  @type {string?}
  */
  #strategy = null;
  /**
  Can be used to serialize the instance.
  @type {EmulatedRegExpOptions}
  */
  rawOptions = {};
  // Override the getter with one that works with lazy-compiled regexes
  get source() {
    return this.#pattern || "(?:)";
  }
  /**
  @overload
  @param {string} pattern
  @param {string} [flags]
  @param {EmulatedRegExpOptions} [options]
  */
  /**
  @overload
  @param {EmulatedRegExp} pattern
  @param {string} [flags]
  */
  constructor(pattern, flags, options) {
    const lazyCompile = !!options?.lazyCompile;
    if (pattern instanceof RegExp) {
      if (options) {
        throw new Error("Cannot provide options when copying a regexp");
      }
      const re = pattern;
      super(re, flags);
      this.#pattern = re.source;
      if (re instanceof _EmulatedRegExp) {
        this.#captureMap = re.#captureMap;
        this.#nameMap = re.#nameMap;
        this.#strategy = re.#strategy;
        this.rawOptions = re.rawOptions;
      }
    } else {
      const opts = {
        hiddenCaptures: [],
        strategy: null,
        transfers: [],
        ...options
      };
      super(lazyCompile ? "" : pattern, flags);
      this.#pattern = pattern;
      this.#captureMap = createCaptureMap(opts.hiddenCaptures, opts.transfers);
      this.#strategy = opts.strategy;
      this.rawOptions = options ?? {};
    }
    if (!lazyCompile) {
      this.#compiled = this;
    }
  }
  /**
  Called internally by all String/RegExp methods that use regexes.
  @override
  @param {string} str
  @returns {RegExpExecArray?}
  */
  exec(str) {
    if (!this.#compiled) {
      const { lazyCompile, ...rest } = this.rawOptions;
      this.#compiled = new _EmulatedRegExp(this.#pattern, this.flags, rest);
    }
    const useLastIndex = this.global || this.sticky;
    const pos = this.lastIndex;
    if (this.#strategy === "clip_search" && useLastIndex && pos) {
      this.lastIndex = 0;
      const match = this.#execCore(str.slice(pos));
      if (match) {
        adjustMatchDetailsForOffset(match, pos, str, this.hasIndices);
        this.lastIndex += pos;
      }
      return match;
    }
    return this.#execCore(str);
  }
  /**
  Adds support for hidden and transfer captures.
  @param {string} str
  @returns
  */
  #execCore(str) {
    this.#compiled.lastIndex = this.lastIndex;
    const match = super.exec.call(this.#compiled, str);
    this.lastIndex = this.#compiled.lastIndex;
    if (!match || !this.#captureMap.size) {
      return match;
    }
    const matchCopy = [...match];
    match.length = 1;
    let indicesCopy;
    if (this.hasIndices) {
      indicesCopy = [...match.indices];
      match.indices.length = 1;
    }
    const mappedNums = [0];
    for (let i2 = 1; i2 < matchCopy.length; i2++) {
      const { hidden, transferTo } = this.#captureMap.get(i2) ?? {};
      if (hidden) {
        mappedNums.push(null);
      } else {
        mappedNums.push(match.length);
        match.push(matchCopy[i2]);
        if (this.hasIndices) {
          match.indices.push(indicesCopy[i2]);
        }
      }
      if (transferTo && matchCopy[i2] !== void 0) {
        const to = throwIfNot(mappedNums[transferTo]);
        match[to] = matchCopy[i2];
        if (this.hasIndices) {
          match.indices[to] = indicesCopy[i2];
        }
        if (match.groups) {
          if (!this.#nameMap) {
            this.#nameMap = createNameMap(this.source);
          }
          const name = this.#nameMap.get(transferTo);
          if (name) {
            match.groups[name] = matchCopy[i2];
            if (this.hasIndices) {
              match.indices.groups[name] = indicesCopy[i2];
            }
          }
        }
      }
    }
    return match;
  }
};
function adjustMatchDetailsForOffset(match, offset, input, hasIndices) {
  match.index += offset;
  match.input = input;
  if (hasIndices) {
    const indices = match.indices;
    for (let i2 = 0; i2 < indices.length; i2++) {
      const arr = indices[i2];
      if (arr) {
        indices[i2] = [arr[0] + offset, arr[1] + offset];
      }
    }
    const groupIndices = indices.groups;
    if (groupIndices) {
      Object.keys(groupIndices).forEach((key) => {
        const arr = groupIndices[key];
        if (arr) {
          groupIndices[key] = [arr[0] + offset, arr[1] + offset];
        }
      });
    }
  }
}
function createCaptureMap(hiddenCaptures, transfers) {
  const captureMap = /* @__PURE__ */ new Map();
  for (const num of hiddenCaptures) {
    captureMap.set(num, {
      hidden: true
    });
  }
  for (const [to, from] of transfers) {
    for (const num of from) {
      getOrInsert(captureMap, num, {}).transferTo = to;
    }
  }
  return captureMap;
}
function createNameMap(pattern) {
  const re = /(?<capture>\((?:\?<(?![=!])(?<name>[^>]+)>|(?!\?)))|\\?./gsu;
  const map = /* @__PURE__ */ new Map();
  let numCharClassesOpen = 0;
  let numCaptures = 0;
  let match;
  while (match = re.exec(pattern)) {
    const { 0: m, groups: { capture, name } } = match;
    if (m === "[") {
      numCharClassesOpen++;
    } else if (!numCharClassesOpen) {
      if (capture) {
        numCaptures++;
        if (name) {
          map.set(numCaptures, name);
        }
      }
    } else if (m === "]") {
      numCharClassesOpen--;
    }
  }
  return map;
}

// node_modules/.pnpm/regex@6.0.1/node_modules/regex/src/utils-internals.js
var noncapturingDelim = String.raw`\(\?(?:[:=!>A-Za-z\-]|<[=!]|\(DEFINE\))`;
function incrementIfAtLeast(arr, threshold) {
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (arr[i2] >= threshold) {
      arr[i2]++;
    }
  }
}
function spliceStr(str, pos, oldValue, newValue) {
  return str.slice(0, pos) + newValue + str.slice(pos + oldValue.length);
}

// node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js
var Context = Object.freeze({
  DEFAULT: "DEFAULT",
  CHAR_CLASS: "CHAR_CLASS"
});
function replaceUnescaped(expression, needle, replacement, context) {
  const re = new RegExp(String.raw`${needle}|(?<$skip>\[\^?|\\?.)`, "gsu");
  const negated = [false];
  let numCharClassesOpen = 0;
  let result = "";
  for (const match of expression.matchAll(re)) {
    const { 0: m, groups: { $skip } } = match;
    if (!$skip && (!context || context === Context.DEFAULT === !numCharClassesOpen)) {
      if (replacement instanceof Function) {
        result += replacement(match, {
          context: numCharClassesOpen ? Context.CHAR_CLASS : Context.DEFAULT,
          negated: negated[negated.length - 1]
        });
      } else {
        result += replacement;
      }
      continue;
    }
    if (m[0] === "[") {
      numCharClassesOpen++;
      negated.push(m[1] === "^");
    } else if (m === "]" && numCharClassesOpen) {
      numCharClassesOpen--;
      negated.pop();
    }
    result += m;
  }
  return result;
}
function forEachUnescaped(expression, needle, callback, context) {
  replaceUnescaped(expression, needle, callback, context);
}
function execUnescaped(expression, needle, pos = 0, context) {
  if (!new RegExp(needle, "su").test(expression)) {
    return null;
  }
  const re = new RegExp(`${needle}|(?<$skip>\\\\?.)`, "gsu");
  re.lastIndex = pos;
  let numCharClassesOpen = 0;
  let match;
  while (match = re.exec(expression)) {
    const { 0: m, groups: { $skip } } = match;
    if (!$skip && (!context || context === Context.DEFAULT === !numCharClassesOpen)) {
      return match;
    }
    if (m === "[") {
      numCharClassesOpen++;
    } else if (m === "]" && numCharClassesOpen) {
      numCharClassesOpen--;
    }
    if (re.lastIndex == match.index) {
      re.lastIndex++;
    }
  }
  return null;
}
function hasUnescaped(expression, needle, context) {
  return !!execUnescaped(expression, needle, 0, context);
}
function getGroupContents(expression, contentsStartPos) {
  const token2 = /\\?./gsu;
  token2.lastIndex = contentsStartPos;
  let contentsEndPos = expression.length;
  let numCharClassesOpen = 0;
  let numGroupsOpen = 1;
  let match;
  while (match = token2.exec(expression)) {
    const [m] = match;
    if (m === "[") {
      numCharClassesOpen++;
    } else if (!numCharClassesOpen) {
      if (m === "(") {
        numGroupsOpen++;
      } else if (m === ")") {
        numGroupsOpen--;
        if (!numGroupsOpen) {
          contentsEndPos = match.index;
          break;
        }
      }
    } else if (m === "]") {
      numCharClassesOpen--;
    }
  }
  return expression.slice(contentsStartPos, contentsEndPos);
}

// node_modules/.pnpm/regex@6.0.1/node_modules/regex/src/atomic.js
var atomicPluginToken = new RegExp(String.raw`(?<noncapturingStart>${noncapturingDelim})|(?<capturingStart>\((?:\?<[^>]+>)?)|\\?.`, "gsu");
function atomic(expression, data) {
  const hiddenCaptures = data?.hiddenCaptures ?? [];
  let captureTransfers = data?.captureTransfers ?? /* @__PURE__ */ new Map();
  if (!/\(\?>/.test(expression)) {
    return {
      pattern: expression,
      captureTransfers,
      hiddenCaptures
    };
  }
  const aGDelim = "(?>";
  const emulatedAGDelim = "(?:(?=(";
  const captureNumMap = [0];
  const addedHiddenCaptures = [];
  let numCapturesBeforeAG = 0;
  let numAGs = 0;
  let aGPos = NaN;
  let hasProcessedAG;
  do {
    hasProcessedAG = false;
    let numCharClassesOpen = 0;
    let numGroupsOpenInAG = 0;
    let inAG = false;
    let match;
    atomicPluginToken.lastIndex = Number.isNaN(aGPos) ? 0 : aGPos + emulatedAGDelim.length;
    while (match = atomicPluginToken.exec(expression)) {
      const { 0: m, index, groups: { capturingStart, noncapturingStart } } = match;
      if (m === "[") {
        numCharClassesOpen++;
      } else if (!numCharClassesOpen) {
        if (m === aGDelim && !inAG) {
          aGPos = index;
          inAG = true;
        } else if (inAG && noncapturingStart) {
          numGroupsOpenInAG++;
        } else if (capturingStart) {
          if (inAG) {
            numGroupsOpenInAG++;
          } else {
            numCapturesBeforeAG++;
            captureNumMap.push(numCapturesBeforeAG + numAGs);
          }
        } else if (m === ")" && inAG) {
          if (!numGroupsOpenInAG) {
            numAGs++;
            const addedCaptureNum = numCapturesBeforeAG + numAGs;
            expression = `${expression.slice(0, aGPos)}${emulatedAGDelim}${expression.slice(aGPos + aGDelim.length, index)}))<$$${addedCaptureNum}>)${expression.slice(index + 1)}`;
            hasProcessedAG = true;
            addedHiddenCaptures.push(addedCaptureNum);
            incrementIfAtLeast(hiddenCaptures, addedCaptureNum);
            if (captureTransfers.size) {
              const newCaptureTransfers = /* @__PURE__ */ new Map();
              captureTransfers.forEach((from, to) => {
                newCaptureTransfers.set(
                  to >= addedCaptureNum ? to + 1 : to,
                  from.map((f2) => f2 >= addedCaptureNum ? f2 + 1 : f2)
                );
              });
              captureTransfers = newCaptureTransfers;
            }
            break;
          }
          numGroupsOpenInAG--;
        }
      } else if (m === "]") {
        numCharClassesOpen--;
      }
    }
  } while (hasProcessedAG);
  hiddenCaptures.push(...addedHiddenCaptures);
  expression = replaceUnescaped(
    expression,
    String.raw`\\(?<backrefNum>[1-9]\d*)|<\$\$(?<wrappedBackrefNum>\d+)>`,
    ({ 0: m, groups: { backrefNum, wrappedBackrefNum } }) => {
      if (backrefNum) {
        const bNum = +backrefNum;
        if (bNum > captureNumMap.length - 1) {
          throw new Error(`Backref "${m}" greater than number of captures`);
        }
        return `\\${captureNumMap[bNum]}`;
      }
      return `\\${wrappedBackrefNum}`;
    },
    Context.DEFAULT
  );
  return {
    pattern: expression,
    captureTransfers,
    hiddenCaptures
  };
}
var baseQuantifier = String.raw`(?:[?*+]|\{\d+(?:,\d*)?\})`;
var possessivePluginToken = new RegExp(String.raw`
\\(?: \d+
  | c[A-Za-z]
  | [gk]<[^>]+>
  | [pPu]\{[^\}]+\}
  | u[A-Fa-f\d]{4}
  | x[A-Fa-f\d]{2}
  )
| \((?: \? (?: [:=!>]
  | <(?:[=!]|[^>]+>)
  | [A-Za-z\-]+:
  | \(DEFINE\)
  ))?
| (?<qBase>${baseQuantifier})(?<qMod>[?+]?)(?<invalidQ>[?*+\{]?)
| \\?.
`.replace(/\s+/g, ""), "gsu");
function possessive(expression) {
  if (!new RegExp(`${baseQuantifier}\\+`).test(expression)) {
    return {
      pattern: expression
    };
  }
  const openGroupIndices = [];
  let lastGroupIndex = null;
  let lastCharClassIndex = null;
  let lastToken = "";
  let numCharClassesOpen = 0;
  let match;
  possessivePluginToken.lastIndex = 0;
  while (match = possessivePluginToken.exec(expression)) {
    const { 0: m, index, groups: { qBase, qMod, invalidQ } } = match;
    if (m === "[") {
      if (!numCharClassesOpen) {
        lastCharClassIndex = index;
      }
      numCharClassesOpen++;
    } else if (m === "]") {
      if (numCharClassesOpen) {
        numCharClassesOpen--;
      } else {
        lastCharClassIndex = null;
      }
    } else if (!numCharClassesOpen) {
      if (qMod === "+" && lastToken && !lastToken.startsWith("(")) {
        if (invalidQ) {
          throw new Error(`Invalid quantifier "${m}"`);
        }
        let charsAdded = -1;
        if (/^\{\d+\}$/.test(qBase)) {
          expression = spliceStr(expression, index + qBase.length, qMod, "");
        } else {
          if (lastToken === ")" || lastToken === "]") {
            const nodeIndex = lastToken === ")" ? lastGroupIndex : lastCharClassIndex;
            if (nodeIndex === null) {
              throw new Error(`Invalid unmatched "${lastToken}"`);
            }
            expression = `${expression.slice(0, nodeIndex)}(?>${expression.slice(nodeIndex, index)}${qBase})${expression.slice(index + m.length)}`;
          } else {
            expression = `${expression.slice(0, index - lastToken.length)}(?>${lastToken}${qBase})${expression.slice(index + m.length)}`;
          }
          charsAdded += 4;
        }
        possessivePluginToken.lastIndex += charsAdded;
      } else if (m[0] === "(") {
        openGroupIndices.push(index);
      } else if (m === ")") {
        lastGroupIndex = openGroupIndices.length ? openGroupIndices.pop() : null;
      }
    }
    lastToken = m;
  }
  return {
    pattern: expression
  };
}

// node_modules/.pnpm/regex-recursion@6.0.2/node_modules/regex-recursion/src/index.js
var r3 = String.raw;
var gRToken = r3`\\g<(?<gRNameOrNum>[^>&]+)&R=(?<gRDepth>[^>]+)>`;
var recursiveToken = r3`\(\?R=(?<rDepth>[^\)]+)\)|${gRToken}`;
var namedCaptureDelim = r3`\(\?<(?![=!])(?<captureName>[^>]+)>`;
var captureDelim = r3`${namedCaptureDelim}|(?<unnamed>\()(?!\?)`;
var token = new RegExp(r3`${namedCaptureDelim}|${recursiveToken}|\(\?|\\?.`, "gsu");
var overlappingRecursionMsg = "Cannot use multiple overlapping recursions";
function recursion(pattern, data) {
  const { hiddenCaptures, mode } = {
    hiddenCaptures: [],
    mode: "plugin",
    ...data
  };
  let captureTransfers = data?.captureTransfers ?? /* @__PURE__ */ new Map();
  if (!new RegExp(recursiveToken, "su").test(pattern)) {
    return {
      pattern,
      captureTransfers,
      hiddenCaptures
    };
  }
  if (mode === "plugin" && hasUnescaped(pattern, r3`\(\?\(DEFINE\)`, Context.DEFAULT)) {
    throw new Error("DEFINE groups cannot be used with recursion");
  }
  const addedHiddenCaptures = [];
  const hasNumberedBackref = hasUnescaped(pattern, r3`\\[1-9]`, Context.DEFAULT);
  const groupContentsStartPos = /* @__PURE__ */ new Map();
  const openGroups = [];
  let hasRecursed = false;
  let numCharClassesOpen = 0;
  let numCapturesPassed = 0;
  let match;
  token.lastIndex = 0;
  while (match = token.exec(pattern)) {
    const { 0: m, groups: { captureName, rDepth, gRNameOrNum, gRDepth } } = match;
    if (m === "[") {
      numCharClassesOpen++;
    } else if (!numCharClassesOpen) {
      if (rDepth) {
        assertMaxInBounds(rDepth);
        if (hasRecursed) {
          throw new Error(overlappingRecursionMsg);
        }
        if (hasNumberedBackref) {
          throw new Error(
            // When used in `external` mode by transpilers other than Regex+, backrefs might have
            // gone through conversion from named to numbered, so avoid a misleading error
            `${mode === "external" ? "Backrefs" : "Numbered backrefs"} cannot be used with global recursion`
          );
        }
        const left = pattern.slice(0, match.index);
        const right = pattern.slice(token.lastIndex);
        if (hasUnescaped(right, recursiveToken, Context.DEFAULT)) {
          throw new Error(overlappingRecursionMsg);
        }
        const reps = +rDepth - 1;
        pattern = makeRecursive(
          left,
          right,
          reps,
          false,
          hiddenCaptures,
          addedHiddenCaptures,
          numCapturesPassed
        );
        captureTransfers = mapCaptureTransfers(
          captureTransfers,
          left,
          reps,
          addedHiddenCaptures.length,
          0,
          numCapturesPassed
        );
        break;
      } else if (gRNameOrNum) {
        assertMaxInBounds(gRDepth);
        let isWithinReffedGroup = false;
        for (const g2 of openGroups) {
          if (g2.name === gRNameOrNum || g2.num === +gRNameOrNum) {
            isWithinReffedGroup = true;
            if (g2.hasRecursedWithin) {
              throw new Error(overlappingRecursionMsg);
            }
            break;
          }
        }
        if (!isWithinReffedGroup) {
          throw new Error(r3`Recursive \g cannot be used outside the referenced group "${mode === "external" ? gRNameOrNum : r3`\g<${gRNameOrNum}&R=${gRDepth}>`}"`);
        }
        const startPos = groupContentsStartPos.get(gRNameOrNum);
        const groupContents = getGroupContents(pattern, startPos);
        if (hasNumberedBackref && hasUnescaped(groupContents, r3`${namedCaptureDelim}|\((?!\?)`, Context.DEFAULT)) {
          throw new Error(
            // When used in `external` mode by transpilers other than Regex+, backrefs might have
            // gone through conversion from named to numbered, so avoid a misleading error
            `${mode === "external" ? "Backrefs" : "Numbered backrefs"} cannot be used with recursion of capturing groups`
          );
        }
        const groupContentsLeft = pattern.slice(startPos, match.index);
        const groupContentsRight = groupContents.slice(groupContentsLeft.length + m.length);
        const numAddedHiddenCapturesPreExpansion = addedHiddenCaptures.length;
        const reps = +gRDepth - 1;
        const expansion = makeRecursive(
          groupContentsLeft,
          groupContentsRight,
          reps,
          true,
          hiddenCaptures,
          addedHiddenCaptures,
          numCapturesPassed
        );
        captureTransfers = mapCaptureTransfers(
          captureTransfers,
          groupContentsLeft,
          reps,
          addedHiddenCaptures.length - numAddedHiddenCapturesPreExpansion,
          numAddedHiddenCapturesPreExpansion,
          numCapturesPassed
        );
        const pre = pattern.slice(0, startPos);
        const post = pattern.slice(startPos + groupContents.length);
        pattern = `${pre}${expansion}${post}`;
        token.lastIndex += expansion.length - m.length - groupContentsLeft.length - groupContentsRight.length;
        openGroups.forEach((g2) => g2.hasRecursedWithin = true);
        hasRecursed = true;
      } else if (captureName) {
        numCapturesPassed++;
        groupContentsStartPos.set(String(numCapturesPassed), token.lastIndex);
        groupContentsStartPos.set(captureName, token.lastIndex);
        openGroups.push({
          num: numCapturesPassed,
          name: captureName
        });
      } else if (m[0] === "(") {
        const isUnnamedCapture = m === "(";
        if (isUnnamedCapture) {
          numCapturesPassed++;
          groupContentsStartPos.set(String(numCapturesPassed), token.lastIndex);
        }
        openGroups.push(isUnnamedCapture ? { num: numCapturesPassed } : {});
      } else if (m === ")") {
        openGroups.pop();
      }
    } else if (m === "]") {
      numCharClassesOpen--;
    }
  }
  hiddenCaptures.push(...addedHiddenCaptures);
  return {
    pattern,
    captureTransfers,
    hiddenCaptures
  };
}
function assertMaxInBounds(max) {
  const errMsg = `Max depth must be integer between 2 and 100; used ${max}`;
  if (!/^[1-9]\d*$/.test(max)) {
    throw new Error(errMsg);
  }
  max = +max;
  if (max < 2 || max > 100) {
    throw new Error(errMsg);
  }
}
function makeRecursive(left, right, reps, isSubpattern, hiddenCaptures, addedHiddenCaptures, numCapturesPassed) {
  const namesInRecursed = /* @__PURE__ */ new Set();
  if (isSubpattern) {
    forEachUnescaped(left + right, namedCaptureDelim, ({ groups: { captureName } }) => {
      namesInRecursed.add(captureName);
    }, Context.DEFAULT);
  }
  const rest = [
    reps,
    isSubpattern ? namesInRecursed : null,
    hiddenCaptures,
    addedHiddenCaptures,
    numCapturesPassed
  ];
  return `${left}${repeatWithDepth(`(?:${left}`, "forward", ...rest)}(?:)${repeatWithDepth(`${right})`, "backward", ...rest)}${right}`;
}
function repeatWithDepth(pattern, direction, reps, namesInRecursed, hiddenCaptures, addedHiddenCaptures, numCapturesPassed) {
  const startNum = 2;
  const getDepthNum = (i2) => direction === "forward" ? i2 + startNum : reps - i2 + startNum - 1;
  let result = "";
  for (let i2 = 0; i2 < reps; i2++) {
    const depthNum = getDepthNum(i2);
    result += replaceUnescaped(
      pattern,
      r3`${captureDelim}|\\k<(?<backref>[^>]+)>`,
      ({ 0: m, groups: { captureName, unnamed, backref } }) => {
        if (backref && namesInRecursed && !namesInRecursed.has(backref)) {
          return m;
        }
        const suffix = `_$${depthNum}`;
        if (unnamed || captureName) {
          const addedCaptureNum = numCapturesPassed + addedHiddenCaptures.length + 1;
          addedHiddenCaptures.push(addedCaptureNum);
          incrementIfAtLeast2(hiddenCaptures, addedCaptureNum);
          return unnamed ? m : `(?<${captureName}${suffix}>`;
        }
        return r3`\k<${backref}${suffix}>`;
      },
      Context.DEFAULT
    );
  }
  return result;
}
function incrementIfAtLeast2(arr, threshold) {
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (arr[i2] >= threshold) {
      arr[i2]++;
    }
  }
}
function mapCaptureTransfers(captureTransfers, left, reps, numCapturesAddedInExpansion, numAddedHiddenCapturesPreExpansion, numCapturesPassed) {
  if (captureTransfers.size && numCapturesAddedInExpansion) {
    let numCapturesInLeft = 0;
    forEachUnescaped(left, captureDelim, () => numCapturesInLeft++, Context.DEFAULT);
    const recursionDelimCaptureNum = numCapturesPassed - numCapturesInLeft + numAddedHiddenCapturesPreExpansion;
    const newCaptureTransfers = /* @__PURE__ */ new Map();
    captureTransfers.forEach((from, to) => {
      const numCapturesInRight = (numCapturesAddedInExpansion - numCapturesInLeft * reps) / reps;
      const numCapturesAddedInLeft = numCapturesInLeft * reps;
      const newTo = to > recursionDelimCaptureNum + numCapturesInLeft ? to + numCapturesAddedInExpansion : to;
      const newFrom = [];
      for (const f2 of from) {
        if (f2 <= recursionDelimCaptureNum) {
          newFrom.push(f2);
        } else if (f2 > recursionDelimCaptureNum + numCapturesInLeft + numCapturesInRight) {
          newFrom.push(f2 + numCapturesAddedInExpansion);
        } else if (f2 <= recursionDelimCaptureNum + numCapturesInLeft) {
          for (let i2 = 0; i2 <= reps; i2++) {
            newFrom.push(f2 + numCapturesInLeft * i2);
          }
        } else {
          for (let i2 = 0; i2 <= reps; i2++) {
            newFrom.push(f2 + numCapturesAddedInLeft + numCapturesInRight * i2);
          }
        }
      }
      newCaptureTransfers.set(newTo, newFrom);
    });
    return newCaptureTransfers;
  }
  return captureTransfers;
}

// src/index.js
function toRegExp(pattern, options) {
  const d = toRegExpDetails(pattern, options);
  if (d.options) {
    return new EmulatedRegExp(d.pattern, d.flags, d.options);
  }
  return new RegExp(d.pattern, d.flags);
}
function toRegExpDetails(pattern, options) {
  const opts = getOptions(options);
  const onigurumaAst = ne(pattern, {
    flags: opts.flags,
    normalizeUnknownPropertyNames: true,
    rules: {
      captureGroup: opts.rules.captureGroup,
      singleline: opts.rules.singleline
    },
    skipBackrefValidation: opts.rules.allowOrphanBackrefs,
    unicodePropertyMap: JsUnicodePropertyMap
  });
  const regexPlusAst = transform(onigurumaAst, {
    accuracy: opts.accuracy,
    asciiWordBoundaries: opts.rules.asciiWordBoundaries,
    avoidSubclass: opts.avoidSubclass,
    bestEffortTarget: opts.target
  });
  const generated = generate(regexPlusAst, opts);
  const recursionResult = recursion(generated.pattern, {
    captureTransfers: generated._captureTransfers,
    hiddenCaptures: generated._hiddenCaptures,
    mode: "external"
  });
  const possessiveResult = possessive(recursionResult.pattern);
  const atomicResult = atomic(possessiveResult.pattern, {
    captureTransfers: recursionResult.captureTransfers,
    hiddenCaptures: recursionResult.hiddenCaptures
  });
  const details = {
    pattern: atomicResult.pattern,
    flags: `${opts.hasIndices ? "d" : ""}${opts.global ? "g" : ""}${generated.flags}${generated.options.disable.v ? "u" : "v"}`
  };
  if (opts.avoidSubclass) {
    if (opts.lazyCompileLength !== Infinity) {
      throw new Error("Lazy compilation requires subclass");
    }
  } else {
    const hiddenCaptures = atomicResult.hiddenCaptures.sort((a, b3) => a - b3);
    const transfers = Array.from(atomicResult.captureTransfers);
    const strategy = regexPlusAst._strategy;
    const lazyCompile = details.pattern.length >= opts.lazyCompileLength;
    if (hiddenCaptures.length || transfers.length || strategy || lazyCompile) {
      details.options = {
        ...hiddenCaptures.length && { hiddenCaptures },
        ...transfers.length && { transfers },
        ...strategy && { strategy },
        ...lazyCompile && { lazyCompile }
      };
    }
  }
  return details;
}
//# sourceMappingURL=index.js.map
