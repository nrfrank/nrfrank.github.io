"use strict";import{NodeTypes as t}from"../parser/parse.js";import{throwIfNot as v}from"../utils.js";function T(A,C,p=null){function x(e,i){for(let r=0;r<e.length;r++){const a=l(e[r],i,r,e);r=Math.max(-1,r+a)}}function l(e,i=null,r=null,a=null){const f="Container expected";let c=0,n=!1;const u={node:e,parent:i,key:r,container:a,root:A,remove(){v(a,f).splice(Math.max(0,r+c),1),c--,n=!0},removeAllNextSiblings(){return v(a,f).splice(r+1)},removeAllPrevSiblings(){const s=r+c;return c-=s,v(a,f).splice(0,Math.max(0,s))},replaceWith(s,g={}){const b=!!g.traverse;a?a[Math.max(0,r+c)]=s:i[r]=s,b&&l(s,i,r,a),n=!0},replaceWithMultiple(s,g={}){const b=!!g.traverse;if(v(a,f).splice(Math.max(0,r+c),1,...s),c+=s.length-1,b){let S=0;for(let o=0;o<s.length;o++)S+=l(s[o],i,r+o+S,a)}n=!0},skip(){n=!0}},h=C["*"],m=C[e.type],k=typeof h=="function"?h:h?.enter,M=typeof m=="function"?m:m?.enter;if(k?.(u,p),M?.(u,p),!n)switch(e.type){case t.Regex:l(e.pattern,e,"pattern"),l(e.flags,e,"flags");break;case t.Alternative:case t.CharacterClass:x(e.elements,e);break;case t.Assertion:case t.Backreference:case t.Character:case t.CharacterSet:case t.Directive:case t.Flags:case t.Recursion:case t.Subroutine:break;case t.AbsentFunction:case t.CapturingGroup:case t.Group:case t.Pattern:x(e.alternatives,e);break;case t.CharacterClassRange:l(e.min,e,"min"),l(e.max,e,"max");break;case t.LookaroundAssertion:x(e.alternatives,e);break;case t.Quantifier:l(e.element,e,"element");break;default:throw new Error(`Unexpected node type "${e.type}"`)}return h?.exit?.(u,p),m?.exit?.(u,p),c}l(A)}export{T as traverse};
//# sourceMappingURL=traverse.js.map
