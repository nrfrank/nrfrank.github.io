"use strict";import{TokenCharacterSetKinds as g,TokenDirectiveKinds as X,TokenGroupKinds as w,tokenize as j,TokenQuantifierKinds as ee,TokenTypes as l}from"../tokenizer/tokenize.js";import{getOrInsert as re,PosixClassNames as U,r as v,throwIfNot as C}from"../utils.js";const s={AbsentFunction:"AbsentFunction",Alternative:"Alternative",Assertion:"Assertion",Backreference:"Backreference",CapturingGroup:"CapturingGroup",Character:"Character",CharacterClass:"CharacterClass",CharacterClassRange:"CharacterClassRange",CharacterSet:"CharacterSet",Directive:"Directive",Flags:"Flags",Group:"Group",LookaroundAssertion:"LookaroundAssertion",Pattern:"Pattern",Quantifier:"Quantifier",Regex:"Regex",Subroutine:"Subroutine",Recursion:"Recursion"},F={repeater:"repeater"},f={grapheme_boundary:"grapheme_boundary",line_end:"line_end",line_start:"line_start",search_start:"search_start",string_end:"string_end",string_end_newline:"string_end_newline",string_start:"string_start",word_boundary:"word_boundary"},L={union:"union",intersection:"intersection"},A=g,E=X,_=ee,b={lookahead:"lookahead",lookbehind:"lookbehind"};function ne(e,r={}){const n={flags:"",normalizeUnknownPropertyNames:!1,skipBackrefValidation:!1,skipLookbehindValidation:!1,skipPropertyNameValidation:!1,unicodePropertyMap:null,...r,rules:{captureGroup:!1,singleline:!1,...r.rules}},a=j(e,{flags:n.flags,rules:{captureGroup:n.rules.captureGroup,singleline:n.rules.singleline}}),t={capturingGroups:[],current:0,hasNumberedRef:!1,namedGroupsByName:new Map,normalizeUnknownPropertyNames:n.normalizeUnknownPropertyNames,parent:null,skipBackrefValidation:n.skipBackrefValidation,skipLookbehindValidation:n.skipLookbehindValidation,skipPropertyNameValidation:n.skipPropertyNameValidation,subroutines:[],token:null,tokens:a.tokens,unicodePropertyMap:n.unicodePropertyMap,walk:o};function o(p,m){const d=a.tokens[t.current];switch(t.parent=p,t.token=d,t.current++,d.type){case l.Alternator:return k();case l.Assertion:return le(d);case l.Backreference:return te(t);case l.Character:return I(d.value,{useLastValid:!!m.isCheckingRangeEnd});case l.CharacterClassHyphen:return ae(t,m);case l.CharacterClassOpen:return oe(t,m);case l.CharacterSet:return se(t);case l.Directive:return K(C(E[d.kind],`Unexpected directive kind "${d.kind}"`),{flags:d.flags});case l.GroupOpen:return ie(t,m);case l.Quantifier:return ue(t);case l.Subroutine:return ce(t);default:throw new Error(`Unexpected token type "${d.type}"`)}}const i=q(D(),O(a.flags));let c=i.pattern.alternatives[0];for(;t.current<a.tokens.length;){const p=o(c,{});p.type===s.Alternative?(i.pattern.alternatives.push(p),c=p):c.elements.push(p)}const{capturingGroups:u,hasNumberedRef:h,namedGroupsByName:y,subroutines:N}=t;if(h&&y.size&&!n.rules.captureGroup)throw new Error("Numbered backref/subroutine not allowed when using named capture");for(const{ref:p}of N)if(typeof p=="number"){if(p>u.length)throw new Error("Subroutine uses a group number that's not defined")}else if(y.has(p)){if(y.get(p).length>1)throw new Error(v`Subroutine uses a duplicate group name "\g<${p}>"`)}else throw new Error(v`Subroutine uses a group name that's not defined "\g<${p}>"`);return i}function te(e){const{raw:r}=e.token,n=/^\\k[<']/.test(r),a=n?r.slice(3,-1):r.slice(1),t=(o,i=!1)=>{const c=e.capturingGroups.length;let u=!1;if(o>c)if(e.skipBackrefValidation)u=!0;else throw new Error(`Not enough capturing groups defined to the left "${r}"`);return e.hasNumberedRef=!0,P(i?c+1-o:o,{orphan:u})};if(n){const o=/^(?<sign>-?)0*(?<num>[1-9]\d*)$/.exec(a);if(o)return t(+o.groups.num,!!o.groups.sign);if(/[-+]/.test(a))throw new Error(`Invalid backref name "${r}"`);if(!e.namedGroupsByName.has(a))throw new Error(`Group name not defined to the left "${r}"`);return P(a)}return t(+a)}function ae(e,r){const{parent:n,tokens:a,walk:t}=e,o=n.elements.at(-1),i=a[e.current];if(!r.isCheckingRangeEnd&&o&&o.type!==s.CharacterClass&&o.type!==s.CharacterClassRange&&i&&i.type!==l.CharacterClassOpen&&i.type!==l.CharacterClassClose&&i.type!==l.CharacterClassIntersector){const c=t(n,{...r,isCheckingRangeEnd:!0});if(o.type===s.Character&&c.type===s.Character)return n.elements.pop(),z(o,c);throw new Error("Invalid character class range")}return I(45)}function oe(e,r){const{token:n,tokens:a,walk:t}=e,o=a[e.current],i=[G()];let c=J(o);for(;c.type!==l.CharacterClassClose;){if(c.type===l.CharacterClassIntersector)i.push(G()),e.current++;else{const h=i.at(-1);h.elements.push(t(h,r))}c=J(a[e.current],o)}const u=G({negate:n.negate});return i.length===1?u.elements=i[0].elements:(u.kind=L.intersection,u.elements=i.map(h=>h.elements.length===1?h.elements[0]:h)),e.current++,u}function se({token:e,normalizeUnknownPropertyNames:r,skipPropertyNameValidation:n,unicodePropertyMap:a}){let{kind:t,negate:o,value:i}=e;if(t===g.property){const c=$(i);if(U.has(c)&&!a?.has(c))t=g.posix,i=c;else return Y(i,{negate:o,normalizeUnknownPropertyNames:r,skipPropertyNameValidation:n,unicodePropertyMap:a})}return t===g.posix?M(i,{negate:o}):T(t,{negate:o})}function ie(e,r){const{token:n,tokens:a,capturingGroups:t,namedGroupsByName:o,skipLookbehindValidation:i,walk:c}=e;let u=pe(n);const h=u.type===s.AbsentFunction,y=u.kind===b.lookbehind,N=y&&u.negate;if(u.type===s.CapturingGroup&&(t.push(u),u.name&&re(o,u.name,[]).push(u)),h&&r.isInAbsentFunction)throw new Error("Nested absent function not supported by Oniguruma");let p=W(a[e.current]);for(;p.type!==l.GroupClose;){if(p.type===l.Alternator)u.alternatives.push(k()),e.current++;else{const m=u.alternatives.at(-1),d=c(m,{...r,isInAbsentFunction:r.isInAbsentFunction||h,isInLookbehind:r.isInLookbehind||y,isInNegLookbehind:r.isInNegLookbehind||N});if(m.elements.push(d),(y||r.isInLookbehind)&&!i){const R="Lookbehind includes a pattern not allowed by Oniguruma";if(N||r.isInNegLookbehind){if(d.kind===b.lookahead||d.type===s.CapturingGroup)throw new Error(R)}else if(d.kind===b.lookahead||d.kind===b.lookbehind&&d.negate)throw new Error(R)}}p=W(a[e.current])}return e.current++,u}function ue({token:e,parent:r}){const{min:n,max:a,kind:t}=e,o=r.elements.at(-1);if(!o||o.type===s.Assertion||o.type===s.Directive||o.type===s.LookaroundAssertion)throw new Error("Quantifier requires a repeatable token");const i=Z(o,n,a,C(_[t],`Unexpected quantifier kind "${t}"`));return r.elements.pop(),i}function ce(e){const{token:r,capturingGroups:n,subroutines:a}=e;let t=r.raw.slice(3,-1);const o=/^(?<sign>[-+]?)0*(?<num>[1-9]\d*)$/.exec(t);if(o){const c=+o.groups.num,u=n.length;if(e.hasNumberedRef=!0,t={"":c,"+":u+c,"-":u+1-c}[o.groups.sign],t<1)throw new Error("Invalid subroutine number")}else t==="0"&&(t=0);const i=H(t);return a.push(i),i}function B(e){if(e!==F.repeater)throw new Error(`Unexpected absent function kind "${e}"`);return{type:s.AbsentFunction,kind:e,alternatives:[k()]}}function k(){return{type:s.Alternative,elements:[]}}function V(e,r){const n={type:s.Assertion,kind:e};return(e===f.word_boundary||e===f.grapheme_boundary)&&(n.negate=!!r?.negate),n}function le({kind:e}){return V(C({"^":f.line_start,$:f.line_end,"\\A":f.string_start,"\\b":f.word_boundary,"\\B":f.word_boundary,"\\G":f.search_start,"\\y":f.grapheme_boundary,"\\Y":f.grapheme_boundary,"\\z":f.string_end,"\\Z":f.string_end_newline}[e],`Unexpected assertion kind "${e}"`),{negate:e===v`\B`||e===v`\Y`})}function P(e,r){const n=!!r?.orphan;return{type:s.Backreference,ref:e,...n&&{orphan:n}}}function pe({flags:e,kind:r,name:n,negate:a,number:t}){switch(r){case w.absent_repeater:return B(F.repeater);case w.atomic:return S({atomic:!0});case w.capturing:return x(t,n);case w.group:return S({flags:e});case w.lookahead:case w.lookbehind:return Q({behind:r===w.lookbehind,negate:a});default:throw new Error(`Unexpected group kind "${r}"`)}}function x(e,r){const n=r!==void 0;if(n&&!de(r))throw new Error(`Group name "${r}" invalid in Oniguruma`);return{type:s.CapturingGroup,number:e,...n&&{name:r},alternatives:[k()]}}function I(e,r){const n={useLastValid:!1,...r};if(e>1114111){const a=e.toString(16);if(n.useLastValid)e=1114111;else throw e>1310719?new Error(`Invalid code point out of range "\\x{${a}}"`):new Error(`Invalid code point out of range in JS "\\x{${a}}"`)}return{type:s.Character,value:e}}function G(e){const r={kind:L.union,negate:!1,...e};return{type:s.CharacterClass,kind:r.kind,negate:r.negate,elements:[]}}function z(e,r){if(r.value<e.value)throw new Error("Character class range out of order");return{type:s.CharacterClassRange,min:e,max:r}}function T(e,r){const n=!!r?.negate,a={type:s.CharacterSet,kind:C(A[e],`Unexpected character set kind "${e}"`)};return(e===g.digit||e===g.hex||e===g.newline||e===g.space||e===g.word)&&(a.negate=n),(e===g.grapheme||e===g.newline&&!n)&&(a.variableLength=!0),a}function K(e,r){const n={type:s.Directive,kind:e};return e===E.flags&&(n.flags=r.flags),n}function O(e){return{type:s.Flags,...e}}function S(e){const r=e?.atomic,n=e?.flags;return{type:s.Group,...r&&{atomic:r},...n&&{flags:n},alternatives:[k()]}}function Q(e){const r={behind:!1,negate:!1,...e};return{type:s.LookaroundAssertion,kind:r.behind?b.lookbehind:b.lookahead,negate:r.negate,alternatives:[k()]}}function D(){return{type:s.Pattern,alternatives:[k()]}}function M(e,r){const n=!!r?.negate;if(!U.has(e))throw new Error(`Invalid POSIX class "${e}"`);return{type:s.CharacterSet,kind:A.posix,value:e,negate:n}}function Z(e,r,n,a=_.greedy){const t={type:s.Quantifier,min:r,max:n,kind:a,element:e};return n<r?{...t,min:n,max:r,kind:_.possessive}:t}function q(e,r){return{type:s.Regex,pattern:e,flags:r}}function H(e){return{type:s.Subroutine,ref:e}}function Y(e,r){const n={negate:!1,normalizeUnknownPropertyNames:!1,skipPropertyNameValidation:!1,unicodePropertyMap:null,...r};let a=n.unicodePropertyMap?.get($(e));if(!a){if(n.normalizeUnknownPropertyNames)a=fe(e);else if(n.unicodePropertyMap&&!n.skipPropertyNameValidation)throw new Error(v`Invalid Unicode property "\p{${e}}"`)}return{type:s.CharacterSet,kind:A.property,value:a??e,negate:n.negate}}function de(e){return/^[\p{Alpha}\p{Pc}][^)]*$/u.test(e)}function fe(e){return e.trim().replace(/[- _]+/g,"_").replace(/[A-Z][a-z]+(?=[A-Z])/g,"$&_").replace(/[A-Za-z]+/g,r=>r[0].toUpperCase()+r.slice(1).toLowerCase())}function $(e){return e.replace(/[- _]+/g,"").toLowerCase()}function J(e,r){return C(e,`${r?.value===93?"Empty":"Unclosed"} character class`)}function W(e){return C(e,"Unclosed group")}export{B as createAbsentFunction,k as createAlternative,V as createAssertion,P as createBackreference,x as createCapturingGroup,I as createCharacter,G as createCharacterClass,z as createCharacterClassRange,T as createCharacterSet,K as createDirective,O as createFlags,S as createGroup,Q as createLookaroundAssertion,D as createPattern,M as createPosixClass,Z as createQuantifier,q as createRegex,H as createSubroutine,Y as createUnicodeProperty,F as NodeAbsentFunctionKinds,f as NodeAssertionKinds,L as NodeCharacterClassKinds,A as NodeCharacterSetKinds,E as NodeDirectiveKinds,b as NodeLookaroundAssertionKinds,s as NodeTypes,_ as NodeQuantifierKinds,ne as parse,$ as slug};
//# sourceMappingURL=parse.js.map
