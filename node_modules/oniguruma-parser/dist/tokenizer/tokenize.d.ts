export type RegexFlags = {
    ignoreCase: boolean;
    dotAll: boolean;
    extended: boolean;
    digitIsAscii: boolean;
    posixIsAscii: boolean;
    spaceIsAscii: boolean;
    wordIsAscii: boolean;
};
export type Token = {
    type: "Alternator" | "Assertion" | "Backreference" | "Character" | "CharacterClassClose" | "CharacterClassHyphen" | "CharacterClassIntersector" | "CharacterClassOpen" | "CharacterSet" | "Directive" | "GroupClose" | "GroupOpen" | "Subroutine" | "Quantifier" | "EscapedNumber";
    raw: string;
    [key: string]: string | number | boolean;
};
export type TokenizerResult = {
    tokens: Array<Token>;
    flags: RegexFlags;
};
export type FlagGroupSwitches = {
    ignoreCase?: true;
    dotAll?: true;
    extended?: true;
};
/**
@typedef {{
  ignoreCase: boolean;
  dotAll: boolean;
  extended: boolean;
  digitIsAscii: boolean;
  posixIsAscii: boolean;
  spaceIsAscii: boolean;
  wordIsAscii: boolean;
}} RegexFlags
@typedef {{
  type: keyof TokenTypes;
  raw: string;
  [key: string]: string | number | boolean;
}} Token
@typedef {{
  tokens: Array<Token>;
  flags: RegexFlags;
}} TokenizerResult
*/
/**
@param {string} pattern Oniguruma pattern.
@param {{
  flags?: string;
  rules?: {
    captureGroup?: boolean;
    singleline?: boolean;
  };
}} [options]
@returns {TokenizerResult}
*/
export function tokenize(pattern: string, options?: {
    flags?: string;
    rules?: {
        captureGroup?: boolean;
        singleline?: boolean;
    };
}): TokenizerResult;
export namespace TokenCharacterSetKinds {
    let any: "any";
    let digit: "digit";
    let dot: "dot";
    let grapheme: "grapheme";
    let hex: "hex";
    let newline: "newline";
    let posix: "posix";
    let property: "property";
    let space: "space";
    let word: "word";
}
export namespace TokenDirectiveKinds {
    let flags: "flags";
    let keep: "keep";
}
export namespace TokenGroupKinds {
    let absent_repeater: "absent_repeater";
    let atomic: "atomic";
    let capturing: "capturing";
    let group: "group";
    let lookahead: "lookahead";
    let lookbehind: "lookbehind";
}
export namespace TokenQuantifierKinds {
    let greedy: "greedy";
    let lazy: "lazy";
    let possessive: "possessive";
}
export namespace TokenTypes {
    let Alternator: "Alternator";
    let Assertion: "Assertion";
    let Backreference: "Backreference";
    let Character: "Character";
    let CharacterClassClose: "CharacterClassClose";
    let CharacterClassHyphen: "CharacterClassHyphen";
    let CharacterClassIntersector: "CharacterClassIntersector";
    let CharacterClassOpen: "CharacterClassOpen";
    let CharacterSet: "CharacterSet";
    let Directive: "Directive";
    let GroupClose: "GroupClose";
    let GroupOpen: "GroupOpen";
    let Subroutine: "Subroutine";
    let Quantifier: "Quantifier";
    let EscapedNumber: "EscapedNumber";
}
//# sourceMappingURL=tokenize.d.ts.map