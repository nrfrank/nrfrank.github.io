export type AbsentFunctionNode = {
    type: "AbsentFunction";
    kind: "repeater";
    alternatives: Array<AlternativeNode>;
};
export type AlternativeNode = {
    type: "Alternative";
    elements: Array<AlternativeElementNode>;
};
export type AssertionNode = {
    type: "Assertion";
    kind: "grapheme_boundary" | "line_end" | "line_start" | "search_start" | "string_end" | "string_end_newline" | "string_start" | "word_boundary";
    negate?: boolean;
};
export type BackreferenceNode = {
    type: "Backreference";
    ref: string | number;
    orphan?: boolean;
};
export type CapturingGroupNode = {
    type: "CapturingGroup";
    number: number;
    name?: string;
    alternatives: Array<AlternativeNode>;
};
export type CharacterNode = {
    type: "Character";
    value: number;
};
export type CharacterClassNode = {
    type: "CharacterClass";
    kind: "union" | "intersection";
    negate: boolean;
    elements: Array<CharacterClassElementNode>;
};
export type CharacterClassRangeNode = {
    type: "CharacterClassRange";
    min: CharacterNode;
    max: CharacterNode;
};
export type CharacterSetNode = {
    type: "CharacterSet";
    kind: "grapheme" | "word" | "digit" | "space" | "any" | "dot" | "hex" | "newline" | "posix" | "property";
    value?: string;
    negate?: boolean;
    variableLength?: boolean;
};
export type DirectiveNode = {
    type: "Directive";
    kind: "flags" | "keep";
    flags?: FlagGroupModifiers;
};
export type FlagsNode = {
    type: "Flags";
} & import("../tokenizer/tokenize.js").RegexFlags;
export type FlagGroupModifiers = {
    enable?: import("../tokenizer/tokenize.js").FlagGroupSwitches;
    disable?: import("../tokenizer/tokenize.js").FlagGroupSwitches;
};
export type GroupNode = {
    type: "Group";
    atomic?: boolean;
    flags?: FlagGroupModifiers;
    alternatives: Array<AlternativeNode>;
};
export type LookaroundAssertionNode = {
    type: "LookaroundAssertion";
    kind: "lookahead" | "lookbehind";
    negate: boolean;
    alternatives: Array<AlternativeNode>;
};
export type PatternNode = {
    type: "Pattern";
    alternatives: Array<AlternativeNode>;
};
export type QuantifierNode = {
    type: "Quantifier";
    min: number;
    max: number;
    kind: "greedy" | "lazy" | "possessive";
    element: QuantifiableNode;
};
export type RegexNode = {
    type: "Regex";
    pattern: PatternNode;
    flags: FlagsNode;
};
export type SubroutineNode = {
    type: "Subroutine";
    ref: string | number;
};
export type NodeType = "AbsentFunction" | "Alternative" | "Assertion" | "Backreference" | "CapturingGroup" | "Character" | "CharacterClass" | "CharacterClassRange" | "CharacterSet" | "Directive" | "Flags" | "Group" | "LookaroundAssertion" | "Pattern" | "Quantifier" | "Regex" | "Subroutine";
export type OnigurumaAst = RegexNode;
export type Node = AbsentFunctionNode | AlternativeNode | AssertionNode | BackreferenceNode | CapturingGroupNode | CharacterNode | CharacterClassNode | CharacterClassRangeNode | CharacterSetNode | DirectiveNode | FlagsNode | GroupNode | LookaroundAssertionNode | PatternNode | QuantifierNode | RegexNode | SubroutineNode;
export type AlternativeContainerNode = AbsentFunctionNode | CapturingGroupNode | GroupNode | LookaroundAssertionNode | PatternNode;
export type AlternativeElementNode = AbsentFunctionNode | AssertionNode | BackreferenceNode | CapturingGroupNode | CharacterNode | CharacterClassNode | CharacterSetNode | DirectiveNode | GroupNode | LookaroundAssertionNode | QuantifierNode | SubroutineNode;
export type CharacterClassElementNode = CharacterNode | CharacterClassNode | CharacterClassRangeNode | CharacterSetNode;
export type QuantifiableNode = AbsentFunctionNode | BackreferenceNode | CapturingGroupNode | CharacterNode | CharacterClassNode | CharacterSetNode | GroupNode | QuantifierNode | SubroutineNode;
/**
@typedef {{
  type: 'AbsentFunction';
  kind: keyof NodeAbsentFunctionKinds;
  alternatives: Array<AlternativeNode>;
}} AbsentFunctionNode
*/
/**
@param {keyof NodeAbsentFunctionKinds} kind
@returns {AbsentFunctionNode}
*/
export function createAbsentFunction(kind: "repeater"): AbsentFunctionNode;
/**
@typedef {{
  type: 'Alternative';
  elements: Array<AlternativeElementNode>;
}} AlternativeNode
*/
/**
@returns {AlternativeNode}
*/
export function createAlternative(): AlternativeNode;
/**
@typedef {{
  type: 'Assertion';
  kind: keyof NodeAssertionKinds;
  negate?: boolean;
}} AssertionNode
*/
/**
@param {keyof NodeAssertionKinds} kind
@param {{
  negate?: boolean;
}} [options]
@returns {AssertionNode}
*/
export function createAssertion(kind: "grapheme_boundary" | "line_end" | "line_start" | "search_start" | "string_end" | "string_end_newline" | "string_start" | "word_boundary", options?: {
    negate?: boolean;
}): AssertionNode;
/**
@typedef {{
  type: 'Backreference';
  ref: string | number;
  orphan?: boolean;
}} BackreferenceNode
*/
/**
@param {string | number} ref
@param {{
  orphan?: boolean;
}} [options]
@returns {BackreferenceNode}
*/
export function createBackreference(ref: string | number, options?: {
    orphan?: boolean;
}): BackreferenceNode;
/**
@typedef {{
  type: 'CapturingGroup';
  number: number;
  name?: string;
  alternatives: Array<AlternativeNode>;
}} CapturingGroupNode
*/
/**
@param {number} number
@param {string} [name]
@returns {CapturingGroupNode}
*/
export function createCapturingGroup(number: number, name?: string): CapturingGroupNode;
/**
@typedef {{
  type: 'Character';
  value: number;
}} CharacterNode
*/
/**
@param {number} charCode
@param {{
  useLastValid?: boolean;
}} [options]
@returns {CharacterNode}
*/
export function createCharacter(charCode: number, options?: {
    useLastValid?: boolean;
}): CharacterNode;
/**
@typedef {{
  type: 'CharacterClass';
  kind: keyof NodeCharacterClassKinds;
  negate: boolean;
  elements: Array<CharacterClassElementNode>;
}} CharacterClassNode
*/
/**
@param {{
  kind?: keyof NodeCharacterClassKinds;
  negate?: boolean;
}} [options]
@returns {CharacterClassNode}
*/
export function createCharacterClass(options?: {
    kind?: "union" | "intersection";
    negate?: boolean;
}): CharacterClassNode;
/**
@typedef {{
  type: 'CharacterClassRange';
  min: CharacterNode;
  max: CharacterNode;
}} CharacterClassRangeNode
*/
/**
@param {CharacterNode} min
@param {CharacterNode} max
@returns {CharacterClassRangeNode}
*/
export function createCharacterClassRange(min: CharacterNode, max: CharacterNode): CharacterClassRangeNode;
/**
@typedef {{
  type: 'CharacterSet';
  kind: keyof NodeCharacterSetKinds;
  value?: string;
  negate?: boolean;
  variableLength?: boolean;
}} CharacterSetNode
*/
/**
@param {keyof Omit<NodeCharacterSetKinds, 'posix' | 'property'>} kind
@param {{
  negate?: boolean;
}} [options]
@returns {
  Omit<CharacterSetNode, 'value'> & {
    kind: keyof Omit<NodeCharacterSetKinds, 'posix' | 'property'>;
  }
}
*/
export function createCharacterSet(kind: keyof Omit<{
    readonly any: "any";
    readonly digit: "digit";
    readonly dot: "dot";
    readonly grapheme: "grapheme";
    readonly hex: "hex";
    readonly newline: "newline";
    readonly posix: "posix";
    readonly property: "property";
    readonly space: "space";
    readonly word: "word";
}, "posix" | "property">, options?: {
    negate?: boolean;
}): Omit<CharacterSetNode, "value"> & {
    kind: keyof Omit<{
        readonly any: "any";
        readonly digit: "digit";
        readonly dot: "dot";
        readonly grapheme: "grapheme";
        readonly hex: "hex";
        readonly newline: "newline";
        readonly posix: "posix";
        readonly property: "property";
        readonly space: "space";
        readonly word: "word";
    }, "posix" | "property">;
};
/**
@typedef {{
  type: 'Directive';
  kind: keyof NodeDirectiveKinds;
  flags?: FlagGroupModifiers;
}} DirectiveNode
*/
/**
@param {keyof NodeDirectiveKinds} kind
@param {{
  flags?: FlagGroupModifiers;
}} [options]
@returns {DirectiveNode}
*/
export function createDirective(kind: "flags" | "keep", options?: {
    flags?: FlagGroupModifiers;
}): DirectiveNode;
/**
@typedef {{
  type: 'Flags';
} & import('../tokenizer/tokenize.js').RegexFlags} FlagsNode
*/
/**
@param {import('../tokenizer/tokenize.js').RegexFlags} flags
@returns {FlagsNode}
*/
export function createFlags(flags: import("../tokenizer/tokenize.js").RegexFlags): FlagsNode;
/**
@typedef {{
  enable?: import('../tokenizer/tokenize.js').FlagGroupSwitches;
  disable?: import('../tokenizer/tokenize.js').FlagGroupSwitches;
}} FlagGroupModifiers
@typedef {{
  type: 'Group';
  atomic?: boolean;
  flags?: FlagGroupModifiers;
  alternatives: Array<AlternativeNode>;
}} GroupNode
*/
/**
@param {{
  atomic?: boolean;
  flags?: FlagGroupModifiers;
}} [options]
@returns {GroupNode}
*/
export function createGroup(options?: {
    atomic?: boolean;
    flags?: FlagGroupModifiers;
}): GroupNode;
/**
@typedef {{
  type: 'LookaroundAssertion';
  kind: keyof NodeLookaroundAssertionKinds;
  negate: boolean;
  alternatives: Array<AlternativeNode>;
}} LookaroundAssertionNode
*/
/**
@param {{
  behind?: boolean;
  negate?: boolean;
}} [options]
@returns {LookaroundAssertionNode}
*/
export function createLookaroundAssertion(options?: {
    behind?: boolean;
    negate?: boolean;
}): LookaroundAssertionNode;
/**
@typedef {{
  type: 'Pattern';
  alternatives: Array<AlternativeNode>;
}} PatternNode
*/
/**
@returns {PatternNode}
*/
export function createPattern(): PatternNode;
/**
@param {string} name
@param {{
  negate?: boolean;
}} [options]
@returns {
  CharacterSetNode & {
    kind: 'posix';
    value: string;
    negate: boolean;
  }
}
*/
export function createPosixClass(name: string, options?: {
    negate?: boolean;
}): CharacterSetNode & {
    kind: "posix";
    value: string;
    negate: boolean;
};
/**
@typedef {{
  type: 'Quantifier';
  min: number;
  max: number;
  kind: keyof NodeQuantifierKinds;
  element: QuantifiableNode;
}} QuantifierNode
*/
/**
@param {QuantifiableNode} element
@param {number} min
@param {number} max
@param {keyof NodeQuantifierKinds} [kind]
@returns {QuantifierNode}
*/
export function createQuantifier(element: QuantifiableNode, min: number, max: number, kind?: "greedy" | "lazy" | "possessive"): QuantifierNode;
/**
@typedef {{
  type: 'Regex';
  pattern: PatternNode;
  flags: FlagsNode;
}} RegexNode
*/
/**
@param {PatternNode} pattern
@param {FlagsNode} flags
@returns {RegexNode}
*/
export function createRegex(pattern: PatternNode, flags: FlagsNode): RegexNode;
/**
@typedef {{
  type: 'Subroutine';
  ref: string | number;
}} SubroutineNode
*/
/**
@param {string | number} ref
@returns {SubroutineNode}
*/
export function createSubroutine(ref: string | number): SubroutineNode;
/**
@param {string} name
@param {{
  negate?: boolean;
  normalizeUnknownPropertyNames?: boolean;
  skipPropertyNameValidation?: boolean;
  unicodePropertyMap?: Map<string, string>?;
}} [options]
@returns {
  CharacterSetNode & {
    kind: 'property';
    value: string;
    negate: boolean;
  }
}
*/
export function createUnicodeProperty(name: string, options?: {
    negate?: boolean;
    normalizeUnknownPropertyNames?: boolean;
    skipPropertyNameValidation?: boolean;
    unicodePropertyMap?: Map<string, string> | null;
}): CharacterSetNode & {
    kind: "property";
    value: string;
    negate: boolean;
};
export namespace NodeAbsentFunctionKinds {
    let repeater: "repeater";
}
export namespace NodeAssertionKinds {
    let grapheme_boundary: "grapheme_boundary";
    let line_end: "line_end";
    let line_start: "line_start";
    let search_start: "search_start";
    let string_end: "string_end";
    let string_end_newline: "string_end_newline";
    let string_start: "string_start";
    let word_boundary: "word_boundary";
}
export namespace NodeCharacterClassKinds {
    let union: "union";
    let intersection: "intersection";
}
export const NodeCharacterSetKinds: {
    readonly any: "any";
    readonly digit: "digit";
    readonly dot: "dot";
    readonly grapheme: "grapheme";
    readonly hex: "hex";
    readonly newline: "newline";
    readonly posix: "posix";
    readonly property: "property";
    readonly space: "space";
    readonly word: "word";
};
export const NodeDirectiveKinds: {
    readonly flags: "flags";
    readonly keep: "keep";
};
export namespace NodeLookaroundAssertionKinds {
    let lookahead: "lookahead";
    let lookbehind: "lookbehind";
}
export namespace NodeTypes {
    let AbsentFunction: "AbsentFunction";
    let Alternative: "Alternative";
    let Assertion: "Assertion";
    let Backreference: "Backreference";
    let CapturingGroup: "CapturingGroup";
    let Character: "Character";
    let CharacterClass: "CharacterClass";
    let CharacterClassRange: "CharacterClassRange";
    let CharacterSet: "CharacterSet";
    let Directive: "Directive";
    let Flags: "Flags";
    let Group: "Group";
    let LookaroundAssertion: "LookaroundAssertion";
    let Pattern: "Pattern";
    let Quantifier: "Quantifier";
    let Regex: "Regex";
    let Subroutine: "Subroutine";
    let Recursion: "Recursion";
}
export const NodeQuantifierKinds: {
    readonly greedy: "greedy";
    readonly lazy: "lazy";
    readonly possessive: "possessive";
};
/**
@param {string} pattern Oniguruma pattern.
@param {{
  flags?: string;
  normalizeUnknownPropertyNames?: boolean;
  rules?: {
    captureGroup?: boolean;
    singleline?: boolean;
  };
  skipBackrefValidation?: boolean;
  skipLookbehindValidation?: boolean;
  skipPropertyNameValidation?: boolean;
  unicodePropertyMap?: Map<string, string>?;
}} [options]
@returns {OnigurumaAst}
*/
export function parse(pattern: string, options?: {
    flags?: string;
    normalizeUnknownPropertyNames?: boolean;
    rules?: {
        captureGroup?: boolean;
        singleline?: boolean;
    };
    skipBackrefValidation?: boolean;
    skipLookbehindValidation?: boolean;
    skipPropertyNameValidation?: boolean;
    unicodePropertyMap?: Map<string, string> | null;
}): OnigurumaAst;
/**
Generates a Unicode property lookup name: lowercase, without spaces, hyphens, or underscores.
@param {string} name Unicode property name.
@returns {string}
*/
export function slug(name: string): string;
//# sourceMappingURL=parse.d.ts.map