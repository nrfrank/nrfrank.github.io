{
  "version": 3,
  "sources": ["../src/bundle.js", "../src/utils.js", "../src/tokenizer/tokenize.js", "../src/parser/parse.js", "../src/unicode.js", "../src/index.js", "../src/generator/generate.js", "../src/traverser/traverse.js", "../src/parser/node-utils.js", "../src/optimizer/transforms/alternation-to-class.js", "../src/optimizer/transforms/dedupe-classes.js", "../src/optimizer/transforms/extract-prefix.js", "../src/optimizer/transforms/extract-prefix-2.js", "../src/optimizer/transforms/remove-empty-groups.js", "../src/optimizer/transforms/remove-useless-flags.js", "../src/optimizer/transforms/unnest-useless-classes.js", "../src/optimizer/transforms/unwrap-negation-wrappers.js", "../src/optimizer/transforms/unwrap-useless-classes.js", "../src/optimizer/transforms/unwrap-useless-groups.js", "../src/optimizer/transforms/use-shorthands.js", "../src/optimizer/transforms/use-unicode-aliases.js", "../src/optimizer/transforms/use-unicode-props.js", "../src/optimizer/optimizations.js", "../src/optimizer/optimize.js"],
  "sourcesContent": ["export {toOnigurumaAst} from './index.js';\nexport {generate} from './generator/generate.js';\nexport {optimize, getOptionalOptimizations} from './optimizer/optimize.js';\nexport {parse} from './parser/parse.js';\nexport {traverse} from './traverser/traverse.js';\n", "const cp = String.fromCodePoint;\nconst r = String.raw;\n\nconst PosixClassNames = new Set([\n  'alnum',\n  'alpha',\n  'ascii',\n  'blank',\n  'cntrl',\n  'digit',\n  'graph',\n  'lower',\n  'print',\n  'punct',\n  'space',\n  'upper',\n  'word',\n  'xdigit',\n]);\n\nfunction getOrInsert(map, key, defaultValue) {\n  if (!map.has(key)) {\n    map.set(key, defaultValue);\n  }\n  return map.get(key);\n}\n\nfunction throwIfNot(value, msg) {\n  if (!value) {\n    throw new Error(msg ?? 'Value expected');\n  }\n  return value;\n}\n\nexport {\n  cp,\n  getOrInsert,\n  PosixClassNames,\n  r,\n  throwIfNot,\n};\n", "import {PosixClassNames, r} from '../utils.js';\n\nconst TokenTypes = /** @type {const} */ ({\n  Alternator: 'Alternator',\n  Assertion: 'Assertion',\n  Backreference: 'Backreference',\n  Character: 'Character',\n  CharacterClassClose: 'CharacterClassClose',\n  CharacterClassHyphen: 'CharacterClassHyphen',\n  CharacterClassIntersector: 'CharacterClassIntersector',\n  CharacterClassOpen: 'CharacterClassOpen',\n  CharacterSet: 'CharacterSet',\n  Directive: 'Directive',\n  GroupClose: 'GroupClose',\n  GroupOpen: 'GroupOpen',\n  Subroutine: 'Subroutine',\n  Quantifier: 'Quantifier',\n  // Intermediate representation not included in results\n  EscapedNumber: 'EscapedNumber',\n});\n\nconst TokenCharacterSetKinds = /** @type {const} */ ({\n  any: 'any',\n  digit: 'digit',\n  dot: 'dot',\n  grapheme: 'grapheme',\n  hex: 'hex',\n  newline: 'newline',\n  posix: 'posix',\n  property: 'property',\n  space: 'space',\n  word: 'word',\n});\n\nconst TokenDirectiveKinds = /** @type {const} */ ({\n  flags: 'flags',\n  keep: 'keep',\n});\n\nconst TokenGroupKinds = /** @type {const} */ ({\n  absent_repeater: 'absent_repeater',\n  atomic: 'atomic',\n  capturing: 'capturing',\n  group: 'group',\n  lookahead: 'lookahead',\n  lookbehind: 'lookbehind',\n});\n\nconst TokenQuantifierKinds = /** @type {const} */ ({\n  greedy: 'greedy',\n  lazy: 'lazy',\n  possessive: 'possessive',\n});\n\nconst EscapeCharCodes = new Map([\n  ['a',  7], // alert/bell (Not available in JS)\n  ['b',  8], // backspace (only in char classes)\n  ['e', 27], // escape (Not available in JS)\n  ['f', 12], // form feed\n  ['n', 10], // line feed\n  ['r', 13], // carriage return\n  ['t',  9], // horizontal tab\n  ['v', 11], // vertical tab\n]);\n\nconst charClassOpenPattern = r`\\[\\^?`;\nconst sharedEscapesPattern = `${\n  // Control char\n  'c.? | C(?:-.?)?'\n}|${\n  // Unicode property; Onig considers `\\p` an identity escape, but e.g. `\\p{`, `\\p{ ^L}`, and\n  // `\\p{gc=L}` are invalid\n  r`[pP]\\{(?:\\^?[-\\x20_]*[A-Za-z][-\\x20\\w]*\\})?`\n}|${\n  // Hex encoded byte sequence; attempt match before other `\\xNN` hex char\n  r`x[89A-Fa-f]\\p{AHex}(?:\\\\x[89A-Fa-f]\\p{AHex})*`\n}|${\n  // Hex char\n  r`u(?:\\p{AHex}{4})? | x\\{[^\\}]*\\}? | x\\p{AHex}{0,2}`\n}|${\n  // Enclosed octal code point\n  r`o\\{[^\\}]*\\}?`\n}|${\n  // Escaped number\n  r`\\d{1,3}`\n}`;\n// Even with flag x, Onig doesn't allow whitespace to separate a quantifier from the `?` or `+`\n// that makes it lazy or possessive. Possessive suffixes don't apply to interval quantifiers\nconst quantifierRe = /[?*+][?+]?|\\{(?:\\d+(?:,\\d*)?|,\\d+)\\}\\??/;\nconst tokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | [gk]<[^>]*>?\n    | [gk]'[^']*'?\n    | .\n  )\n  | \\( (?:\n    \\? (?:\n      [:=!>({]\n      | <[=!]\n      | <[^>]*>\n      | '[^']*'\n      | ~\\|?\n      | #(?:[^)\\\\]|\\\\.?)*\n      | [^:)]*[:)]\n    )?\n    | \\*\n  )?\n  | ${quantifierRe.source}\n  | ${charClassOpenPattern}\n  | .\n`.replace(/\\s+/g, ''), 'gsu');\nconst charClassTokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | .\n  )\n  | \\[:(?:\\^?\\p{Alpha}+|\\^):\\]\n  | ${charClassOpenPattern}\n  | &&\n  | .\n`.replace(/\\s+/g, ''), 'gsu');\n\n/**\n@typedef {{\n  ignoreCase: boolean;\n  dotAll: boolean;\n  extended: boolean;\n  digitIsAscii: boolean;\n  posixIsAscii: boolean;\n  spaceIsAscii: boolean;\n  wordIsAscii: boolean;\n}} RegexFlags\n@typedef {{\n  type: keyof TokenTypes;\n  raw: string;\n  [key: string]: string | number | boolean;\n}} Token\n@typedef {{\n  tokens: Array<Token>;\n  flags: RegexFlags;\n}} TokenizerResult\n*/\n/**\n@param {string} pattern Oniguruma pattern.\n@param {{\n  flags?: string;\n  rules?: {\n    captureGroup?: boolean;\n    singleline?: boolean;\n  };\n}} [options]\n@returns {TokenizerResult}\n*/\nfunction tokenize(pattern, options = {}) {\n  const opts = {\n    flags: '',\n    ...options,\n    rules: {\n      captureGroup: false, // `ONIG_OPTION_CAPTURE_GROUP`\n      singleline: false, // `ONIG_OPTION_SINGLELINE`\n      ...options.rules,\n    },\n  };\n  if (typeof pattern !== 'string') {\n    throw new Error('String expected as pattern');\n  }\n  const flagsObj = getFlagsObj(opts.flags);\n  const xStack = [flagsObj.extended];\n  const context = {\n    captureGroup: opts.rules.captureGroup,\n    getCurrentModX: () => xStack.at(-1),\n    numOpenGroups: 0,\n    popModX() {xStack.pop()},\n    pushModX(isXOn) {xStack.push(isXOn)},\n    replaceCurrentModX(isXOn) {xStack[xStack.length - 1] = isXOn},\n    singleline: opts.rules.singleline,\n  };\n  let tokens = [];\n  let match;\n  tokenRe.lastIndex = 0;\n  while ((match = tokenRe.exec(pattern))) {\n    const result = getTokenWithDetails(context, pattern, match[0], tokenRe.lastIndex);\n    if (result.tokens) {\n      tokens.push(...result.tokens);\n    } else if (result.token) {\n      tokens.push(result.token);\n    }\n    if (result.lastIndex !== undefined) {\n      tokenRe.lastIndex = result.lastIndex;\n    }\n  }\n\n  const potentialUnnamedCaptureTokens = [];\n  let numNamedAndOptInUnnamedCaptures = 0;\n  tokens.forEach(t => {\n    if (t.type === TokenTypes.GroupOpen) {\n      if (t.kind === TokenGroupKinds.capturing) {\n        t.number = ++numNamedAndOptInUnnamedCaptures;\n      } else if (t.raw === '(') {\n        potentialUnnamedCaptureTokens.push(t);\n      }\n    }\n  });\n  // Enable unnamed capturing groups if no named captures (when `captureGroup` not enabled)\n  if (!numNamedAndOptInUnnamedCaptures) {\n    potentialUnnamedCaptureTokens.forEach((t, i) => {\n      t.kind = TokenGroupKinds.capturing;\n      t.number = i + 1;\n    });\n  }\n  const numCaptures = numNamedAndOptInUnnamedCaptures || potentialUnnamedCaptureTokens.length;\n  // Can now split escaped nums accurately, accounting for number of captures\n  tokens = tokens.map(\n    t => t.type === TokenTypes.EscapedNumber ? splitEscapedNumToken(t, numCaptures) : t\n  ).flat();\n\n  return {\n    tokens,\n    flags: flagsObj,\n  };\n}\n\nfunction getTokenWithDetails(context, pattern, m, lastIndex) {\n  const [m0, m1] = m;\n\n  if (m0 === '[') {\n    const result = getAllTokensForCharClass(pattern, m, lastIndex);\n    return {\n      // Array of all of the char class's tokens\n      tokens: result.tokens,\n      // Jump forward to the end of the char class\n      lastIndex: result.lastIndex,\n    };\n  }\n\n  if (m0 === '\\\\') {\n    if ('AbBGyYzZ'.includes(m1)) {\n      return {\n        token: createToken(TokenTypes.Assertion, m, {\n          kind: m,\n        }),\n      };\n    }\n    if (/^\\\\g[<']/.test(m)) {\n      if (!/^\\\\g(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.Subroutine, m),\n      };\n    }\n    if (/^\\\\k[<']/.test(m)) {\n      if (!/^\\\\k(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.Backreference, m),\n      };\n    }\n    if (m1 === 'K') {\n      return {\n        token: createToken(TokenTypes.Directive, m, {\n          kind: TokenDirectiveKinds.keep,\n        }),\n      };\n    }\n    if (m1 === 'N' || m1 === 'R') {\n      return {\n        token: createToken(TokenTypes.CharacterSet, m, {\n          kind: TokenCharacterSetKinds.newline,\n          // `\\N` and `\\R` are not actually opposites since the former only excludes `\\n`\n          negate: m1 === 'N',\n        }),\n      };\n    }\n    if (m1 === 'O') {\n      return {\n        token: createToken(TokenTypes.CharacterSet, m, {\n          kind: TokenCharacterSetKinds.any,\n        }),\n      };\n    }\n    if (m1 === 'X') {\n      return {\n        token: createToken(TokenTypes.CharacterSet, m, {\n          kind: TokenCharacterSetKinds.grapheme,\n        }),\n      };\n    }\n    // Run last since it assumes an identity escape as final condition\n    const result = createTokenForSharedEscape(m, {inCharClass: false});\n    return Array.isArray(result) ? {tokens: result} : {token: result};\n  }\n\n  if (m0 === '(') {\n    if (m === '(*') {\n      throw new Error(`Unsupported named callout \"${m}\"`);\n    }\n    if (m === '(?{') {\n      throw new Error(`Unsupported callout \"${m}\"`);\n    }\n    // Comment group\n    if (m.startsWith('(?#')) {\n      // Everything except the closing unescaped `)` is included in the match\n      if (pattern[lastIndex] !== ')') {\n        throw new Error('Unclosed comment group \"(?#\"');\n      }\n      return {\n        // Jump forward to after the closing paren\n        lastIndex: lastIndex + 1,\n      };\n    }\n    // Flag modifier (directive or group opener)\n    if (/^\\(\\?[-imx]+[:)]$/.test(m)) {\n      return {\n        token: createTokenForFlagMod(m, context),\n      };\n    }\n    // --- Remaining group types all reuse current flag x status ---\n    context.pushModX(context.getCurrentModX());\n    context.numOpenGroups++;\n    if (\n      // Unnamed capture if no named captures present and `captureGroup` not enabled, else\n      // noncapturing group\n      (m === '(' && !context.captureGroup) ||\n      // Noncapturing group\n      m === '(?:'\n    ) {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          // For `(`, will later change to `capturing` and add `number` prop if no named captures\n          kind: TokenGroupKinds.group,\n        }),\n      };\n    }\n    // Atomic group\n    if (m === '(?>') {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: TokenGroupKinds.atomic,\n        }),\n      };\n    }\n    // Lookaround\n    if (m === '(?=' || m === '(?!' || m === '(?<=' || m === '(?<!') {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: m[2] === '<' ? TokenGroupKinds.lookbehind : TokenGroupKinds.lookahead,\n          negate: m.endsWith('!'),\n        }),\n      };\n    }\n    // Unnamed capture when `captureGroup` enabled, or named capture (checked after lookbehind due\n    // to similar syntax)\n    if (\n      (m === '(' && context.captureGroup) ||\n      (m.startsWith('(?<') && m.endsWith('>')) ||\n      (m.startsWith(\"(?'\") && m.endsWith(\"'\"))\n    ) {\n      const token = createToken(TokenTypes.GroupOpen, m, {\n        kind: TokenGroupKinds.capturing,\n        // Will add `number` prop in a second pass\n      });\n      if (m !== '(') {\n        token.name = m.slice(3, -1);\n      }\n      return {\n        token,\n      };\n    }\n    if (m.startsWith('(?~')) {\n      if (m === '(?~|') {\n        throw new Error(`Unsupported absent function kind \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: TokenGroupKinds.absent_repeater,\n        }),\n      };\n    }\n    if (m === '(?(') {\n      // Some forms are supportable; can be added\n      throw new Error(`Unsupported conditional \"${m}\"`);\n    }\n    throw new Error(`Invalid or unsupported group option \"${m}\"`);\n  }\n  if (m === ')') {\n    context.popModX();\n    context.numOpenGroups--;\n    if (context.numOpenGroups < 0) {\n      throw new Error('Unmatched \")\"');\n    }\n    return {\n      token: createToken(TokenTypes.GroupClose, m),\n    };\n  }\n\n  if (m === '#' && context.getCurrentModX()) {\n    // Onig's only line break char is line feed\n    const end = pattern.indexOf('\\n', lastIndex);\n    return {\n      // Jump forward to the end of the comment\n      lastIndex: end === -1 ? pattern.length : end,\n    };\n  }\n  if (/^\\s$/.test(m) && context.getCurrentModX()) {\n    const re = /\\s+/y;\n    re.lastIndex = lastIndex;\n    const rest = re.exec(pattern);\n    return {\n      // Jump forward to the end of the whitespace\n      lastIndex: rest ? re.lastIndex : lastIndex,\n    };\n  }\n\n  if (m === '.') {\n    return {\n      token: createToken(TokenTypes.CharacterSet, m, {\n        kind: TokenCharacterSetKinds.dot,\n      }),\n    };\n  }\n\n  if (m === '^' || m === '$') {\n    const kind = context.singleline ? {\n      '^': r`\\A`,\n      '$': r`\\Z`,\n    }[m] : m;\n    return {\n      token: createToken(TokenTypes.Assertion, m, {\n        kind,\n      }),\n    };\n  }\n\n  if (m === '|') {\n    return {\n      token: createToken(TokenTypes.Alternator, m),\n    };\n  }\n\n  if (quantifierRe.test(m)) {\n    return {\n      token: createTokenForQuantifier(m),\n    };\n  }\n\n  assertSingleCodePoint(m);\n  return {\n    token: createToken(TokenTypes.Character, m, {\n      value: m.codePointAt(0),\n    }),\n  };\n}\n\nfunction getAllTokensForCharClass(pattern, opener, lastIndex) {\n  const tokens = [createToken(TokenTypes.CharacterClassOpen, opener, {\n    negate: opener[1] === '^',\n  })];\n  let numCharClassesOpen = 1;\n  let match;\n  charClassTokenRe.lastIndex = lastIndex;\n  while ((match = charClassTokenRe.exec(pattern))) {\n    const m = match[0];\n    // Start of nested char class\n    // POSIX classes are handled as a single token; not as a nested char class\n    if (m[0] === '[' && m[1] !== ':') {\n      numCharClassesOpen++;\n      tokens.push(createToken(TokenTypes.CharacterClassOpen, m, {\n        negate: m[1] === '^',\n      }));\n    } else if (m === ']') {\n      if (tokens.at(-1).type === TokenTypes.CharacterClassOpen) {\n        // Allow unescaped `]` as leading char\n        tokens.push(createToken(TokenTypes.Character, m, {\n          value: 93,\n        }));\n      } else {\n        numCharClassesOpen--;\n        tokens.push(createToken(TokenTypes.CharacterClassClose, m));\n        if (!numCharClassesOpen) {\n          break;\n        }\n      }\n    } else {\n      const result = createTokenForAnyTokenWithinCharClass(m);\n      if (Array.isArray(result)) {\n        tokens.push(...result);\n      } else {\n        tokens.push(result);\n      }\n    }\n  }\n  return {\n    tokens,\n    lastIndex: charClassTokenRe.lastIndex || pattern.length,\n  }\n}\n\nfunction createTokenForAnyTokenWithinCharClass(raw) {\n  if (raw[0] === '\\\\') {\n    // Assumes an identity escape as final condition\n    return createTokenForSharedEscape(raw, {inCharClass: true});\n  }\n  // POSIX class: `[:name:]` or `[:^name:]`\n  if (raw[0] === '[') {\n    const posix = /\\[:(?<negate>\\^?)(?<name>[a-z]+):\\]/.exec(raw);\n    if (!posix || !PosixClassNames.has(posix.groups.name)) {\n      throw new Error(`Invalid POSIX class \"${raw}\"`);\n    }\n    return createToken(TokenTypes.CharacterSet, raw, {\n      kind: TokenCharacterSetKinds.posix,\n      value: posix.groups.name,\n      negate: !!posix.groups.negate,\n    });\n  }\n  // Range (possibly invalid) or literal hyphen\n  if (raw === '-') {\n    return createToken(TokenTypes.CharacterClassHyphen, raw);\n  }\n  if (raw === '&&') {\n    return createToken(TokenTypes.CharacterClassIntersector, raw);\n  }\n  assertSingleCodePoint(raw);\n  return createToken(TokenTypes.Character, raw, {\n    value: raw.codePointAt(0),\n  });\n}\n\n// Tokens shared by base syntax and char class syntax that start with `\\`\nfunction createTokenForSharedEscape(raw, {inCharClass}) {\n  const char1 = raw[1];\n  if (char1 === 'c' || char1 === 'C') {\n    return createTokenForControlChar(raw);\n  }\n  if ('dDhHsSwW'.includes(char1)) {\n    return createTokenForShorthandCharClass(raw);\n  }\n  if (raw.startsWith(r`\\o{`)) {\n    throw new Error(`Incomplete, invalid, or unsupported octal code point \"${raw}\"`);\n  }\n  if (/^\\\\[pP]\\{/.test(raw)) {\n    if (raw.length === 3) {\n      throw new Error(`Incomplete or invalid Unicode property \"${raw}\"`);\n    }\n    return createTokenForUnicodeProperty(raw);\n  }\n  // Hex UTF-8 encoded byte sequence\n  if (/^\\\\x[89A-Fa-f]\\p{AHex}/u.test(raw)) {\n    try {\n      const bytes = raw.split(/\\\\x/).slice(1).map(hex => parseInt(hex, 16));\n      const decoded = new TextDecoder('utf-8', {\n        ignoreBOM: true,\n        fatal: true,\n      }).decode(new Uint8Array(bytes));\n      const encoder = new TextEncoder();\n      const tokens = [...decoded].map(char => {\n        // Since this regenerates `raw`, it might have different casing for hex A-F than the input\n        const raw = [...encoder.encode(char)].map(byte => `\\\\x${byte.toString(16)}`).join('');\n        return createToken(TokenTypes.Character, raw, {\n          value: char.codePointAt(0),\n        });\n      });\n      return tokens;\n    } catch {\n      throw new Error(`Multibyte code \"${raw}\" incomplete or invalid in Oniguruma`);\n    }\n  }\n  if (char1 === 'u' || char1 === 'x') {\n    return createToken(TokenTypes.Character, raw, {\n      value: getValidatedHexCharCode(raw),\n    });\n  }\n  if (EscapeCharCodes.has(char1)) {\n    return createToken(TokenTypes.Character, raw, {\n      value: EscapeCharCodes.get(char1),\n    });\n  }\n  // Escaped number: backref (possibly invalid), null, octal, or identity escape, possibly followed\n  // by 1-2 literal digits\n  if (/\\d/.test(char1)) {\n    return createToken(TokenTypes.EscapedNumber, raw, {\n      inCharClass,\n    });\n  }\n  if (raw === '\\\\') {\n    throw new Error(r`Incomplete escape \"\\\"`);\n  }\n  // Meta `\\M-x` and `\\M-\\C-x` are unsupported; avoid treating as an identity escape\n  if (char1 === 'M') {\n    // Supportable; see:\n    // - <github.com/kkos/oniguruma/blob/master/doc/SYNTAX.md#12-onig_syn_op2_esc_capital_m_bar_meta-enable-m-x>\n    // - <github.com/kkos/oniguruma/blob/43a8c3f3daf263091f3a74019d4b32ebb6417093/src/regparse.c#L4695>\n    // - <github.com/ammar/regexp_parser/blob/8851030feda68223d74f502335fb254a20d77016/lib/regexp_parser/expression/classes/escape_sequence.rb#L75>\n    throw new Error(`Unsupported meta \"${raw}\"`);\n  }\n  // Identity escape; count code point length\n  if ([...raw].length === 2) {\n    return createToken(TokenTypes.Character, raw, {\n      value: raw.codePointAt(1),\n    });\n  }\n  throw new Error(`Unexpected escape \"${raw}\"`);\n}\n\n/**\n@param {keyof TokenTypes} type\n@param {string} raw\n@param {{[key: string]: string | number | boolean;}} [data]\n@returns {Token}\n*/\nfunction createToken(type, raw, data) {\n  return {\n    type,\n    raw,\n    ...data,\n  };\n}\n\n// Expects `\\cx` or `\\C-x`\nfunction createTokenForControlChar(raw) {\n  const char = raw[1] === 'c' ? raw[2] : raw[3];\n  if (!char || !/[A-Za-z]/.test(char)) {\n    // Unlike JS, Onig allows any char to follow `\\c` or `\\C-`, but this is an extreme edge case\n    // Supportable; see <github.com/kkos/oniguruma/blob/master/doc/SYNTAX.md#11-onig_syn_op2_esc_capital_c_bar_control-enable-c-x>, <github.com/kkos/oniguruma/blob/43a8c3f3daf263091f3a74019d4b32ebb6417093/src/regparse.c#L4695>\n    throw new Error(`Unsupported control character \"${raw}\"`);\n  }\n  return createToken(TokenTypes.Character, raw, {\n    value: char.toUpperCase().codePointAt(0) - 64,\n  });\n}\n\nfunction createTokenForFlagMod(raw, context) {\n  // Allows multiple `-` and solo `-` without `on` or `off` flags\n  let {on, off} = /^\\(\\?(?<on>[imx]*)(?:-(?<off>[-imx]*))?/.exec(raw).groups;\n  off ??= '';\n  // Flag x is used directly by the tokenizer since it changes how to interpret the pattern\n  const isXOn = (context.getCurrentModX() || on.includes('x')) && !off.includes('x');\n  const enabledFlags = getFlagGroupSwitches(on);\n  const disabledFlags = getFlagGroupSwitches(off);\n  const flagChanges = {};\n  enabledFlags && (flagChanges.enable = enabledFlags);\n  disabledFlags && (flagChanges.disable = disabledFlags);\n  // Flag directive; ex: `(?im-x)`\n  if (raw.endsWith(')')) {\n    // Replace flag x value until the end of the current group\n    context.replaceCurrentModX(isXOn);\n    // Can't remove flag directives without flags like `(?-)`; they affect following quantifiers\n    return createToken(TokenTypes.Directive, raw, {\n      kind: TokenDirectiveKinds.flags,\n      flags: flagChanges,\n    });\n  }\n  // Flag group opener; ex: `(?im-x:`\n  if (raw.endsWith(':')) {\n    context.pushModX(isXOn);\n    context.numOpenGroups++;\n    const token = createToken(TokenTypes.GroupOpen, raw, {\n      kind: TokenGroupKinds.group,\n    });\n    if (enabledFlags || disabledFlags) {\n      token.flags = flagChanges;\n    }\n    return token;\n  }\n  throw new Error(`Unexpected flag modifier \"${raw}\"`);\n}\n\nfunction createTokenForQuantifier(raw) {\n  const data = {};\n  if (raw[0] === '{') {\n    const {min, max} = /^\\{(?<min>\\d*)(?:,(?<max>\\d*))?/.exec(raw).groups;\n    const limit = 100_000;\n    if (+min > limit || +max > limit) {\n      throw new Error('Quantifier value unsupported in Oniguruma');\n    }\n    data.min = +min;\n    data.max = max === undefined ? +min : (max === '' ? Infinity : +max);\n    // By default, Onig doesn't support making interval quantifiers possessive with a `+` suffix\n    data.kind = raw.endsWith('?') ? TokenQuantifierKinds.lazy : TokenQuantifierKinds.greedy;\n  } else {\n    data.min = raw[0] === '+' ? 1 : 0;\n    data.max = raw[0] === '?' ? 1 : Infinity;\n    data.kind = raw[1] === '+' ?\n      TokenQuantifierKinds.possessive :\n      (raw[1] === '?' ? TokenQuantifierKinds.lazy : TokenQuantifierKinds.greedy);\n  }\n  return createToken(TokenTypes.Quantifier, raw, data);\n}\n\nfunction createTokenForShorthandCharClass(raw) {\n  const lower = raw[1].toLowerCase();\n  return createToken(TokenTypes.CharacterSet, raw, {\n    kind: {\n      'd': TokenCharacterSetKinds.digit,\n      'h': TokenCharacterSetKinds.hex,\n      's': TokenCharacterSetKinds.space,\n      'w': TokenCharacterSetKinds.word,\n    }[lower],\n    negate: raw[1] !== lower,\n  });\n}\n\nfunction createTokenForUnicodeProperty(raw) {\n  const {p, neg, value} = /^\\\\(?<p>[pP])\\{(?<neg>\\^?)(?<value>[^}]+)/.exec(raw).groups;\n  const negate = (p === 'P' && !neg) || (p === 'p' && !!neg);\n  return createToken(TokenTypes.CharacterSet, raw, {\n    kind: TokenCharacterSetKinds.property,\n    value,\n    negate,\n  });\n}\n\n/**\n@typedef {{\n  ignoreCase?: true;\n  dotAll?: true;\n  extended?: true;\n}} FlagGroupSwitches\n*/\n/**\n@param {string} flags\n@returns {FlagGroupSwitches?}\n*/\nfunction getFlagGroupSwitches(flags) {\n  // Don't include `false` for flags that aren't included\n  const obj = {};\n  if (flags.includes('i')) {\n    obj.ignoreCase = true;\n  }\n  if (flags.includes('m')) {\n    // Onig flag m is equivalent to JS flag s\n    obj.dotAll = true;\n  }\n  if (flags.includes('x')) {\n    obj.extended = true;\n  }\n  return Object.keys(obj).length ? obj : null;\n}\n\nfunction getFlagsObj(flags) {\n  if (!/^[imxDPSW]*$/.test(flags)) {\n    throw new Error(`Flags \"${flags}\" includes unsupported value`);\n  }\n  const flagsObj = {\n    ignoreCase: false,\n    dotAll: false,\n    extended: false,\n    digitIsAscii: false,\n    posixIsAscii: false,\n    spaceIsAscii: false,\n    wordIsAscii: false,\n  };\n  for (const char of flags) {\n    flagsObj[{\n      i: 'ignoreCase',\n      // Flag m is called `multiline` in Onig, but that has a different meaning in JS. Onig flag m\n      // is equivalent to JS flag s\n      m: 'dotAll',\n      // Flag x is fully handled during tokenization\n      x: 'extended',\n      // Flags D, P, S, W are currently only supported as top-level flags\n      D: 'digitIsAscii',\n      P: 'posixIsAscii',\n      S: 'spaceIsAscii',\n      W: 'wordIsAscii',\n    }[char]] = true;\n  }\n  return flagsObj;\n}\n\n// - Unenclosed `\\xNN` above 0x7F is handled elsewhere as a UTF-8 encoded byte sequence\n// - Enclosed `\\x{}` with value above 0x10FFFF is allowed here; handled in the parser\nfunction getValidatedHexCharCode(raw) {\n  // Note: Onig (tested 6.9.8) has a bug where bare `\\u` and `\\x` are identity escapes if they\n  // appear at the very end of the pattern, so e.g. `\\u` matches `u`, but `\\u0`, `\\u.`, and `[\\u]`\n  // are all errors, and `\\x.` and `[\\x]` aren't errors but instead the `\\x` is equivalent to `\\0`.\n  // Don't emulate these bugs (see #21), and just treat these cases as errors. Also, Onig treats\n  // incomplete `\\x{` (with the brace and not immediately followed by a hex digit) as an identity\n  // escape, so e.g. `\\x{` matches `x{` and `^\\x{,2}$` matches `xx`, but `\\x{2,}` and `\\x{0,2}` are\n  // errors. Don't emulate this pointless ambiguity; just treat incomplete `\\x{` as an error\n  if (/^(?:\\\\u(?!\\p{AHex}{4})|\\\\x(?!\\p{AHex}{1,2}|\\{\\p{AHex}{1,8}\\}))/u.test(raw)) {\n    throw new Error(`Incomplete or invalid escape \"${raw}\"`);\n  }\n  // Might include leading 0s\n  const hex = raw[2] === '{' ?\n    /^\\\\x\\{\\s*(?<hex>\\p{AHex}+)/u.exec(raw).groups.hex :\n    raw.slice(2);\n  const dec = parseInt(hex, 16);\n  return dec;\n}\n\n// Value is 1-3 digits, which can be a backref (possibly invalid), null, octal, or identity escape,\n// possibly followed by 1-2 literal digits\nfunction splitEscapedNumToken(token, numCaptures) {\n  const {raw, inCharClass} = token;\n  // Keep any leading 0s since they indicate octal\n  const value = raw.slice(1);\n  // Backref (possibly invalid)\n  if (\n    !inCharClass &&\n    ( // Single digit 1-9 outside a char class is always treated as a backref\n      (value !== '0' && value.length === 1) ||\n      // Leading 0 makes it octal; backrefs can't include following literal digits\n      (value[0] !== '0' && +value <= numCaptures)\n    )\n  ) {\n    return [createToken(TokenTypes.Backreference, raw)];\n  }\n  const tokens = [];\n  // Returns 1-3 matches; the first (only) might be octal\n  const matches = value.match(/^[0-7]+|\\d/g);\n  for (let i = 0; i < matches.length; i++) {\n    const m = matches[i];\n    let value;\n    // Octal digits are 0-7\n    if (i === 0 && m !== '8' && m !== '9') {\n      value = parseInt(m, 8);\n      if (value > 0o177) {\n        // Octal UTF-8 encoded byte sequence; not yet supported\n        throw new Error(r`Octal encoded byte above 177 unsupported \"${raw}\"`);\n      }\n    } else {\n      value = m.codePointAt(0);\n    }\n    tokens.push(createToken(TokenTypes.Character, (i === 0 ? '\\\\' : '') + m, {\n      value,\n    }));\n  }\n  return tokens;\n}\n\nfunction assertSingleCodePoint(raw) {\n  if ([...raw].length !== 1) {\n    throw new Error(`Expected \"${raw}\" to be a single code point`);\n  }\n}\n\nexport {\n  tokenize,\n  TokenCharacterSetKinds,\n  TokenDirectiveKinds,\n  TokenGroupKinds,\n  TokenQuantifierKinds,\n  TokenTypes,\n};\n", "import {TokenCharacterSetKinds, TokenDirectiveKinds, TokenGroupKinds, tokenize, TokenQuantifierKinds, TokenTypes} from '../tokenizer/tokenize.js';\nimport {getOrInsert, PosixClassNames, r, throwIfNot} from '../utils.js';\n\n/**\n@typedef {\n  'AbsentFunction' |\n  'Alternative' |\n  'Assertion' |\n  'Backreference' |\n  'CapturingGroup' |\n  'Character' |\n  'CharacterClass' |\n  'CharacterClassRange' |\n  'CharacterSet' |\n  'Directive' |\n  'Flags' |\n  'Group' |\n  'LookaroundAssertion' |\n  'Pattern' |\n  'Quantifier' |\n  'Regex' |\n  'Subroutine'\n} NodeType\n*/\nconst NodeTypes = /** @type {const} */ ({\n  AbsentFunction: 'AbsentFunction',\n  Alternative: 'Alternative',\n  Assertion: 'Assertion',\n  Backreference: 'Backreference',\n  CapturingGroup: 'CapturingGroup',\n  Character: 'Character',\n  CharacterClass: 'CharacterClass',\n  CharacterClassRange: 'CharacterClassRange',\n  CharacterSet: 'CharacterSet',\n  Directive: 'Directive',\n  Flags: 'Flags',\n  Group: 'Group',\n  LookaroundAssertion: 'LookaroundAssertion',\n  Pattern: 'Pattern',\n  Quantifier: 'Quantifier',\n  Regex: 'Regex',\n  Subroutine: 'Subroutine',\n  // Type `Recursion` is used only by the `oniguruma-to-es` transformer for Regex+ ASTs\n  // [TODO] Refactor to remove this type: <github.com/slevithan/oniguruma-parser/issues/3>\n  Recursion: 'Recursion',\n});\n\n/**\n@typedef {RegexNode} OnigurumaAst\n@typedef {\n  AbsentFunctionNode |\n  AlternativeNode |\n  AssertionNode |\n  BackreferenceNode |\n  CapturingGroupNode |\n  CharacterNode |\n  CharacterClassNode |\n  CharacterClassRangeNode |\n  CharacterSetNode |\n  DirectiveNode |\n  FlagsNode |\n  GroupNode |\n  LookaroundAssertionNode |\n  PatternNode |\n  QuantifierNode |\n  RegexNode |\n  SubroutineNode\n} Node\n@typedef {\n  AbsentFunctionNode |\n  CapturingGroupNode |\n  GroupNode |\n  LookaroundAssertionNode |\n  PatternNode\n} AlternativeContainerNode\n@typedef {\n  AbsentFunctionNode |\n  AssertionNode |\n  BackreferenceNode |\n  CapturingGroupNode |\n  CharacterNode |\n  CharacterClassNode |\n  CharacterSetNode |\n  DirectiveNode |\n  GroupNode |\n  LookaroundAssertionNode |\n  QuantifierNode |\n  SubroutineNode\n} AlternativeElementNode\n@typedef {\n  CharacterNode |\n  CharacterClassNode |\n  CharacterClassRangeNode |\n  CharacterSetNode\n} CharacterClassElementNode\n@typedef {\n  AbsentFunctionNode |\n  BackreferenceNode |\n  CapturingGroupNode |\n  CharacterNode |\n  CharacterClassNode |\n  CharacterSetNode |\n  GroupNode |\n  QuantifierNode |\n  SubroutineNode\n} QuantifiableNode\n*/\n\n// See <github.com/slevithan/oniguruma-to-es/issues/13>\nconst NodeAbsentFunctionKinds = /** @type {const} */ ({\n  repeater: 'repeater',\n});\n\nconst NodeAssertionKinds = /** @type {const} */ ({\n  grapheme_boundary: 'grapheme_boundary',\n  line_end: 'line_end',\n  line_start: 'line_start',\n  search_start: 'search_start',\n  string_end: 'string_end',\n  string_end_newline: 'string_end_newline',\n  string_start: 'string_start',\n  word_boundary: 'word_boundary',\n});\n\nconst NodeCharacterClassKinds = /** @type {const} */ ({\n  union: 'union',\n  intersection: 'intersection',\n});\n\n// Identical values\nconst NodeCharacterSetKinds = TokenCharacterSetKinds;\nconst NodeDirectiveKinds = TokenDirectiveKinds;\nconst NodeQuantifierKinds = TokenQuantifierKinds;\n\nconst NodeLookaroundAssertionKinds = /** @type {const} */ ({\n  lookahead: 'lookahead',\n  lookbehind: 'lookbehind',\n});\n\n/**\n@param {string} pattern Oniguruma pattern.\n@param {{\n  flags?: string;\n  normalizeUnknownPropertyNames?: boolean;\n  rules?: {\n    captureGroup?: boolean;\n    singleline?: boolean;\n  };\n  skipBackrefValidation?: boolean;\n  skipLookbehindValidation?: boolean;\n  skipPropertyNameValidation?: boolean;\n  unicodePropertyMap?: Map<string, string>?;\n}} [options]\n@returns {OnigurumaAst}\n*/\nfunction parse(pattern, options = {}) {\n  const opts = {\n    flags: '',\n    normalizeUnknownPropertyNames: false,\n    skipBackrefValidation: false,\n    skipLookbehindValidation: false,\n    skipPropertyNameValidation: false,\n    unicodePropertyMap: null,\n    ...options,\n    rules: {\n      captureGroup: false, // `ONIG_OPTION_CAPTURE_GROUP`\n      singleline: false, // `ONIG_OPTION_SINGLELINE`\n      ...options.rules,\n    },\n  };\n  const tokenized = tokenize(pattern, {\n    // Limit to the tokenizer's options\n    flags: opts.flags,\n    rules: {\n      captureGroup: opts.rules.captureGroup,\n      singleline: opts.rules.singleline,\n    },\n  });\n  const context = {\n    capturingGroups: [],\n    current: 0,\n    hasNumberedRef: false,\n    namedGroupsByName: new Map(),\n    normalizeUnknownPropertyNames: opts.normalizeUnknownPropertyNames,\n    parent: null,\n    skipBackrefValidation: opts.skipBackrefValidation,\n    skipLookbehindValidation: opts.skipLookbehindValidation,\n    skipPropertyNameValidation: opts.skipPropertyNameValidation,\n    subroutines: [],\n    token: null,\n    tokens: tokenized.tokens,\n    unicodePropertyMap: opts.unicodePropertyMap,\n    walk,\n  };\n  function walk(parent, state) {\n    const token = tokenized.tokens[context.current];\n    context.parent = parent;\n    context.token = token;\n    // Advance for the next iteration\n    context.current++;\n    switch (token.type) {\n      case TokenTypes.Alternator:\n        // Top-level only; groups handle their own alternators\n        return createAlternative();\n      case TokenTypes.Assertion:\n        return createAssertionFromToken(token);\n      case TokenTypes.Backreference:\n        return parseBackreference(context);\n      case TokenTypes.Character:\n        return createCharacter(token.value, {useLastValid: !!state.isCheckingRangeEnd});\n      case TokenTypes.CharacterClassHyphen:\n        return parseCharacterClassHyphen(context, state);\n      case TokenTypes.CharacterClassOpen:\n        return parseCharacterClassOpen(context, state);\n      case TokenTypes.CharacterSet:\n        return parseCharacterSet(context);\n      case TokenTypes.Directive:\n        return createDirective(\n          throwIfNot(NodeDirectiveKinds[token.kind], `Unexpected directive kind \"${token.kind}\"`),\n          {flags: token.flags}\n        );\n      case TokenTypes.GroupOpen:\n        return parseGroupOpen(context, state);\n      case TokenTypes.Quantifier:\n        return parseQuantifier(context);\n      case TokenTypes.Subroutine:\n        return parseSubroutine(context);\n      default:\n        throw new Error(`Unexpected token type \"${token.type}\"`);\n    }\n  }\n  const ast = createRegex(createPattern(), createFlags(tokenized.flags));\n  let top = ast.pattern.alternatives[0];\n  while (context.current < tokenized.tokens.length) {\n    const node = walk(top, {});\n    if (node.type === NodeTypes.Alternative) {\n      ast.pattern.alternatives.push(node);\n      top = node;\n    } else {\n      top.elements.push(node);\n    }\n  }\n  // `context` updated by preceding `walk` loop\n  const {capturingGroups, hasNumberedRef, namedGroupsByName, subroutines} = context;\n  // Validation that requires knowledge about the complete pattern\n  if (hasNumberedRef && namedGroupsByName.size && !opts.rules.captureGroup) {\n    throw new Error('Numbered backref/subroutine not allowed when using named capture');\n  }\n  for (const {ref} of subroutines) {\n    if (typeof ref === 'number') {\n      // Relative nums are already resolved\n      if (ref > capturingGroups.length) {\n        throw new Error(`Subroutine uses a group number that's not defined`);\n      }\n    } else if (!namedGroupsByName.has(ref)) {\n      throw new Error(r`Subroutine uses a group name that's not defined \"\\g<${ref}>\"`);\n    } else if (namedGroupsByName.get(ref).length > 1) {\n      throw new Error(r`Subroutine uses a duplicate group name \"\\g<${ref}>\"`);\n    }\n  }\n  return ast;\n}\n\n// Supported (if the backref appears to the right of the reffed capture's opening paren):\n// - `\\k<name>`, `\\k'name'`\n// - When named capture not used:\n//   - `\\n`, `\\nn`, `\\nnn`\n//   - `\\k<n>`, `\\k'n'\n//   - `\\k<-n>`, `\\k'-n'`\n// Unsupported:\n// - `\\k<+n>`, `\\k'+n'` - Note that, Unlike Oniguruma, Onigmo doesn't support this as special\n//   syntax and therefore considers it a valid group name.\n// - Backref with recursion level (with num or name): `\\k<n+level>`, `\\k<n-level>`, etc.\n//   (Onigmo also supports `\\k<-n+level>`, `\\k<-n-level>`, etc.)\n// Backrefs in Onig use multiplexing for duplicate group names (the rules can be complicated when\n// overlapping with subroutines), but a `Backreference`'s simple `ref` prop doesn't capture these\n// details so multiplexed ref pointers need to be derived when working with the AST\nfunction parseBackreference(context) {\n  const {raw} = context.token;\n  const hasKWrapper = /^\\\\k[<']/.test(raw);\n  const ref = hasKWrapper ? raw.slice(3, -1) : raw.slice(1);\n  const fromNum = (num, isRelative = false) => {\n    const numCapturesToLeft = context.capturingGroups.length;\n    let orphan = false;\n    // Note: It's not an error for numbered backrefs to come before their referenced group in Onig,\n    // but an error is the best path for this library because:\n    // 1. Most placements are mistakes and can never match (based on the Onig behavior for backrefs\n    //    to nonparticipating groups).\n    // 2. Erroring matches the behavior of named backrefs.\n    // 3. The edge cases where they're matchable rely on rules for backref resetting within\n    //    quantified groups that are different in JS and aren't emulatable. Note that it's not a\n    //    backref in the first place if using `\\10` or higher and not as many capturing groups are\n    //    defined to the left (it's an octal or identity escape).\n    // [TODO] Ideally this would be refactored to include the backref in the AST when it's not an\n    // error in Onig (due to the reffed group being defined to the right), and the error handling\n    // would move to the `oniguruma-to-es` transformer\n    if (num > numCapturesToLeft) {\n      // [WARNING] Skipping the error breaks assumptions and might create edge case issues, since\n      // backrefs are required to come after their captures; unfortunately this option is needed\n      // for TextMate grammars\n      if (context.skipBackrefValidation) {\n        orphan = true;\n      } else {\n        throw new Error(`Not enough capturing groups defined to the left \"${raw}\"`);\n      }\n    }\n    context.hasNumberedRef = true;\n    return createBackreference(isRelative ? numCapturesToLeft + 1 - num : num, {orphan});\n  };\n  if (hasKWrapper) {\n    const numberedRef = /^(?<sign>-?)0*(?<num>[1-9]\\d*)$/.exec(ref);\n    if (numberedRef) {\n      return fromNum(+numberedRef.groups.num, !!numberedRef.groups.sign);\n    }\n    // Invalid in a backref name even when valid in a group name\n    if (/[-+]/.test(ref)) {\n      throw new Error(`Invalid backref name \"${raw}\"`);\n    }\n    if (!context.namedGroupsByName.has(ref)) {\n      throw new Error(`Group name not defined to the left \"${raw}\"`);\n    }\n    return createBackreference(ref);\n  }\n  return fromNum(+ref);\n}\n\nfunction parseCharacterClassHyphen(context, state) {\n  const {parent, tokens, walk} = context;\n  const prevSiblingNode = parent.elements.at(-1);\n  const nextToken = tokens[context.current];\n  if (\n    !state.isCheckingRangeEnd &&\n    prevSiblingNode &&\n    prevSiblingNode.type !== NodeTypes.CharacterClass &&\n    prevSiblingNode.type !== NodeTypes.CharacterClassRange &&\n    nextToken &&\n    nextToken.type !== TokenTypes.CharacterClassOpen &&\n    nextToken.type !== TokenTypes.CharacterClassClose &&\n    nextToken.type !== TokenTypes.CharacterClassIntersector\n  ) {\n    const nextNode = walk(parent, {\n      ...state,\n      isCheckingRangeEnd: true,\n    });\n    if (prevSiblingNode.type === NodeTypes.Character && nextNode.type === NodeTypes.Character) {\n      parent.elements.pop();\n      return createCharacterClassRange(prevSiblingNode, nextNode);\n    }\n    throw new Error('Invalid character class range');\n  }\n  // Literal hyphen\n  return createCharacter(45);\n}\n\nfunction parseCharacterClassOpen(context, state) {\n  const {token, tokens, walk} = context;\n  const firstClassToken = tokens[context.current];\n  const intersections = [createCharacterClass()];\n  let nextToken = throwIfUnclosedCharacterClass(firstClassToken);\n  while (nextToken.type !== TokenTypes.CharacterClassClose) {\n    if (nextToken.type === TokenTypes.CharacterClassIntersector) {\n      intersections.push(createCharacterClass());\n      // Skip the intersector\n      context.current++;\n    } else {\n      const cc = intersections.at(-1);\n      cc.elements.push(walk(cc, state));\n    }\n    nextToken = throwIfUnclosedCharacterClass(tokens[context.current], firstClassToken);\n  }\n  const node = createCharacterClass({negate: token.negate});\n  if (intersections.length === 1) {\n    node.elements = intersections[0].elements;\n  } else {\n    node.kind = NodeCharacterClassKinds.intersection;\n    node.elements = intersections.map(cc => cc.elements.length === 1 ? cc.elements[0] : cc);\n  }\n  // Skip the closing square bracket\n  context.current++;\n  return node;\n}\n\nfunction parseCharacterSet({token, normalizeUnknownPropertyNames, skipPropertyNameValidation, unicodePropertyMap}) {\n  let {kind, negate, value} = token;\n  if (kind === TokenCharacterSetKinds.property) {\n    const normalized = slug(value);\n    // Don't treat as POSIX if it's in the provided list of Unicode property names\n    if (PosixClassNames.has(normalized) && !unicodePropertyMap?.has(normalized)) {\n      kind = TokenCharacterSetKinds.posix;\n      value = normalized;\n    } else {\n      return createUnicodeProperty(value, {\n        negate,\n        normalizeUnknownPropertyNames,\n        skipPropertyNameValidation,\n        unicodePropertyMap,\n      });\n    }\n  }\n  if (kind === TokenCharacterSetKinds.posix) {\n    return createPosixClass(value, {negate});\n  }\n  return createCharacterSet(kind, {negate});\n}\n\nfunction parseGroupOpen(context, state) {\n  const {token, tokens, capturingGroups, namedGroupsByName, skipLookbehindValidation, walk} = context;\n  let node = createByGroupKind(token);\n  const isAbsentFunction = node.type === NodeTypes.AbsentFunction;\n  const isLookbehind = node.kind === NodeLookaroundAssertionKinds.lookbehind;\n  const isNegLookbehind = isLookbehind && node.negate;\n  // Track capturing group details for backrefs and subroutines (before parsing the group's\n  // contents so nested groups with the same name are tracked in order)\n  if (node.type === NodeTypes.CapturingGroup) {\n    capturingGroups.push(node);\n    if (node.name) {\n      getOrInsert(namedGroupsByName, node.name, []).push(node);\n    }\n  }\n  // Don't allow nested absent functions\n  if (isAbsentFunction && state.isInAbsentFunction) {\n    // Is officially unsupported in Onig but doesn't throw, gives strange results\n    throw new Error('Nested absent function not supported by Oniguruma');\n  }\n  let nextToken = throwIfUnclosedGroup(tokens[context.current]);\n  while (nextToken.type !== TokenTypes.GroupClose) {\n    if (nextToken.type === TokenTypes.Alternator) {\n      node.alternatives.push(createAlternative());\n      // Skip the alternator\n      context.current++;\n    } else {\n      const alt = node.alternatives.at(-1);\n      const child = walk(alt, {\n        ...state,\n        isInAbsentFunction: state.isInAbsentFunction || isAbsentFunction,\n        isInLookbehind: state.isInLookbehind || isLookbehind,\n        isInNegLookbehind: state.isInNegLookbehind || isNegLookbehind,\n      });\n      alt.elements.push(child);\n      // Centralized validation of lookbehind contents\n      if ((isLookbehind || state.isInLookbehind) && !skipLookbehindValidation) {\n        // JS supports all features within lookbehind, but Onig doesn't. Absent functions of form\n        // `(?~|)` and `(?~|\u2026)` are also invalid in lookbehind (the `(?~\u2026)` and `(?~|\u2026|\u2026)` forms\n        // are allowed), but all forms with `(?~|` throw since they aren't yet supported\n        const msg = 'Lookbehind includes a pattern not allowed by Oniguruma';\n        if (isNegLookbehind || state.isInNegLookbehind) {\n          // - Invalid: `(?=\u2026)`, `(?!\u2026)`, capturing groups\n          // - Valid: `(?<=\u2026)`, `(?<!\u2026)`\n          if (\n            child.kind === NodeLookaroundAssertionKinds.lookahead ||\n            child.type === NodeTypes.CapturingGroup\n          ) {\n            throw new Error(msg);\n          }\n        } else {\n          // - Invalid: `(?=\u2026)`, `(?!\u2026)`, `(?<!\u2026)`\n          // - Valid: `(?<=\u2026)`, capturing groups\n          if (\n            child.kind === NodeLookaroundAssertionKinds.lookahead ||\n            (child.kind === NodeLookaroundAssertionKinds.lookbehind && child.negate)\n          ) {\n            throw new Error(msg);\n          }\n        }\n      }\n    }\n    nextToken = throwIfUnclosedGroup(tokens[context.current]);\n  }\n  // Skip the closing parenthesis\n  context.current++;\n  return node;\n}\n\nfunction parseQuantifier({token, parent}) {\n  const {min, max, kind} = token;\n  const quantifiedNode = parent.elements.at(-1);\n  if (\n    !quantifiedNode ||\n    quantifiedNode.type === NodeTypes.Assertion ||\n    quantifiedNode.type === NodeTypes.Directive ||\n    quantifiedNode.type === NodeTypes.LookaroundAssertion\n  ) {\n    throw new Error(`Quantifier requires a repeatable token`);\n  }\n  const node = createQuantifier(\n    quantifiedNode,\n    min,\n    max,\n    throwIfNot(NodeQuantifierKinds[kind], `Unexpected quantifier kind \"${kind}\"`)\n  );\n  parent.elements.pop();\n  return node;\n}\n\n// Onig subroutine behavior:\n// - Subroutines can appear before the groups they reference; ex: `\\g<1>(a)` is valid.\n// - Multiple subroutines can reference the same group.\n// - Subroutines can reference groups that themselves contain subroutines, followed to any depth.\n// - Subroutines can be used recursively, and `\\g<0>` recursively references the whole pattern.\n// - Subroutines can use relative references (backward or forward); ex: `\\g<+1>(.)\\g<-1>`.\n// - Subroutines don't get their own capturing group numbers; ex: `(.)\\g<1>\\2` is invalid.\n// - Subroutines use the flags that apply to their referenced group, so e.g.\n//   `(?-i)(?<a>a)(?i)\\g<a>` is fully case sensitive.\n// - Differences from PCRE/Perl/Regex+ subroutines:\n//   - Subroutines can't reference duplicate group names (though duplicate names are valid if no\n//     subroutines reference them).\n//   - Subroutines can't use absolute or relative numbers if named capture is used anywhere.\n//   - Named backrefs must be to the right of their group definition, so the backref in\n//     `\\g<a>\\k<a>(?<a>)` is invalid (not directly related to subroutines).\n//   - Subroutines don't restore capturing group match values (for backrefs) upon exit, so e.g.\n//     `(?<a>(?<b>[ab]))\\g<a>\\k<b>` matches `abb` but not `aba`; same for numbered.\n// The interaction of backref multiplexing (an Onig-specific feature) and subroutines is complex:\n// - Only the most recent value matched by a capturing group and its subroutines is considered for\n//   backref multiplexing, and this also applies to capturing groups nested within a group that's\n//   referenced by a subroutine.\n// - Although a subroutine can't reference a group with a duplicate name, it can reference a group\n//   with a nested capture whose name is duplicated (e.g. outside of the referenced group).\n//   - These duplicate names can then multiplex; but only the most recent value matched from within\n//     the outer group (or the subroutines that reference it) is available for multiplexing.\n//   - Ex: With `(?<a>(?<b>[123]))\\g<a>\\g<a>(?<b>0)\\k<b>`, the backref `\\k<b>` can only match `0`\n//     or whatever was matched by the most recently matched subroutine. If you took out `(?<b>0)`,\n//     no multiplexing would occur.\nfunction parseSubroutine(context) {\n  const {token, capturingGroups, subroutines} = context;\n  let ref = token.raw.slice(3, -1);\n  const numberedRef = /^(?<sign>[-+]?)0*(?<num>[1-9]\\d*)$/.exec(ref);\n  if (numberedRef) {\n    const num = +numberedRef.groups.num;\n    const numCapturesToLeft = capturingGroups.length;\n    context.hasNumberedRef = true;\n    ref = {\n      '': num,\n      '+': numCapturesToLeft + num,\n      '-': numCapturesToLeft + 1 - num,\n    }[numberedRef.groups.sign];\n    if (ref < 1) {\n      throw new Error('Invalid subroutine number');\n    }\n  // Special case for full-pattern recursion; can't be `+0`, `-0`, `00`, etc.\n  } else if (ref === '0') {\n    ref = 0;\n  }\n  const node = createSubroutine(ref);\n  subroutines.push(node);\n  return node;\n}\n\n/**\n@typedef {{\n  type: 'AbsentFunction';\n  kind: keyof NodeAbsentFunctionKinds;\n  alternatives: Array<AlternativeNode>;\n}} AbsentFunctionNode\n*/\n/**\n@param {keyof NodeAbsentFunctionKinds} kind\n@returns {AbsentFunctionNode}\n*/\nfunction createAbsentFunction(kind) {\n  if (kind !== NodeAbsentFunctionKinds.repeater) {\n    throw new Error(`Unexpected absent function kind \"${kind}\"`);\n  }\n  return {\n    type: NodeTypes.AbsentFunction,\n    kind,\n    alternatives: [createAlternative()],\n  };\n}\n\n/**\n@typedef {{\n  type: 'Alternative';\n  elements: Array<AlternativeElementNode>;\n}} AlternativeNode\n*/\n/**\n@returns {AlternativeNode}\n*/\nfunction createAlternative() {\n  return {\n    type: NodeTypes.Alternative,\n    elements: [],\n  };\n}\n\n/**\n@typedef {{\n  type: 'Assertion';\n  kind: keyof NodeAssertionKinds;\n  negate?: boolean;\n}} AssertionNode\n*/\n/**\n@param {keyof NodeAssertionKinds} kind\n@param {{\n  negate?: boolean;\n}} [options]\n@returns {AssertionNode}\n*/\nfunction createAssertion(kind, options) {\n  const node = {\n    type: NodeTypes.Assertion,\n    kind,\n  };\n  if (kind === NodeAssertionKinds.word_boundary || kind === NodeAssertionKinds.grapheme_boundary) {\n    node.negate = !!options?.negate;\n  }\n  return node;\n}\n\nfunction createAssertionFromToken({kind}) {\n  return createAssertion(\n    throwIfNot({\n      '^': NodeAssertionKinds.line_start,\n      '$': NodeAssertionKinds.line_end,\n      '\\\\A': NodeAssertionKinds.string_start,\n      '\\\\b': NodeAssertionKinds.word_boundary,\n      '\\\\B': NodeAssertionKinds.word_boundary,\n      '\\\\G': NodeAssertionKinds.search_start,\n      '\\\\y': NodeAssertionKinds.grapheme_boundary,\n      '\\\\Y': NodeAssertionKinds.grapheme_boundary,\n      '\\\\z': NodeAssertionKinds.string_end,\n      '\\\\Z': NodeAssertionKinds.string_end_newline,\n    }[kind], `Unexpected assertion kind \"${kind}\"`),\n    {negate: kind === r`\\B` || kind === r`\\Y`}\n  );\n}\n\n/**\n@typedef {{\n  type: 'Backreference';\n  ref: string | number;\n  orphan?: boolean;\n}} BackreferenceNode\n*/\n/**\n@param {string | number} ref\n@param {{\n  orphan?: boolean;\n}} [options]\n@returns {BackreferenceNode}\n*/\nfunction createBackreference(ref, options) {\n  const orphan = !!options?.orphan;\n  return {\n    type: NodeTypes.Backreference,\n    ref,\n    ...(orphan && {orphan}),\n  };\n}\n\nfunction createByGroupKind({flags, kind, name, negate, number}) {\n  switch (kind) {\n    case TokenGroupKinds.absent_repeater:\n      return createAbsentFunction(NodeAbsentFunctionKinds.repeater);\n    case TokenGroupKinds.atomic:\n      return createGroup({atomic: true});\n    case TokenGroupKinds.capturing:\n      return createCapturingGroup(number, name);\n    case TokenGroupKinds.group:\n      return createGroup({flags});\n    case TokenGroupKinds.lookahead:\n    case TokenGroupKinds.lookbehind:\n      return createLookaroundAssertion({\n        behind: kind === TokenGroupKinds.lookbehind,\n        negate,\n      });\n    default:\n      throw new Error(`Unexpected group kind \"${kind}\"`);\n  }\n}\n\n/**\n@typedef {{\n  type: 'CapturingGroup';\n  number: number;\n  name?: string;\n  alternatives: Array<AlternativeNode>;\n}} CapturingGroupNode\n*/\n/**\n@param {number} number\n@param {string} [name]\n@returns {CapturingGroupNode}\n*/\nfunction createCapturingGroup(number, name) {\n  const hasName = name !== undefined;\n  if (hasName && !isValidGroupName(name)) {\n    throw new Error(`Group name \"${name}\" invalid in Oniguruma`);\n  }\n  return {\n    type: NodeTypes.CapturingGroup,\n    number,\n    ...(hasName && {name}),\n    alternatives: [createAlternative()],\n  };\n}\n\n/**\n@typedef {{\n  type: 'Character';\n  value: number;\n}} CharacterNode\n*/\n/**\n@param {number} charCode\n@param {{\n  useLastValid?: boolean;\n}} [options]\n@returns {CharacterNode}\n*/\nfunction createCharacter(charCode, options) {\n  const opts = {\n    useLastValid: false,\n    ...options,\n  };\n  if (charCode > 0x10FFFF) {\n    const hex = charCode.toString(16);\n    if (opts.useLastValid) {\n      charCode = 0x10FFFF;\n    } else if (charCode > 0x13FFFF) {\n      throw new Error(`Invalid code point out of range \"\\\\x{${hex}}\"`);\n    } else {\n      throw new Error(`Invalid code point out of range in JS \"\\\\x{${hex}}\"`);\n    }\n  }\n  return {\n    type: NodeTypes.Character,\n    value: charCode,\n  };\n}\n\n/**\n@typedef {{\n  type: 'CharacterClass';\n  kind: keyof NodeCharacterClassKinds;\n  negate: boolean;\n  elements: Array<CharacterClassElementNode>;\n}} CharacterClassNode\n*/\n/**\n@param {{\n  kind?: keyof NodeCharacterClassKinds;\n  negate?: boolean;\n}} [options]\n@returns {CharacterClassNode}\n*/\nfunction createCharacterClass(options) {\n  const opts = {\n    kind: NodeCharacterClassKinds.union,\n    negate: false,\n    ...options,\n  };\n  return {\n    type: NodeTypes.CharacterClass,\n    kind: opts.kind,\n    negate: opts.negate,\n    elements: [],\n  };\n}\n\n/**\n@typedef {{\n  type: 'CharacterClassRange';\n  min: CharacterNode;\n  max: CharacterNode;\n}} CharacterClassRangeNode\n*/\n/**\n@param {CharacterNode} min\n@param {CharacterNode} max\n@returns {CharacterClassRangeNode}\n*/\nfunction createCharacterClassRange(min, max) {\n  if (max.value < min.value) {\n    throw new Error('Character class range out of order');\n  }\n  return {\n    type: NodeTypes.CharacterClassRange,\n    min,\n    max,\n  };\n}\n\n/**\n@typedef {{\n  type: 'CharacterSet';\n  kind: keyof NodeCharacterSetKinds;\n  value?: string;\n  negate?: boolean;\n  variableLength?: boolean;\n}} CharacterSetNode\n*/\n/**\n@param {keyof Omit<NodeCharacterSetKinds, 'posix' | 'property'>} kind\n@param {{\n  negate?: boolean;\n}} [options]\n@returns {\n  Omit<CharacterSetNode, 'value'> & {\n    kind: keyof Omit<NodeCharacterSetKinds, 'posix' | 'property'>;\n  }\n}\n*/\nfunction createCharacterSet(kind, options) {\n  const negate = !!options?.negate;\n  const node = {\n    type: NodeTypes.CharacterSet,\n    kind: throwIfNot(NodeCharacterSetKinds[kind], `Unexpected character set kind \"${kind}\"`),\n  };\n  if (\n    kind === TokenCharacterSetKinds.digit ||\n    kind === TokenCharacterSetKinds.hex ||\n    kind === TokenCharacterSetKinds.newline ||\n    kind === TokenCharacterSetKinds.space ||\n    kind === TokenCharacterSetKinds.word\n  ) {\n    node.negate = negate;\n  }\n  if (\n    kind === TokenCharacterSetKinds.grapheme ||\n    (kind === TokenCharacterSetKinds.newline && !negate)\n  ) {\n    node.variableLength = true;\n  }\n  return node;\n}\n\n/**\n@typedef {{\n  type: 'Directive';\n  kind: keyof NodeDirectiveKinds;\n  flags?: FlagGroupModifiers;\n}} DirectiveNode\n*/\n/**\n@param {keyof NodeDirectiveKinds} kind\n@param {{\n  flags?: FlagGroupModifiers;\n}} [options]\n@returns {DirectiveNode}\n*/\nfunction createDirective(kind, options) {\n  const node = {\n    type: NodeTypes.Directive,\n    kind,\n  };\n  // Can't optimize by simply creating a `Group` with a `flags` prop and wrapping the remainder of\n  // the open group or pattern in it, because the flag modifier's effect might extend across\n  // alternation. Ex: `a(?i)b|c` is equivalent to `a(?i:b)|(?i:c)`, not `a(?i:b|c)`\n  if (kind === NodeDirectiveKinds.flags) {\n    node.flags = options.flags;\n  }\n  return node;\n}\n\n/**\n@typedef {{\n  type: 'Flags';\n} & import('../tokenizer/tokenize.js').RegexFlags} FlagsNode\n*/\n/**\n@param {import('../tokenizer/tokenize.js').RegexFlags} flags\n@returns {FlagsNode}\n*/\nfunction createFlags(flags) {\n  return {\n    type: NodeTypes.Flags,\n    ...flags,\n  };\n}\n\n/**\n@typedef {{\n  enable?: import('../tokenizer/tokenize.js').FlagGroupSwitches;\n  disable?: import('../tokenizer/tokenize.js').FlagGroupSwitches;\n}} FlagGroupModifiers\n@typedef {{\n  type: 'Group';\n  atomic?: boolean;\n  flags?: FlagGroupModifiers;\n  alternatives: Array<AlternativeNode>;\n}} GroupNode\n*/\n/**\n@param {{\n  atomic?: boolean;\n  flags?: FlagGroupModifiers;\n}} [options]\n@returns {GroupNode}\n*/\nfunction createGroup(options) {\n  const atomic = options?.atomic;\n  const flags = options?.flags;\n  return {\n    type: NodeTypes.Group,\n    ...(atomic && {atomic}),\n    ...(flags && {flags}),\n    alternatives: [createAlternative()],\n  };\n}\n\n/**\n@typedef {{\n  type: 'LookaroundAssertion';\n  kind: keyof NodeLookaroundAssertionKinds;\n  negate: boolean;\n  alternatives: Array<AlternativeNode>;\n}} LookaroundAssertionNode\n*/\n/**\n@param {{\n  behind?: boolean;\n  negate?: boolean;\n}} [options]\n@returns {LookaroundAssertionNode}\n*/\nfunction createLookaroundAssertion(options) {\n  const opts = {\n    behind: false,\n    negate: false,\n    ...options,\n  };\n  return {\n    type: NodeTypes.LookaroundAssertion,\n    kind: opts.behind ? NodeLookaroundAssertionKinds.lookbehind : NodeLookaroundAssertionKinds.lookahead,\n    negate: opts.negate,\n    alternatives: [createAlternative()],\n  };\n}\n\n/**\n@typedef {{\n  type: 'Pattern';\n  alternatives: Array<AlternativeNode>;\n}} PatternNode\n*/\n/**\n@returns {PatternNode}\n*/\nfunction createPattern() {\n  return {\n    type: NodeTypes.Pattern,\n    alternatives: [createAlternative()],\n  };\n}\n\n/**\n@param {string} name\n@param {{\n  negate?: boolean;\n}} [options]\n@returns {\n  CharacterSetNode & {\n    kind: 'posix';\n    value: string;\n    negate: boolean;\n  }\n}\n*/\nfunction createPosixClass(name, options) {\n  const negate = !!options?.negate;\n  if (!PosixClassNames.has(name)) {\n    throw new Error(`Invalid POSIX class \"${name}\"`);\n  }\n  return {\n    type: NodeTypes.CharacterSet,\n    kind: NodeCharacterSetKinds.posix,\n    value: name,\n    negate,\n  };\n}\n\n/**\n@typedef {{\n  type: 'Quantifier';\n  min: number;\n  max: number;\n  kind: keyof NodeQuantifierKinds;\n  element: QuantifiableNode;\n}} QuantifierNode\n*/\n/**\n@param {QuantifiableNode} element\n@param {number} min\n@param {number} max\n@param {keyof NodeQuantifierKinds} [kind]\n@returns {QuantifierNode}\n*/\nfunction createQuantifier(element, min, max, kind = NodeQuantifierKinds.greedy) {\n  const node = {\n    type: NodeTypes.Quantifier,\n    min,\n    max,\n    kind,\n    element,\n  };\n  if (max < min) {\n    return {\n      ...node,\n      min: max,\n      max: min,\n      kind: NodeQuantifierKinds.possessive,\n    };\n  }\n  return node;\n}\n\n/**\n@typedef {{\n  type: 'Regex';\n  pattern: PatternNode;\n  flags: FlagsNode;\n}} RegexNode\n*/\n/**\n@param {PatternNode} pattern\n@param {FlagsNode} flags\n@returns {RegexNode}\n*/\nfunction createRegex(pattern, flags) {\n  return {\n    type: NodeTypes.Regex,\n    pattern,\n    flags,\n  };\n}\n\n/**\n@typedef {{\n  type: 'Subroutine';\n  ref: string | number;\n}} SubroutineNode\n*/\n/**\n@param {string | number} ref\n@returns {SubroutineNode}\n*/\nfunction createSubroutine(ref) {\n  return {\n    type: NodeTypes.Subroutine,\n    ref,\n  };\n}\n\n/**\n@param {string} name\n@param {{\n  negate?: boolean;\n  normalizeUnknownPropertyNames?: boolean;\n  skipPropertyNameValidation?: boolean;\n  unicodePropertyMap?: Map<string, string>?;\n}} [options]\n@returns {\n  CharacterSetNode & {\n    kind: 'property';\n    value: string;\n    negate: boolean;\n  }\n}\n*/\nfunction createUnicodeProperty(name, options) {\n  const opts = {\n    negate: false,\n    normalizeUnknownPropertyNames: false,\n    skipPropertyNameValidation: false,\n    unicodePropertyMap: null,\n    ...options,\n  };\n  let normalized = opts.unicodePropertyMap?.get(slug(name));\n  if (!normalized) {\n    if (opts.normalizeUnknownPropertyNames) {\n      normalized = normalizeUnicodePropertyName(name);\n    // Let the name through as-is if no map provided and normalization not requested\n    } else if (opts.unicodePropertyMap && !opts.skipPropertyNameValidation) {\n      throw new Error(r`Invalid Unicode property \"\\p{${name}}\"`);\n    }\n  }\n  return {\n    type: NodeTypes.CharacterSet,\n    kind: NodeCharacterSetKinds.property,\n    value: normalized ?? name,\n    negate: opts.negate,\n  }\n}\n\nfunction isValidGroupName(name) {\n  // Note that backrefs and subroutines might contextually use `-` and `+` to indicate relative\n  // index or recursion level\n  return /^[\\p{Alpha}\\p{Pc}][^)]*$/u.test(name);\n}\n\nfunction normalizeUnicodePropertyName(name) {\n  // In Onig, Unicode property names ignore case, spaces, hyphens, and underscores. Use best effort\n  // to reformat the name to follow official values (covers a lot, but isn't able to map for all\n  // possible formatting differences)\n  return name.\n    trim().\n    replace(/[- _]+/g, '_').\n    replace(/[A-Z][a-z]+(?=[A-Z])/g, '$&_'). // `PropertyName` to `Property_Name`\n    replace(/[A-Za-z]+/g, m => m[0].toUpperCase() + m.slice(1).toLowerCase());\n}\n\n/**\nGenerates a Unicode property lookup name: lowercase, without spaces, hyphens, or underscores.\n@param {string} name Unicode property name.\n@returns {string}\n*/\nfunction slug(name) {\n  return name.replace(/[- _]+/g, '').toLowerCase();\n}\n\nfunction throwIfUnclosedCharacterClass(token, firstClassToken) {\n  return throwIfNot(\n    token,\n    // Easier to understand error when applicable\n    `${firstClassToken?.value === 93 ? 'Empty' : 'Unclosed'} character class`\n  );\n}\n\nfunction throwIfUnclosedGroup(token) {\n  return throwIfNot(token, 'Unclosed group');\n}\n\nexport {\n  createAbsentFunction,\n  createAlternative,\n  createAssertion,\n  createBackreference,\n  createCapturingGroup,\n  createCharacter,\n  createCharacterClass,\n  createCharacterClassRange,\n  createCharacterSet,\n  createDirective,\n  createFlags,\n  createGroup,\n  createLookaroundAssertion,\n  createPattern,\n  createPosixClass,\n  createQuantifier,\n  createRegex,\n  createSubroutine,\n  createUnicodeProperty,\n  NodeAbsentFunctionKinds,\n  NodeAssertionKinds,\n  NodeCharacterClassKinds,\n  NodeCharacterSetKinds,\n  NodeDirectiveKinds,\n  NodeLookaroundAssertionKinds,\n  NodeTypes,\n  NodeQuantifierKinds,\n  parse,\n  slug,\n};\n", "import {slug} from \"./parser/parse.js\";\n\n/**\nAll Unicode properties supported by Oniguruma as of v6.9.10 (Unicode v16.0.0).\nCopied from <github.com/kkos/oniguruma/blob/master/doc/UNICODE_PROPERTIES>\n*/\nconst OnigUnicodePropertyMap = /* @__PURE__ */ new Map(\n`ASCII_Hex_Digit\nAdlam\nAhom\nAlphabetic\nAnatolian_Hieroglyphs\nAny\nArabic\nArmenian\nAssigned\nAvestan\nBalinese\nBamum\nBassa_Vah\nBatak\nBengali\nBhaiksuki\nBidi_Control\nBopomofo\nBrahmi\nBraille\nBuginese\nBuhid\nC\nCanadian_Aboriginal\nCarian\nCase_Ignorable\nCased\nCaucasian_Albanian\nCc\nCf\nChakma\nCham\nChanges_When_Casefolded\nChanges_When_Casemapped\nChanges_When_Lowercased\nChanges_When_Titlecased\nChanges_When_Uppercased\nCherokee\nChorasmian\nCn\nCo\nCommon\nCoptic\nCs\nCuneiform\nCypriot\nCypro_Minoan\nCyrillic\nDash\nDefault_Ignorable_Code_Point\nDeprecated\nDeseret\nDevanagari\nDiacritic\nDives_Akuru\nDogra\nDuployan\nEgyptian_Hieroglyphs\nElbasan\nElymaic\nEmoji\nEmoji_Component\nEmoji_Modifier\nEmoji_Modifier_Base\nEmoji_Presentation\nEthiopic\nExtended_Pictographic\nExtender\nGaray\nGeorgian\nGlagolitic\nGothic\nGrantha\nGrapheme_Base\nGrapheme_Extend\nGrapheme_Link\nGreek\nGujarati\nGunjala_Gondi\nGurmukhi\nGurung_Khema\nHan\nHangul\nHanifi_Rohingya\nHanunoo\nHatran\nHebrew\nHex_Digit\nHiragana\nHyphen\nIDS_Binary_Operator\nIDS_Trinary_Operator\nIDS_Unary_Operator\nID_Compat_Math_Continue\nID_Compat_Math_Start\nID_Continue\nID_Start\nIdeographic\nImperial_Aramaic\nInCB\nInherited\nInscriptional_Pahlavi\nInscriptional_Parthian\nJavanese\nJoin_Control\nKaithi\nKannada\nKatakana\nKawi\nKayah_Li\nKharoshthi\nKhitan_Small_Script\nKhmer\nKhojki\nKhudawadi\nKirat_Rai\nL\nLC\nLao\nLatin\nLepcha\nLimbu\nLinear_A\nLinear_B\nLisu\nLl\nLm\nLo\nLogical_Order_Exception\nLowercase\nLt\nLu\nLycian\nLydian\nM\nMahajani\nMakasar\nMalayalam\nMandaic\nManichaean\nMarchen\nMasaram_Gondi\nMath\nMc\nMe\nMedefaidrin\nMeetei_Mayek\nMende_Kikakui\nMeroitic_Cursive\nMeroitic_Hieroglyphs\nMiao\nMn\nModi\nModifier_Combining_Mark\nMongolian\nMro\nMultani\nMyanmar\nN\nNabataean\nNag_Mundari\nNandinagari\nNd\nNew_Tai_Lue\nNewa\nNko\nNl\nNo\nNoncharacter_Code_Point\nNushu\nNyiakeng_Puachue_Hmong\nOgham\nOl_Chiki\nOl_Onal\nOld_Hungarian\nOld_Italic\nOld_North_Arabian\nOld_Permic\nOld_Persian\nOld_Sogdian\nOld_South_Arabian\nOld_Turkic\nOld_Uyghur\nOriya\nOsage\nOsmanya\nOther_Alphabetic\nOther_Default_Ignorable_Code_Point\nOther_Grapheme_Extend\nOther_ID_Continue\nOther_ID_Start\nOther_Lowercase\nOther_Math\nOther_Uppercase\nP\nPahawh_Hmong\nPalmyrene\nPattern_Syntax\nPattern_White_Space\nPau_Cin_Hau\nPc\nPd\nPe\nPf\nPhags_Pa\nPhoenician\nPi\nPo\nPrepended_Concatenation_Mark\nPs\nPsalter_Pahlavi\nQuotation_Mark\nRadical\nRegional_Indicator\nRejang\nRunic\nS\nSamaritan\nSaurashtra\nSc\nSentence_Terminal\nSharada\nShavian\nSiddham\nSignWriting\nSinhala\nSk\nSm\nSo\nSoft_Dotted\nSogdian\nSora_Sompeng\nSoyombo\nSundanese\nSunuwar\nSyloti_Nagri\nSyriac\nTagalog\nTagbanwa\nTai_Le\nTai_Tham\nTai_Viet\nTakri\nTamil\nTangsa\nTangut\nTelugu\nTerminal_Punctuation\nThaana\nThai\nTibetan\nTifinagh\nTirhuta\nTodhri\nToto\nTulu_Tigalari\nUgaritic\nUnified_Ideograph\nUnknown\nUppercase\nVai\nVariation_Selector\nVithkuqi\nWancho\nWarang_Citi\nWhite_Space\nXID_Continue\nXID_Start\nYezidi\nYi\nZ\nZanabazar_Square\nZl\nZp\nZs\nAdlm\nAghb\nAHex\nArab\nArmi\nArmn\nAvst\nBali\nBamu\nBass\nBatk\nBeng\nBhks\nBidi_C\nBopo\nBrah\nBrai\nBugi\nBuhd\nCakm\nCans\nCari\nCased_Letter\nCher\nChrs\nCI\nClose_Punctuation\nCombining_Mark\nConnector_Punctuation\nControl\nCopt\nCpmn\nCprt\nCurrency_Symbol\nCWCF\nCWCM\nCWL\nCWT\nCWU\nCyrl\nDash_Punctuation\nDecimal_Number\nDep\nDeva\nDI\nDia\nDiak\nDogr\nDsrt\nDupl\nEBase\nEComp\nEgyp\nElba\nElym\nEMod\nEnclosing_Mark\nEPres\nEthi\nExt\nExtPict\nFinal_Punctuation\nFormat\nGara\nGeor\nGlag\nGong\nGonm\nGoth\nGran\nGr_Base\nGrek\nGr_Ext\nGr_Link\nGujr\nGukh\nGuru\nHang\nHani\nHano\nHatr\nHebr\nHex\nHira\nHluw\nHmng\nHmnp\nHung\nIDC\nIdeo\nIDS\nIDSB\nIDST\nIDSU\nInitial_Punctuation\nItal\nJava\nJoin_C\nKali\nKana\nKhar\nKhmr\nKhoj\nKits\nKnda\nKrai\nKthi\nLana\nLaoo\nLatn\nLepc\nLetter\nLetter_Number\nLimb\nLina\nLinb\nLine_Separator\nLOE\nLowercase_Letter\nLyci\nLydi\nMahj\nMaka\nMand\nMani\nMarc\nMark\nMath_Symbol\nMCM\nMedf\nMend\nMerc\nMero\nMlym\nModifier_Letter\nModifier_Symbol\nMong\nMroo\nMtei\nMult\nMymr\nNagm\nNand\nNarb\nNbat\nNChar\nNkoo\nNonspacing_Mark\nNshu\nNumber\nOAlpha\nODI\nOgam\nOGr_Ext\nOIDC\nOIDS\nOlck\nOLower\nOMath\nOnao\nOpen_Punctuation\nOrkh\nOrya\nOsge\nOsma\nOther\nOther_Letter\nOther_Number\nOther_Punctuation\nOther_Symbol\nOugr\nOUpper\nPalm\nParagraph_Separator\nPat_Syn\nPat_WS\nPauc\nPCM\nPerm\nPhag\nPhli\nPhlp\nPhnx\nPlrd\nPrivate_Use\nPrti\npunct\nPunctuation\nQaac\nQaai\nQMark\nRI\nRjng\nRohg\nRunr\nSamr\nSarb\nSaur\nSD\nSeparator\nSgnw\nShaw\nShrd\nSidd\nSind\nSinh\nSogd\nSogo\nSora\nSoyo\nSpace_Separator\nSpacing_Mark\nSTerm\nSund\nSunu\nSurrogate\nSylo\nSymbol\nSyrc\nTagb\nTakr\nTale\nTalu\nTaml\nTang\nTavt\nTelu\nTerm\nTfng\nTglg\nThaa\nTibt\nTirh\nTitlecase_Letter\nTnsa\nTodr\nTutg\nUgar\nUIdeo\nUnassigned\nUppercase_Letter\nVaii\nVith\nVS\nWara\nWcho\nWSpace\nXIDC\nXIDS\nXpeo\nXsux\nYezi\nYiii\nZanb\nZinh\nZyyy\nZzzz\nIn_Basic_Latin\nIn_Latin_1_Supplement\nIn_Latin_Extended_A\nIn_Latin_Extended_B\nIn_IPA_Extensions\nIn_Spacing_Modifier_Letters\nIn_Combining_Diacritical_Marks\nIn_Greek_and_Coptic\nIn_Cyrillic\nIn_Cyrillic_Supplement\nIn_Armenian\nIn_Hebrew\nIn_Arabic\nIn_Syriac\nIn_Arabic_Supplement\nIn_Thaana\nIn_NKo\nIn_Samaritan\nIn_Mandaic\nIn_Syriac_Supplement\nIn_Arabic_Extended_B\nIn_Arabic_Extended_A\nIn_Devanagari\nIn_Bengali\nIn_Gurmukhi\nIn_Gujarati\nIn_Oriya\nIn_Tamil\nIn_Telugu\nIn_Kannada\nIn_Malayalam\nIn_Sinhala\nIn_Thai\nIn_Lao\nIn_Tibetan\nIn_Myanmar\nIn_Georgian\nIn_Hangul_Jamo\nIn_Ethiopic\nIn_Ethiopic_Supplement\nIn_Cherokee\nIn_Unified_Canadian_Aboriginal_Syllabics\nIn_Ogham\nIn_Runic\nIn_Tagalog\nIn_Hanunoo\nIn_Buhid\nIn_Tagbanwa\nIn_Khmer\nIn_Mongolian\nIn_Unified_Canadian_Aboriginal_Syllabics_Extended\nIn_Limbu\nIn_Tai_Le\nIn_New_Tai_Lue\nIn_Khmer_Symbols\nIn_Buginese\nIn_Tai_Tham\nIn_Combining_Diacritical_Marks_Extended\nIn_Balinese\nIn_Sundanese\nIn_Batak\nIn_Lepcha\nIn_Ol_Chiki\nIn_Cyrillic_Extended_C\nIn_Georgian_Extended\nIn_Sundanese_Supplement\nIn_Vedic_Extensions\nIn_Phonetic_Extensions\nIn_Phonetic_Extensions_Supplement\nIn_Combining_Diacritical_Marks_Supplement\nIn_Latin_Extended_Additional\nIn_Greek_Extended\nIn_General_Punctuation\nIn_Superscripts_and_Subscripts\nIn_Currency_Symbols\nIn_Combining_Diacritical_Marks_for_Symbols\nIn_Letterlike_Symbols\nIn_Number_Forms\nIn_Arrows\nIn_Mathematical_Operators\nIn_Miscellaneous_Technical\nIn_Control_Pictures\nIn_Optical_Character_Recognition\nIn_Enclosed_Alphanumerics\nIn_Box_Drawing\nIn_Block_Elements\nIn_Geometric_Shapes\nIn_Miscellaneous_Symbols\nIn_Dingbats\nIn_Miscellaneous_Mathematical_Symbols_A\nIn_Supplemental_Arrows_A\nIn_Braille_Patterns\nIn_Supplemental_Arrows_B\nIn_Miscellaneous_Mathematical_Symbols_B\nIn_Supplemental_Mathematical_Operators\nIn_Miscellaneous_Symbols_and_Arrows\nIn_Glagolitic\nIn_Latin_Extended_C\nIn_Coptic\nIn_Georgian_Supplement\nIn_Tifinagh\nIn_Ethiopic_Extended\nIn_Cyrillic_Extended_A\nIn_Supplemental_Punctuation\nIn_CJK_Radicals_Supplement\nIn_Kangxi_Radicals\nIn_Ideographic_Description_Characters\nIn_CJK_Symbols_and_Punctuation\nIn_Hiragana\nIn_Katakana\nIn_Bopomofo\nIn_Hangul_Compatibility_Jamo\nIn_Kanbun\nIn_Bopomofo_Extended\nIn_CJK_Strokes\nIn_Katakana_Phonetic_Extensions\nIn_Enclosed_CJK_Letters_and_Months\nIn_CJK_Compatibility\nIn_CJK_Unified_Ideographs_Extension_A\nIn_Yijing_Hexagram_Symbols\nIn_CJK_Unified_Ideographs\nIn_Yi_Syllables\nIn_Yi_Radicals\nIn_Lisu\nIn_Vai\nIn_Cyrillic_Extended_B\nIn_Bamum\nIn_Modifier_Tone_Letters\nIn_Latin_Extended_D\nIn_Syloti_Nagri\nIn_Common_Indic_Number_Forms\nIn_Phags_pa\nIn_Saurashtra\nIn_Devanagari_Extended\nIn_Kayah_Li\nIn_Rejang\nIn_Hangul_Jamo_Extended_A\nIn_Javanese\nIn_Myanmar_Extended_B\nIn_Cham\nIn_Myanmar_Extended_A\nIn_Tai_Viet\nIn_Meetei_Mayek_Extensions\nIn_Ethiopic_Extended_A\nIn_Latin_Extended_E\nIn_Cherokee_Supplement\nIn_Meetei_Mayek\nIn_Hangul_Syllables\nIn_Hangul_Jamo_Extended_B\nIn_High_Surrogates\nIn_High_Private_Use_Surrogates\nIn_Low_Surrogates\nIn_Private_Use_Area\nIn_CJK_Compatibility_Ideographs\nIn_Alphabetic_Presentation_Forms\nIn_Arabic_Presentation_Forms_A\nIn_Variation_Selectors\nIn_Vertical_Forms\nIn_Combining_Half_Marks\nIn_CJK_Compatibility_Forms\nIn_Small_Form_Variants\nIn_Arabic_Presentation_Forms_B\nIn_Halfwidth_and_Fullwidth_Forms\nIn_Specials\nIn_Linear_B_Syllabary\nIn_Linear_B_Ideograms\nIn_Aegean_Numbers\nIn_Ancient_Greek_Numbers\nIn_Ancient_Symbols\nIn_Phaistos_Disc\nIn_Lycian\nIn_Carian\nIn_Coptic_Epact_Numbers\nIn_Old_Italic\nIn_Gothic\nIn_Old_Permic\nIn_Ugaritic\nIn_Old_Persian\nIn_Deseret\nIn_Shavian\nIn_Osmanya\nIn_Osage\nIn_Elbasan\nIn_Caucasian_Albanian\nIn_Vithkuqi\nIn_Todhri\nIn_Linear_A\nIn_Latin_Extended_F\nIn_Cypriot_Syllabary\nIn_Imperial_Aramaic\nIn_Palmyrene\nIn_Nabataean\nIn_Hatran\nIn_Phoenician\nIn_Lydian\nIn_Meroitic_Hieroglyphs\nIn_Meroitic_Cursive\nIn_Kharoshthi\nIn_Old_South_Arabian\nIn_Old_North_Arabian\nIn_Manichaean\nIn_Avestan\nIn_Inscriptional_Parthian\nIn_Inscriptional_Pahlavi\nIn_Psalter_Pahlavi\nIn_Old_Turkic\nIn_Old_Hungarian\nIn_Hanifi_Rohingya\nIn_Garay\nIn_Rumi_Numeral_Symbols\nIn_Yezidi\nIn_Arabic_Extended_C\nIn_Old_Sogdian\nIn_Sogdian\nIn_Old_Uyghur\nIn_Chorasmian\nIn_Elymaic\nIn_Brahmi\nIn_Kaithi\nIn_Sora_Sompeng\nIn_Chakma\nIn_Mahajani\nIn_Sharada\nIn_Sinhala_Archaic_Numbers\nIn_Khojki\nIn_Multani\nIn_Khudawadi\nIn_Grantha\nIn_Tulu_Tigalari\nIn_Newa\nIn_Tirhuta\nIn_Siddham\nIn_Modi\nIn_Mongolian_Supplement\nIn_Takri\nIn_Myanmar_Extended_C\nIn_Ahom\nIn_Dogra\nIn_Warang_Citi\nIn_Dives_Akuru\nIn_Nandinagari\nIn_Zanabazar_Square\nIn_Soyombo\nIn_Unified_Canadian_Aboriginal_Syllabics_Extended_A\nIn_Pau_Cin_Hau\nIn_Devanagari_Extended_A\nIn_Sunuwar\nIn_Bhaiksuki\nIn_Marchen\nIn_Masaram_Gondi\nIn_Gunjala_Gondi\nIn_Makasar\nIn_Kawi\nIn_Lisu_Supplement\nIn_Tamil_Supplement\nIn_Cuneiform\nIn_Cuneiform_Numbers_and_Punctuation\nIn_Early_Dynastic_Cuneiform\nIn_Cypro_Minoan\nIn_Egyptian_Hieroglyphs\nIn_Egyptian_Hieroglyph_Format_Controls\nIn_Egyptian_Hieroglyphs_Extended_A\nIn_Anatolian_Hieroglyphs\nIn_Gurung_Khema\nIn_Bamum_Supplement\nIn_Mro\nIn_Tangsa\nIn_Bassa_Vah\nIn_Pahawh_Hmong\nIn_Kirat_Rai\nIn_Medefaidrin\nIn_Miao\nIn_Ideographic_Symbols_and_Punctuation\nIn_Tangut\nIn_Tangut_Components\nIn_Khitan_Small_Script\nIn_Tangut_Supplement\nIn_Kana_Extended_B\nIn_Kana_Supplement\nIn_Kana_Extended_A\nIn_Small_Kana_Extension\nIn_Nushu\nIn_Duployan\nIn_Shorthand_Format_Controls\nIn_Symbols_for_Legacy_Computing_Supplement\nIn_Znamenny_Musical_Notation\nIn_Byzantine_Musical_Symbols\nIn_Musical_Symbols\nIn_Ancient_Greek_Musical_Notation\nIn_Kaktovik_Numerals\nIn_Mayan_Numerals\nIn_Tai_Xuan_Jing_Symbols\nIn_Counting_Rod_Numerals\nIn_Mathematical_Alphanumeric_Symbols\nIn_Sutton_SignWriting\nIn_Latin_Extended_G\nIn_Glagolitic_Supplement\nIn_Cyrillic_Extended_D\nIn_Nyiakeng_Puachue_Hmong\nIn_Toto\nIn_Wancho\nIn_Nag_Mundari\nIn_Ol_Onal\nIn_Ethiopic_Extended_B\nIn_Mende_Kikakui\nIn_Adlam\nIn_Indic_Siyaq_Numbers\nIn_Ottoman_Siyaq_Numbers\nIn_Arabic_Mathematical_Alphabetic_Symbols\nIn_Mahjong_Tiles\nIn_Domino_Tiles\nIn_Playing_Cards\nIn_Enclosed_Alphanumeric_Supplement\nIn_Enclosed_Ideographic_Supplement\nIn_Miscellaneous_Symbols_and_Pictographs\nIn_Emoticons\nIn_Ornamental_Dingbats\nIn_Transport_and_Map_Symbols\nIn_Alchemical_Symbols\nIn_Geometric_Shapes_Extended\nIn_Supplemental_Arrows_C\nIn_Supplemental_Symbols_and_Pictographs\nIn_Chess_Symbols\nIn_Symbols_and_Pictographs_Extended_A\nIn_Symbols_for_Legacy_Computing\nIn_CJK_Unified_Ideographs_Extension_B\nIn_CJK_Unified_Ideographs_Extension_C\nIn_CJK_Unified_Ideographs_Extension_D\nIn_CJK_Unified_Ideographs_Extension_E\nIn_CJK_Unified_Ideographs_Extension_F\nIn_CJK_Unified_Ideographs_Extension_I\nIn_CJK_Compatibility_Ideographs_Supplement\nIn_CJK_Unified_Ideographs_Extension_G\nIn_CJK_Unified_Ideographs_Extension_H\nIn_Tags\nIn_Variation_Selectors_Supplement\nIn_Supplementary_Private_Use_Area_A\nIn_Supplementary_Private_Use_Area_B\nIn_No_Block`.\n  split(/\\s/).\n  map(p => [slug(p), p])\n);\n\nexport {\n  OnigUnicodePropertyMap,\n};\n", "import {parse} from './parser/parse.js';\nimport {OnigUnicodePropertyMap} from './unicode.js';\n\n/**\nReturns an Oniguruma AST generated from an Oniguruma pattern.\n@param {string} pattern Oniguruma regex pattern.\n@param {{\n  flags?: string;\n  rules?: {\n    captureGroup?: boolean;\n    singleline?: boolean;\n  };\n}} [options]\n@returns {import('./parser/parse.js').OnigurumaAst}\n*/\nfunction toOnigurumaAst(pattern, options = {}) {\n  if ({}.toString.call(options) !== '[object Object]') {\n    throw new Error('Unexpected options');\n  }\n  return parse(pattern, {\n    // Limit the options that can be passed to the parser\n    flags: options.flags ?? '',\n    rules: {\n      captureGroup: options.rules?.captureGroup ?? false,\n      singleline: options.rules?.singleline ?? false,\n    },\n    unicodePropertyMap: OnigUnicodePropertyMap,\n  });\n}\n\nexport {\n  toOnigurumaAst,\n};\n", "import {NodeAbsentFunctionKinds, NodeAssertionKinds, NodeCharacterClassKinds, NodeCharacterSetKinds, NodeDirectiveKinds, NodeLookaroundAssertionKinds, NodeQuantifierKinds, NodeTypes} from '../parser/parse.js';\nimport {cp, r, throwIfNot} from '../utils.js';\n\n/**\nGenerates a Oniguruma `pattern` and `flags` from an `OnigurumaAst`.\n@param {import('../parser/parse.js').OnigurumaAst} ast\n@returns {{\n  pattern: string;\n  flags: string;\n}}\n*/\nfunction generate(ast) {\n  let lastNode = null;\n  let parent = null;\n  const state = {\n    inCharClass: false,\n    lastNode,\n    parent,\n  };\n  function gen(node) {\n    state.lastNode = lastNode;\n    lastNode = node;\n    if (state.lastNode && getFirstChild(state.lastNode) === node) {\n      state.parent = state.lastNode;\n    }\n    const fn = generator[node.type];\n    if (!fn) {\n      throw new Error(`Unexpected node type \"${node.type}\"`);\n    }\n    return fn(node, state, gen);\n  }\n  return gen(ast);\n}\n\nconst generator = {\n  Regex({pattern, flags}, _, gen) {\n    // Final result is an object; other node types return strings\n    return {\n      pattern: gen(pattern),\n      flags: gen(flags),\n    };\n  },\n\n  AbsentFunction({kind, alternatives}, _, gen) {\n    if (kind !== NodeAbsentFunctionKinds.repeater) {\n      throw new Error(`Unexpected absent function kind \"${kind}\"`);\n    }\n    return `(?~${alternatives.map(gen).join('|')})`;\n  },\n\n  Alternative({elements}, _, gen) {\n    return elements.map(gen).join('');\n  },\n\n  Assertion({kind, negate}) {\n    if (kind === NodeAssertionKinds.grapheme_boundary) {\n      return negate ? r`\\Y` : r`\\y`;\n    }\n    if (kind === NodeAssertionKinds.word_boundary) {\n      return negate ? r`\\B` : r`\\b`;\n    }\n    return throwIfNot({\n      line_end: '$',\n      line_start: '^',\n      search_start: r`\\G`,\n      string_end: r`\\z`,\n      string_end_newline: r`\\Z`,\n      string_start: r`\\A`,\n    }[kind], `Unexpected assertion kind \"${kind}\"`);\n  },\n\n  Backreference({ref}) {\n    if (typeof ref === 'number') {\n      // [TODO] Won't be safe to indiscriminately unenclose when forward backrefs are supported\n      return '\\\\' + ref;\n    }\n    // Onig doesn't allow chars `>` or `'` in backref names, so this is safe\n    return `\\\\k<${ref}>`;\n  },\n\n  CapturingGroup(node, _, gen) {\n    const {name, alternatives} = node;\n    const nameWrapper = name ? `?${name.includes('>') ? `'${name}'` : `<${name}>`}` : '';\n    return `(${nameWrapper}${alternatives.map(gen).join('|')})`;\n  },\n\n  Character({value}, state) {\n    return getCharEscape(value, {\n      escDigit: state.lastNode.type === NodeTypes.Backreference,\n      inCharClass: state.inCharClass,\n    });\n  },\n\n  CharacterClass({kind, negate, elements}, state, gen) {\n    function genClass() {\n      if (\n        state.parent.type === NodeTypes.CharacterClass &&\n        state.parent.kind === NodeCharacterClassKinds.intersection &&\n        kind === NodeCharacterClassKinds.union &&\n        !elements.length\n      ) {\n        // Prevent empty intersection like `[&&]` from becoming the invalid `[[]&&[]]`\n        return '';\n      }\n      return `[${negate ? '^' : ''}${\n        elements.map(gen).join(kind === NodeCharacterClassKinds.intersection ? '&&' : '')\n      }]`;\n    }\n    if (!state.inCharClass) {\n      // For the outermost char class, set state\n      state.inCharClass = true;\n      const result = genClass();\n      state.inCharClass = false;\n      return result;\n    }\n    return genClass();\n  },\n\n  CharacterClassRange({min, max}, _, gen) {\n    return `${gen(min)}-${gen(max)}`;\n  },\n\n  CharacterSet({kind, negate, value}, state) {\n    if (kind === NodeCharacterSetKinds.digit) {\n      return negate ? r`\\D` : r`\\d`;\n    }\n    if (kind === NodeCharacterSetKinds.hex) {\n      return negate ? r`\\H` : r`\\h`;\n    }\n    if (kind === NodeCharacterSetKinds.newline) {\n      return negate ? r`\\N` : r`\\R`;\n    }\n    if (kind === NodeCharacterSetKinds.posix) {\n      return state.inCharClass ?\n        `[:${negate ? '^' : ''}${value}:]` :\n        `${negate ? r`\\P` : r`\\p`}{${value}}`;\n    }\n    if (kind === NodeCharacterSetKinds.property) {\n      return `${negate ? r`\\P` : r`\\p`}{${value}}`;\n    }\n    if (kind === NodeCharacterSetKinds.space) {\n      return negate ? r`\\S` : r`\\s`;\n    }\n    if (kind === NodeCharacterSetKinds.word) {\n      return negate ? r`\\W` : r`\\w`;\n    }\n    return throwIfNot({\n      any: r`\\O`,\n      dot: '.',\n      grapheme: r`\\X`,\n    }[kind], `Unexpected character set kind \"${kind}\"`);\n  },\n\n  Directive({kind, flags}) {\n    if (kind === NodeDirectiveKinds.flags) {\n      const {enable = {}, disable = {}} = flags;\n      const enableStr = getFlagsStr(enable);\n      const disableStr = getFlagsStr(disable);\n      return (enableStr || disableStr) ? `(?${enableStr}${disableStr ? `-${disableStr}` : ''})` : '';\n    }\n    if (kind === NodeDirectiveKinds.keep) {\n      return r`\\K`;\n    }\n    throw new Error(`Unexpected directive kind \"${kind}\"`);\n  },\n\n  Flags(node) {\n    return getFlagsStr(node);\n  },\n\n  Group({atomic, flags, alternatives}, _, gen) {\n    const contents = alternatives.map(gen).join('|');\n    return `(?${getGroupPrefix(atomic, flags)}${contents})`;\n  },\n\n  LookaroundAssertion({kind, negate, alternatives}, _, gen) {\n    const prefix = `${kind === NodeLookaroundAssertionKinds.lookahead ? '' : '<'}${negate ? '!' : '='}`;\n    return `(?${prefix}${alternatives.map(gen).join('|')})`;\n  },\n\n  Pattern({alternatives}, _, gen) {\n    return alternatives.map(gen).join('|');\n  },\n\n  Quantifier({min, max, kind, element}, _, gen) {\n    // These errors shouldn't happen unless the AST is modified in an invalid way after parsing\n    if (min > max) {\n      throw new Error(`Invalid quantifier: min \"${min}\" > max \"${max}\"`);\n    }\n    if (min > 1 && max === Infinity && kind === NodeQuantifierKinds.possessive) {\n      // Onig reversed ranges are possessive but `{,n}` is greedy `{0,n}`, so there's no way to\n      // represent this without adding additional nodes that aren't in the AST\n      throw new Error(`Invalid possessive quantifier: min \"${min}\" with no max\"`);\n    }\n    if (min === max && kind === NodeQuantifierKinds.possessive) {\n      // Can't add a `+` suffix to a fixed `{n}` interval quantifier\n      throw new Error(`Invalid possessive quantifier: min and max are equal \"${min}\"`);\n    }\n    const kidIsGreedyQuantifier = element.type === NodeTypes.Quantifier && element.kind === NodeQuantifierKinds.greedy;\n    let base;\n    let interval = false;\n    if (!min && max === 1 && !kidIsGreedyQuantifier) {\n      base = '?';\n    } else if (!min && max === Infinity) {\n      base = '*';\n    } else if (min === 1 && max === Infinity && !kidIsGreedyQuantifier) {\n      base = '+';\n    } else if (min === max) {\n      base = `{${min}}`;\n      interval = true;\n    } else {\n      base = kind === NodeQuantifierKinds.possessive ?\n        `{${max},${min}}` :\n        `{${min},${max === Infinity ? '' : max}}`;\n      interval = true;\n    }\n    const suffix = {\n      greedy: '',\n      lazy: '?',\n      // Interval quantifiers are marked possessive by reversing their min/max; a `+` suffix would\n      // create a quantifier chain\n      possessive: interval ? '' : '+',\n    }[kind];\n    return `${gen(element)}${base}${suffix}`;\n  },\n\n  Subroutine({ref}) {\n    if (typeof ref === 'string' && ref.includes('>')) {\n      return r`\\g'${ref}'`;\n    }\n    return r`\\g<${ref}>`;\n  },\n};\n\nconst BaseEscapeChars = new Set([\n  '$', '(', ')', '*', '+', '.', '?', '[', '\\\\', '^', '{', '|',\n]);\nconst CharClassEscapeChars = new Set([\n  '&', '-', '[', '\\\\', ']', '^',\n]);\nconst CharCodeEscapeMap = new Map([\n  [ 7, r`\\a`], // bell\n  [ 9, r`\\t`], // horizontal tab\n  [10, r`\\n`], // line feed\n  [11, r`\\v`], // vertical tab\n  [12, r`\\f`], // form feed\n  [13, r`\\r`], // carriage return\n  [27, r`\\e`], // escape\n  [0x2028, r`\\u2028`], // line separator\n  [0x2029, r`\\u2029`], // paragraph separator\n  [0xFEFF, r`\\uFEFF`], // ZWNBSP/BOM\n]);\n\nfunction getCharEscape(codePoint, {escDigit, inCharClass}) {\n  if (CharCodeEscapeMap.has(codePoint)) {\n    return CharCodeEscapeMap.get(codePoint);\n  }\n  if (\n    // Control chars, etc.; condition modeled on the Chrome developer console's display for strings\n    codePoint < 32 || (codePoint > 126 && codePoint < 160) ||\n    // Unicode planes 4-16; unassigned, special purpose, and private use area\n    codePoint > 0x3FFFF ||\n    // Avoid corrupting a preceding backref by immediately following it with a literal digit\n    (escDigit && isDigitCharCode(codePoint))\n  ) {\n    // Don't convert codePoint `0` to `\\0` since that's corruptible by following literal digits\n    return codePoint > 0x7F ?\n      `\\\\x{${codePoint.toString(16).toUpperCase()}}` :\n      `\\\\x${codePoint.toString(16).toUpperCase().padStart(2, '0')}`;\n  }\n  const escapeChars = inCharClass ? CharClassEscapeChars : BaseEscapeChars;\n  const char = cp(codePoint);\n  return (escapeChars.has(char) ? '\\\\' : '') + char;\n}\n\nfunction getFirstChild(node) {\n  if (node.alternatives) {\n    return node.alternatives[0];\n  }\n  if (node.elements) {\n    return node.elements[0] ?? null;\n  }\n  if (node.element) {\n    return node.element;\n  }\n  if (node.min && node.min.type) {\n    return node.min;\n  }\n  if (node.pattern) {\n    return node.pattern;\n  }\n  return null;\n}\n\n/**\n@param {import('../tokenizer/tokenize.js').RegexFlags} node\n@returns {string}\n*/\nfunction getFlagsStr({ignoreCase, dotAll, extended, digitIsAscii, posixIsAscii, spaceIsAscii, wordIsAscii}) {\n  return `${\n    ignoreCase ? 'i' : ''\n  }${\n    dotAll ? 'm' : ''\n  }${\n    extended ? 'x' : ''\n  }${\n    digitIsAscii ? 'D' : ''\n  }${\n    posixIsAscii ? 'P' : ''\n  }${\n    spaceIsAscii ? 'S' : ''\n  }${\n    wordIsAscii ? 'W' : ''\n  }`;\n}\n\n/**\n@param {boolean} atomic\n@param {import('../parser/parse.js').FlagGroupModifiers} flagMods\n@returns {string}\n*/\nfunction getGroupPrefix(atomic, flagMods) {\n  if (atomic) {\n    return '>';\n  }\n  let mods = '';\n  if (flagMods) {\n    const {enable = {}, disable = {}} = flagMods;\n    const enableStr = getFlagsStr(enable);\n    const disableStr = getFlagsStr(disable);\n    mods = `${enableStr}${disableStr ? `-${disableStr}` : ''}`;\n  }\n  return `${mods}:`;\n}\n\nfunction isDigitCharCode(value) {\n  return value > 47 && value < 58;\n}\n\nexport {\n  generate,\n};\n", "import {NodeTypes} from '../parser/parse.js';\nimport {throwIfNot} from '../utils.js';\n\n/**\n@typedef {{\n  node: import('../parser/parse.js').Node;\n  parent: import('../parser/parse.js').Node?;\n  key: (number | string)?;\n  container: Array<import('../parser/parse.js').Node>?;\n  root: import('../parser/parse.js').RegexNode;\n  remove: () => void;\n  removeAllNextSiblings: () => Array<import('../parser/parse.js').Node>;\n  removeAllPrevSiblings: () => Array<import('../parser/parse.js').Node>;\n  replaceWith: (newNode: import('../parser/parse.js').Node, options?: {traverse?: boolean}) => void;\n  replaceWithMultiple: (newNodes: Array<import('../parser/parse.js').Node>, options?: {traverse?: boolean}) => void;\n  skip: () => void;\n}} Path\n@typedef {\n  ( path: Path,\n    state: {\n      [key: string]: any;\n    }\n  ) => void\n} Transformer\n*/\n\n/**\n@param {import('../parser/parse.js').OnigurumaAst} ast\n@param {{\n  [key in ('*' | import('../parser/parse.js').NodeType)]?: Transformer | {enter?: Transformer, exit?: Transformer};\n}} visitor\n@param {{\n  [key: string]: any;\n}} [state]\n*/\nfunction traverse(ast, visitor, state = null) {\n  function traverseArray(array, parent) {\n    for (let i = 0; i < array.length; i++) {\n      const keyShift = traverseNode(array[i], parent, i, array);\n      i = Math.max(-1, i + keyShift);\n    }\n  }\n  function traverseNode(node, parent = null, key = null, container = null) {\n    const containerExpected = 'Container expected';\n    let keyShift = 0;\n    let skipTraversingKidsOfPath = false;\n    const path = {\n      node,\n      parent,\n      key,\n      container,\n      root: ast,\n      remove() {\n        throwIfNot(container, containerExpected).splice(Math.max(0, key + keyShift), 1);\n        keyShift--;\n        skipTraversingKidsOfPath = true;\n      },\n      removeAllNextSiblings() {\n        return throwIfNot(container, containerExpected).splice(key + 1);\n      },\n      removeAllPrevSiblings() {\n        const shifted = key + keyShift;\n        keyShift -= shifted;\n        return throwIfNot(container, containerExpected).splice(0, Math.max(0, shifted));\n      },\n      replaceWith(newNode, options = {}) {\n        const traverseNew = !!options.traverse;\n        if (container) {\n          container[Math.max(0, key + keyShift)] = newNode;\n        } else {\n          parent[key] = newNode;\n        }\n        if (traverseNew) {\n          traverseNode(newNode, parent, key, container);\n        }\n        skipTraversingKidsOfPath = true;\n      },\n      replaceWithMultiple(newNodes, options = {}) {\n        const traverseNew = !!options.traverse;\n        throwIfNot(container, containerExpected).splice(Math.max(0, key + keyShift), 1, ...newNodes);\n        keyShift += newNodes.length - 1;\n        if (traverseNew) {\n          let keyShiftInLoop = 0;\n          for (let i = 0; i < newNodes.length; i++) {\n            keyShiftInLoop += traverseNode(newNodes[i], parent, key + i + keyShiftInLoop, container);\n          }\n        }\n        skipTraversingKidsOfPath = true;\n      },\n      skip() {\n        skipTraversingKidsOfPath = true;\n      },\n    };\n\n    const anyType = visitor['*'];\n    const thisType = visitor[node.type];\n    const enterAllFn = typeof anyType === 'function' ? anyType : anyType?.enter;\n    const enterThisFn = typeof thisType === 'function' ? thisType : thisType?.enter;\n    enterAllFn?.(path, state);\n    enterThisFn?.(path, state);\n\n    if (!skipTraversingKidsOfPath) {\n      switch (node.type) {\n        case NodeTypes.Regex:\n          traverseNode(node.pattern, node, 'pattern');\n          traverseNode(node.flags, node, 'flags');\n          break;\n        case NodeTypes.Alternative:\n        case NodeTypes.CharacterClass:\n          traverseArray(node.elements, node);\n          break;\n        case NodeTypes.Assertion:\n        case NodeTypes.Backreference:\n        case NodeTypes.Character:\n        case NodeTypes.CharacterSet:\n        case NodeTypes.Directive:\n        case NodeTypes.Flags:\n        case NodeTypes.Recursion:\n        case NodeTypes.Subroutine:\n          break;\n        case NodeTypes.AbsentFunction:\n        case NodeTypes.CapturingGroup:\n        case NodeTypes.Group:\n        case NodeTypes.Pattern:\n          traverseArray(node.alternatives, node);\n          break;\n        case NodeTypes.CharacterClassRange:\n          traverseNode(node.min, node, 'min');\n          traverseNode(node.max, node, 'max');\n          break;\n        case NodeTypes.LookaroundAssertion:\n          traverseArray(node.alternatives, node);\n          break;\n        case NodeTypes.Quantifier:\n          traverseNode(node.element, node, 'element');\n          break;\n        default:\n          throw new Error(`Unexpected node type \"${node.type}\"`);\n      }\n    }\n\n    anyType?.exit?.(path, state);\n    thisType?.exit?.(path, state);\n    return keyShift;\n  }\n  traverseNode(ast);\n}\n\nexport {\n  traverse,\n};\n", "import {NodeCharacterSetKinds, NodeTypes} from './parse.js';\n\nconst alternativeContainerTypes = new Set([\n  NodeTypes.AbsentFunction,\n  NodeTypes.CapturingGroup,\n  NodeTypes.Group,\n  NodeTypes.LookaroundAssertion,\n  NodeTypes.Pattern,\n]);\n\nconst atomicTypes = new Set([\n  NodeTypes.Assertion,\n  NodeTypes.Backreference,\n  NodeTypes.Character,\n  NodeTypes.CharacterClass,\n  NodeTypes.CharacterSet,\n  NodeTypes.Directive,\n]);\n\nconst quantifiableTypes = new Set([\n  NodeTypes.AbsentFunction,\n  NodeTypes.Backreference,\n  NodeTypes.CapturingGroup,\n  NodeTypes.Character,\n  NodeTypes.CharacterClass,\n  NodeTypes.CharacterSet,\n  NodeTypes.Group,\n  NodeTypes.Quantifier,\n  NodeTypes.Subroutine,\n]);\n\n// Character set kinds that can appear inside and outside of character classes, and can be inverted\n// by setting `negate`. Some but not all of those excluded use `variableLength: true`\nconst universalCharacterSetKinds = new Set([\n  NodeCharacterSetKinds.digit,\n  NodeCharacterSetKinds.hex,\n  NodeCharacterSetKinds.posix,\n  NodeCharacterSetKinds.property,\n  NodeCharacterSetKinds.space,\n  NodeCharacterSetKinds.word,\n]);\n\nfunction hasOnlyChild(node, props) {\n  // [TODO] Add support for nodes with `alternatives`; look for `elements` within the first alt\n  // after checking that there's only one alt\n  if (!node.elements) {\n    throw new Error('Expected node with elements');\n  }\n  if (node.elements.length !== 1) {\n    return false;\n  }\n  const kid = node.elements[0];\n  return !props || Object.keys(props).every(key => props[key] === kid[key]);\n}\n\nexport {\n  alternativeContainerTypes,\n  atomicTypes,\n  hasOnlyChild,\n  quantifiableTypes,\n  universalCharacterSetKinds,\n};\n", "import {alternativeContainerTypes, universalCharacterSetKinds} from '../../parser/node-utils.js';\nimport {createAlternative, createCharacterClass, NodeTypes} from '../../parser/parse.js';\n\n/**\nUse character classes for adjacent alternatives with single-length values.\n*/\nconst alternationToClass = {\n  '*'({node}) {\n    if (!alternativeContainerTypes.has(node.type)) {\n      return;\n    }\n    const newAlts = [];\n    let ccNodes = [];\n    for (const alt of node.alternatives) {\n      const kid = alt.elements[0];\n      if (\n        alt.elements.length === 1 &&\n        ( kid.type === NodeTypes.Character ||\n          kid.type === NodeTypes.CharacterClass ||\n          (kid.type === NodeTypes.CharacterSet && universalCharacterSetKinds.has(kid.kind))\n        )\n      ) {\n        ccNodes.push(kid);\n      } else {\n        if (ccNodes.length) {\n          newAlts.push(createAlternativeWithCombinedNodes(ccNodes));\n          ccNodes = [];\n        }\n        newAlts.push(alt);\n      }\n    }\n    if (ccNodes.length) {\n      newAlts.push(createAlternativeWithCombinedNodes(ccNodes));\n    }\n    node.alternatives = newAlts;\n  },\n};\n\nfunction createAlternativeWithCombinedNodes(nodes) {\n  const alt = createAlternative();\n  let node = nodes[0];\n  if (nodes.length > 1) {\n    const cc = createCharacterClass();\n    cc.elements = nodes;\n    node = cc;\n  }\n  if (node) {\n    alt.elements.push(node);\n  }\n  return alt;\n}\n\nexport {\n  alternationToClass,\n};\n", "import {NodeCharacterClassKinds, NodeTypes} from '../../parser/parse.js';\n\n/**\nRemove duplicate characters, sets, and ranges from character classes.\n*/\nconst dedupeClasses = {\n  CharacterClass({node}) {\n    const {kind, elements} = node;\n    if (kind !== NodeCharacterClassKinds.union) {\n      return;\n    }\n    const keep = [];\n    for (const el of elements) {\n      // Preserve the order; ignore formatting differences\n      if (\n        ( el.type === NodeTypes.Character &&\n          keep.some(k => (\n            k.type === el.type &&\n            k.value === el.value\n          ))\n        ) ||\n        ( el.type === NodeTypes.CharacterSet &&\n          keep.some(k => (\n            k.type === el.type &&\n            k.kind === el.kind &&\n            k.negate === el.negate &&\n            k.value === el.value\n          ))\n        ) ||\n        ( el.type === NodeTypes.CharacterClassRange &&\n          keep.some(k => (\n            k.type === el.type &&\n            k.min.value === el.min.value &&\n            k.max.value === el.max.value\n          ))\n        )\n      ) {\n        continue;\n      }\n      // Keep non-duplicate nodes (first instance) and any `CharacterClass` nodes\n      keep.push(el);\n    }\n    node.elements = keep;\n  },\n};\n\nexport {\n  dedupeClasses,\n};\n", "import {alternativeContainerTypes} from '../../parser/node-utils.js';\nimport {createAlternative, createGroup, NodeTypes} from '../../parser/parse.js';\n\n/**\nExtract nodes at the start of every alternative into a prefix.\nAlso works within groups.\n- `^aa|^abb|^ac` -> `^a(?:a|bb|c)`\n- `aa|aa|aa` -> `aa`\n- `a|b|c` -> `a|b|c` (no common prefix)\n*/\nconst extractPrefix = {\n  '*'({node}) {\n    if (!alternativeContainerTypes.has(node.type) || node.alternatives.length < 2) {\n      return;\n    }\n    const prefixNodes = [];\n    let passedSharedPrefix = false;\n    let i = 0;\n    while (!passedSharedPrefix) {\n      prefixNodes[i] = node.alternatives[0].elements[i];\n      for (const alt of node.alternatives) {\n        const kid = alt.elements[i];\n        if (!kid || !isAllowedSimpleType(kid.type) || !isNodeEqual(kid, prefixNodes[i])) {\n          passedSharedPrefix = true;\n          break;\n        }\n      }\n      i++;\n    }\n    prefixNodes.pop();\n    if (!prefixNodes.length) {\n      return;\n    }\n    for (const alt of node.alternatives) {\n      alt.elements = alt.elements.slice(prefixNodes.length);\n    }\n    const newContents = createAlternative();\n    newContents.elements = [...prefixNodes];\n    const suffixGroup = createGroup();\n    suffixGroup.alternatives = node.alternatives;\n    if (!suffixGroup.alternatives.every(alt => !alt.elements.length)) {\n      newContents.elements.push(suffixGroup);\n    }\n    node.alternatives = [newContents];\n  },\n};\n\nfunction isAllowedSimpleType(type) {\n  return (\n    type === NodeTypes.Assertion ||\n    type === NodeTypes.Character ||\n    type === NodeTypes.CharacterSet\n  );\n}\n\n// [TODO] Add support for more node types and move to `src/parser/`\nfunction isNodeEqual(a, b) {\n  if (a.type !== b.type) {\n    return false;\n  }\n  if (a.type === NodeTypes.Assertion || a.type === NodeTypes.CharacterSet) {\n    return a.kind === b.kind && a.negate === b.negate;\n  }\n  if (a.type === NodeTypes.Character) {\n    return a.value === b.value;\n  }\n  // Only supports types from `isAllowedSimpleType`\n  throw new Error(`Unexpected node type \"${a.type}\"`);\n}\n\nexport {\n  extractPrefix,\n  isAllowedSimpleType,\n  isNodeEqual,\n};\n", "import {isAllowedSimpleType, isNodeEqual} from './extract-prefix.js';\nimport {alternativeContainerTypes} from '../../parser/node-utils.js';\nimport {createAlternative, createGroup} from '../../parser/parse.js';\n\n/**\nExtract alternating prefixes if patterns are repeated for each prefix.\nAlso works within groups.\n- `^a|!a|^bb|!bb|^c|!c` -> `(?:^|!)(?:a|bb|c)`\n*/\nconst extractPrefix2 = {\n  '*'({node}) {\n    if (!alternativeContainerTypes.has(node.type)) {\n      return;\n    }\n    const numDiffPrefixes = 2;\n    const numAlts = node.alternatives.length;\n    if (numAlts < (numDiffPrefixes * 2) || numAlts % numDiffPrefixes) {\n      return;\n    }\n    const prefixAltElsByI = [...node.alternatives.slice(0, numDiffPrefixes).map(alt => alt.elements)];\n    const prefixNodesByI = Array.from({length: numDiffPrefixes}, _ => []);\n    const prefixIsFinishedByI = Array(numDiffPrefixes).fill(false);\n    const longestOf = Math.max(...prefixAltElsByI.map(els => els.length));\n    for (let nodeI = 0; nodeI < longestOf; nodeI++) {\n      for (let prefixI = 0; prefixI < numDiffPrefixes; prefixI++) {\n        if (!prefixIsFinishedByI[prefixI]) {\n          const nextNode = prefixAltElsByI[prefixI][nodeI];\n          if (\n            !nextNode ||\n            !isAllowedSimpleType(nextNode.type) ||\n            !isPrefixNodeShared(nextNode, node.alternatives, {prefixI, nodeI, numDiffPrefixes})\n          ) {\n            prefixIsFinishedByI[prefixI] = true;\n          } else {\n            prefixNodesByI[prefixI].push(nextNode);\n          }\n        }\n      }\n    }\n    if (!prefixNodesByI.some(nodes => nodes.length)) {\n      return;\n    }\n    const strippedAlts = [];\n    let counter = 0;\n    for (let i = 0; i < numAlts; i++) {\n      const alt = createAlternative();\n      alt.elements = node.alternatives[i].elements.slice(prefixNodesByI[counter].length);\n      strippedAlts.push(alt);\n      counter = counter < (numDiffPrefixes - 1) ? counter + 1 : 0;\n    }\n    // Check that each set of alts now use the same value after having had their prefixes removed\n    for (let i = 0; i < (numAlts / numDiffPrefixes); i++) {\n      const altComparisonSet = strippedAlts.slice(i * numDiffPrefixes, (i * numDiffPrefixes) + numDiffPrefixes);\n      for (let j = 1; j < altComparisonSet.length; j++) {\n        const els = altComparisonSet[j].elements;\n        if (els.length !== altComparisonSet[0].elements.length) {\n          return;\n        }\n        if (!els.every((el, k) => (\n          isAllowedSimpleType(el.type) &&\n          isNodeEqual(el, altComparisonSet[0].elements[k])\n        ))) {\n          return;\n        }\n      }\n    }\n    const newContents = createAlternative();\n    const prefixGroup = createGroup();\n    const prefixAlts = [];\n    for (let i = 0; i < numDiffPrefixes; i++) {\n      const alt = createAlternative();\n      alt.elements = prefixNodesByI[i];\n      prefixAlts.push(alt);\n    }\n    prefixGroup.alternatives = prefixAlts;\n    newContents.elements.push(prefixGroup);\n    const suffixGroup = createGroup();\n    // Only take one (unique) alt from each set of stripped alts\n    suffixGroup.alternatives = strippedAlts.filter((_, i) => i % numDiffPrefixes);\n    if (suffixGroup.alternatives.every(alt => !alt.elements.length)) {\n      node.alternatives = prefixGroup.alternatives;\n    } else {\n      newContents.elements.push(suffixGroup);\n      node.alternatives = [newContents];\n    }\n  },\n};\n\nfunction isPrefixNodeShared(node, alts, {prefixI, nodeI, numDiffPrefixes}) {\n  for (let i = prefixI; i < alts.length; i += numDiffPrefixes) {\n    const alt = alts[i];\n    const bNode = alt.elements[nodeI];\n    if (!bNode || !isNodeEqual(bNode, node)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport {\n  extractPrefix2,\n};\n", "import {NodeTypes} from '../../parser/parse.js';\n\n/**\nRemove empty noncapturing, atomic, and flag groups, even if quantified.\n*/\nconst removeEmptyGroups = {\n  Group({node, remove}) {\n    if (isEmptyGroup(node)) {\n      remove();\n    }\n  },\n\n  Quantifier({node, remove}) {\n    let kid = node.element;\n    while (kid.type === NodeTypes.Quantifier) {\n      kid = kid.element;\n    }\n    if (isEmptyGroup(kid)) {\n      remove();\n    }\n  },\n};\n\nfunction isEmptyGroup(node) {\n  return (\n    node.type === NodeTypes.Group &&\n    node.alternatives.every(alt => !alt.elements.length)\n  );\n}\n\nexport {\n  removeEmptyGroups,\n};\n", "import {NodeDirectiveKinds} from '../../parser/parse.js';\n\n/**\nRemove flags (from top-level and modifiers) that have no effect.\n[TODO] Support removing additional flags besides `x`.\n*/\nconst removeUselessFlags = {\n  Flags({node}) {\n    // Effects of flag x are already applied during parsing\n    node.extended = false;\n  },\n\n  Directive({node, remove}) {\n    if (node.kind !== NodeDirectiveKinds.flags) {\n      return;\n    }\n    removeFlagX(node);\n    if (removeEmptyFlagsObj(node)) {\n      remove();\n    }\n  },\n\n  Group({node}) {\n    if (!node.flags) {\n      return;\n    }\n    removeFlagX(node);\n    removeEmptyFlagsObj(node);\n  },\n};\n\nfunction removeEmptyFlagsObj(node) {\n  const {flags} = node;\n  if (flags && !flags.enable && !flags.disable) {\n    delete node.flags;\n    return true;\n  }\n  return false;\n}\n\nfunction removeFlagX({flags}) {\n  flags.enable && delete flags.enable.extended;\n  flags.disable && delete flags.disable.extended;\n  cleanupFlagsObj(flags);\n}\n\nfunction cleanupFlagsObj(flags) {\n  flags.enable && !Object.keys(flags.enable).length && delete flags.enable;\n  flags.disable && !Object.keys(flags.disable).length && delete flags.disable;\n}\n\nexport {\n  removeUselessFlags,\n};\n", "import {hasOnlyChild} from '../../parser/node-utils.js';\nimport {NodeCharacterClassKinds, NodeTypes} from '../../parser/parse.js';\n\n/**\nUnnest character classes when possible.\nSee also `unwrapNegationWrappers`.\n*/\nconst unnestUselessClasses = {\n  CharacterClass({node, parent, replaceWith, replaceWithMultiple}) {\n    const {kind, negate, elements} = node;\n    if (\n      // Don't use this to unwrap outermost classes; see `unwrapUselessClasses` for that\n      parent.type !== NodeTypes.CharacterClass ||\n      kind !== NodeCharacterClassKinds.union ||\n      !elements.length\n    ) {\n      return;\n    }\n    const firstEl = elements[0];\n    // Special case to unnest classes that are an only-kid of their parent, since it might flip\n    // `negate` on the parent; ex:\n    // `[[a]]` -> `[a]`; `[[^a]]` -> `[^a]`; `[^[a]]` -> `[^a]`; `[^[^a]]` -> `[a]`\n    if (hasOnlyChild(parent, {\n      type: NodeTypes.CharacterClass,\n      kind: NodeCharacterClassKinds.union,\n    })) {\n      parent.negate = parent.negate !== negate;\n      replaceWithMultiple(elements, {traverse: true});\n      return;\n    }\n    // Remainder of options apply only if the class is non-negated\n    if (negate) {\n      return;\n    }\n    // Unnest all kids into a union class\n    if (parent.kind === NodeCharacterClassKinds.union) {\n      replaceWithMultiple(elements, {traverse: true});\n    // Can unnest any one kid into an intersection class\n    // [TODO] After supporting `format` for classes in the parser, can \"unnest\" any number of kids\n    // into intersection by flipping this class's `format` from `'explicit'` to `'implicit'`,\n    // rather than replacing it\n    } else if (hasOnlyChild(node)) {\n      replaceWith(firstEl, {traverse: true});\n    }\n  },\n};\n\nexport {\n  unnestUselessClasses,\n};\n", "import {createCharacterSet, NodeCharacterClassKinds, NodeCharacterSetKinds, NodeQuantifierKinds, NodeTypes} from '../../parser/parse.js';\n\n/**\nUnwrap negated classes used to negate an individual character set.\nAllows independently controlling this behavior and avoiding logic duplication in\n`unwrapUselessClasses` and `unnestUselessClasses`.\n*/\nconst unwrapNegationWrappers = {\n  CharacterClass({node, parent, replaceWith}) {\n    const {kind, negate, elements} = node;\n    const kid = elements[0];\n    if (\n      !negate ||\n      kind !== NodeCharacterClassKinds.union ||\n      elements.length !== 1\n    ) {\n      return;\n    }\n    // Don't need to check if `kind` is in `universalCharacterSetKinds` because all character\n    // sets valid in classes are in that set\n    if (kid.type === NodeTypes.CharacterSet) {\n      kid.negate = !kid.negate;\n      // Might unnest into a class or unwrap into a non-class\n      replaceWith(kid);\n    } else if (\n      parent.type !== NodeTypes.CharacterClass &&\n      kid.type === NodeTypes.Character &&\n      kid.value === 10 // '\\n'\n    ) {\n      if (parent.type === NodeTypes.Quantifier && parent.kind !== NodeQuantifierKinds.lazy) {\n        // Avoid introducing a trigger for an Oniguruma bug; see <github.com/rosshamish/kuskus/issues/209>\n        return;\n      }\n      // `[^\\n]` -> `\\N`; can only use `\\N` if not in a class\n      replaceWith(createCharacterSet(NodeCharacterSetKinds.newline, {negate: true}));\n    }\n  },\n};\n\nexport {\n  unwrapNegationWrappers,\n};\n", "import {NodeCharacterClassKinds, NodeTypes} from '../../parser/parse.js';\n\n/**\nUnwrap outermost non-negated character classes containing a single character or character set.\nSee also `unwrapNegationWrappers`.\n*/\nconst unwrapUselessClasses = {\n  CharacterClass({node, parent, replaceWith}) {\n    const {kind, negate, elements} = node;\n    const kid = elements[0];\n    if (\n      parent.type === NodeTypes.CharacterClass ||\n      negate ||\n      kind !== NodeCharacterClassKinds.union ||\n      elements.length !== 1 ||\n      (kid.type !== NodeTypes.Character && kid.type !== NodeTypes.CharacterSet)\n    ) {\n      return;\n    }\n    replaceWith(kid, {traverse: true});\n  },\n};\n\nexport {\n  unwrapUselessClasses,\n};\n", "import {atomicTypes, quantifiableTypes} from '../../parser/node-utils.js';\nimport {NodeTypes} from '../../parser/parse.js';\n\n/**\nUnwrap nonbeneficial noncapturing and atomic groups.\n*/\nconst unwrapUselessGroups = {\n  Group({node, parent, replaceWithMultiple}) {\n    const {alternatives, atomic, flags} = node;\n    if (alternatives.length > 1 || parent.type === NodeTypes.Quantifier) {\n      return;\n    }\n    const els = alternatives[0].elements;\n    let unwrap = false;\n\n    if (atomic) {\n      if (els.every(({type}) => atomicTypes.has(type))) {\n        unwrap = true;\n      }\n    } else if (flags) {\n      // Rely on `removeUselessFlags`, then the group can be unwrapped in a subsequent pass\n    } else {\n      unwrap = true;\n    }\n\n    if (unwrap) {\n      replaceWithMultiple(els, {traverse: true});\n    }\n  },\n\n  Quantifier({node}) {\n    if (node.element.type !== NodeTypes.Group) {\n      return;\n    }\n    const quantifiedGroup = node.element;\n    if (quantifiedGroup.alternatives.length > 1) {\n      return;\n    }\n    const groupKids = quantifiedGroup.alternatives[0].elements;\n    if (groupKids.length !== 1) {\n      return;\n    }\n    const candidate = groupKids[0];\n    if (\n      !quantifiableTypes.has(candidate.type) ||\n      (quantifiedGroup.atomic && !atomicTypes.has(candidate.type)) ||\n      quantifiedGroup.flags\n    ) {\n      return;\n    }\n    // Make the only child of the group the new element of the quantifier\n    node.element = candidate;\n  },\n};\n\nexport {\n  unwrapUselessGroups,\n};\n", "import {createCharacterSet, NodeCharacterClassKinds, NodeCharacterSetKinds, NodeTypes} from '../../parser/parse.js';\n\n/**\nUse shorthands (`\\d`, `\\h`, `\\s`, etc.) when possible.\n- `\\d` from `\\p{Decimal_Number}`, `\\p{Nd}`, `\\p{digit}`, `[[:digit:]]`\n- `\\h` from `\\p{ASCII_Hex_Digit}`, `\\p{AHex}`, `\\p{xdigit}`, `[[:xdigit:]]`, `[0-9A-Fa-f]`\n- `\\s` from `\\p{White_Space}`, `\\p{WSpace}`, `\\p{space}`, `[[:space:]]`\n- `\\w` from `[\\p{L}\\p{M}\\p{N}\\p{Pc}]` - Not the same as POSIX `\\p{word}`, `[[:word:]]`!\n- `\\O` from `\\p{Any}` if not in class\nSee also `useUnicodeProps`.\n*/\nconst useShorthands = {\n  CharacterSet({node, parent, root, replaceWith}) {\n    const {kind, negate, value} = node;\n    let newNode;\n    if (\n      ( kind === NodeCharacterSetKinds.property &&\n        (value === 'Decimal_Number' || value === 'Nd') &&\n        // [TODO] Also need to check whether these flags are set in local context, when the parser\n        // supports these flags on mode modifiers\n        !root.flags.digitIsAscii &&\n        !root.flags.posixIsAscii\n      ) ||\n      ( kind === NodeCharacterSetKinds.posix &&\n        value === 'digit'\n      )\n    ) {\n      newNode = createCharacterSet(NodeCharacterSetKinds.digit, {negate});\n    } else if (\n      ( kind === NodeCharacterSetKinds.property &&\n        (value === 'ASCII_Hex_Digit' || value === 'AHex')\n      ) ||\n      ( kind === NodeCharacterSetKinds.posix &&\n        value === 'xdigit'\n      )\n    ) {\n      newNode = createCharacterSet(NodeCharacterSetKinds.hex, {negate});\n    } else if (\n      ( kind === NodeCharacterSetKinds.property &&\n        (value === 'White_Space' || value === 'WSpace') &&\n        // [TODO] Also need to check whether these flags are set in local context, when the parser\n        // supports these flags on mode modifiers\n        !root.flags.spaceIsAscii &&\n        !root.flags.posixIsAscii\n      ) ||\n      ( kind === NodeCharacterSetKinds.posix &&\n        value === 'space'\n      )\n    ) {\n      newNode = createCharacterSet(NodeCharacterSetKinds.space, {negate});\n    } else if (\n      parent.type !== NodeTypes.CharacterClass &&\n      kind === NodeCharacterSetKinds.property &&\n      !negate &&\n      value === 'Any'\n    ) {\n      newNode = createCharacterSet(NodeCharacterSetKinds.any);\n    }\n\n    if (newNode) {\n      replaceWith(newNode);\n    }\n  },\n\n  CharacterClass({node, root}) {\n    if (node.kind !== NodeCharacterClassKinds.union) {\n      return;\n    }\n    const has = {\n      rangeDigit0To9: false,\n      rangeAToFLower: false,\n      rangeAToFUpper: false,\n      unicodeL: false,\n      unicodeM: false,\n      unicodeN: false,\n      unicodePc: false,\n    }\n    for (const kid of node.elements) {\n      if (kid.type === NodeTypes.CharacterClassRange) {\n        has.rangeDigit0To9 ||= isRange(kid, 48, 57); // '0' to '9'\n        has.rangeAToFLower ||= isRange(kid, 97, 102); // 'a' to 'f'\n        has.rangeAToFUpper ||= isRange(kid, 65, 70); // 'A' to 'F'\n      } else if (kid.type === NodeTypes.CharacterSet) {\n        has.unicodeL ||= isUnicode(kid, 'L');\n        has.unicodeM ||= isUnicode(kid, 'M');\n        has.unicodeN ||= isUnicode(kid, 'N');\n        has.unicodePc ||= isUnicode(kid, 'Pc', {supercategories: true});\n      }\n    }\n    if (has.rangeDigit0To9 && has.rangeAToFUpper && has.rangeAToFLower) {\n      node.elements = node.elements.filter(kid => !(\n        isRange(kid, 48, 57) || isRange(kid, 97, 102) || isRange(kid, 65, 70)\n      ));\n      node.elements.push(createCharacterSet(NodeCharacterSetKinds.hex));\n    }\n    if (\n      (has.unicodeL && has.unicodeM && has.unicodeN && has.unicodePc) &&\n      // [TODO] Also need to check whether these flags are set in local context, when the parser\n      // supports these flags on mode modifiers\n      !root.flags.wordIsAscii &&\n      !root.flags.posixIsAscii\n    ) {\n      node.elements = node.elements.filter(kid => !isUnicode(kid, ['L', 'M', 'N', 'Pc'], {\n        subcategories: true,\n      }));\n      node.elements.push(createCharacterSet(NodeCharacterSetKinds.word));\n    }\n  },\n};\n\nfunction isRange(node, min, max) {\n  return (\n    node.type === NodeTypes.CharacterClassRange &&\n    node.min.value === min &&\n    node.max.value === max\n  );\n}\n\nfunction isUnicode(node, value, options = {}) {\n  const names = Array.isArray(value) ? value : [value];\n  const expanded = [];\n  for (const v of names) {\n    expanded.push(v);\n    if (fullNames[v]) {\n      expanded.push(fullNames[v]);\n    }\n    if (options.supercategories && supercategories[v]) {\n      expanded.push(supercategories[v]);\n      if (fullNames[supercategories[v]]) {\n        expanded.push(fullNames[supercategories[v]]);\n      }\n    }\n    if (options.subcategories && subcategories[v]) {\n      expanded.push(...subcategories[v]);\n    }\n  }\n  return (\n    node.type === NodeTypes.CharacterSet &&\n    node.kind === NodeCharacterSetKinds.property &&\n    !node.negate &&\n    expanded.includes(node.value)\n  );\n}\n\nconst fullNames = {\n  L: 'Letter',\n  M: 'Mark',\n  N: 'Number',\n  P: 'Punctuation',\n};\n\nconst supercategories = {\n  Pc: 'P',\n};\n\nconst subcategories = {\n  L: ['Ll', 'Lm', 'Lo', 'Lt', 'Lu'],\n  M: ['Mc', 'Me', 'Mn'],\n  N: ['Nd', 'Nl', 'No'],\n};\n\nexport {\n  isRange,\n  useShorthands,\n};\n", "import {NodeCharacterSetKinds} from '../../parser/parse.js';\n\n/**\nUse Unicode property aliases.\n*/\nconst useUnicodeAliases = {\n  CharacterSet({node}) {\n    if (node.kind !== NodeCharacterSetKinds.property) {\n      return;\n    }\n    const alias = OnigUnicodeAliasMap.get(node.value);\n    if (alias) {\n      node.value = alias;\n    }\n  },\n};\n\n// Oniguruma doesn't include all Unicode property aliases; some are treated as POSIX class names\n// and are excluded (see `PosixClassNames`)\nconst OnigUnicodeAliasMap = /* @__PURE__ */ new Map([\n  // ## General category aliases\n  ['Other', 'C'],\n    ['Control', 'Cc'],\n    ['Format', 'Cf'],\n    ['Unassigned', 'Cn'],\n    ['Private_Use', 'Co'],\n    ['Surrogate', 'Cs'],\n  ['Letter', 'L'],\n    ['Cased_Letter', 'LC'],\n    ['Lowercase_Letter', 'Ll'],\n    ['Modifier_Letter', 'Lm'],\n    ['Other_Letter', 'Lo'],\n    ['Titlecase_Letter', 'Lt'],\n    ['Uppercase_Letter', 'Lu'],\n  ['Mark', 'M'],\n  ['Combining_Mark', 'M'],\n    ['Spacing_Mark', 'Mc'],\n    ['Enclosing_Mark', 'Me'],\n    ['Nonspacing_Mark', 'Mn'],\n  ['Number', 'N'],\n    ['Decimal_Number', 'Nd'],\n    ['Letter_Number', 'Nl'],\n    ['Other_Number', 'No'],\n  ['Punctuation', 'P'],\n  // `punct` is also a POSIX class name, but it's included in the Oniguruma property list since the\n  // POSIX class version uses a different value starting with Oniguruma 6.9.9\n  ['punct', 'P'],\n    ['Connector_Punctuation', 'Pc'],\n    ['Dash_Punctuation', 'Pd'],\n    ['Close_Punctuation', 'Pe'],\n    ['Final_Punctuation', 'Pf'],\n    ['Initial_Punctuation', 'Pi'],\n    ['Other_Punctuation', 'Po'],\n    ['Open_Punctuation', 'Ps'],\n  ['Symbol', 'S'],\n    ['Currency_Symbol', 'Sc'],\n    ['Modifier_Symbol', 'Sk'],\n    ['Math_Symbol', 'Sm'],\n    ['Other_Symbol', 'So'],\n  ['Separator', 'Z'],\n    ['Line_Separator', 'Zl'],\n    ['Paragraph_Separator', 'Zp'],\n    ['Space_Separator', 'Zs'],\n  // ## Binary property aliases\n  ['ASCII_Hex_Digit', 'AHex'],\n  ['Bidi_Control', 'Bidi_C'],\n  ['Case_Ignorable', 'CI'],\n  ['Changes_When_Casefolded', 'CWCF'],\n  ['Changes_When_Casemapped', 'CWCM'],\n  ['Changes_When_Lowercased', 'CWL'],\n  ['Changes_When_Titlecased', 'CWT'],\n  ['Changes_When_Uppercased', 'CWU'],\n  ['Default_Ignorable_Code_Point', 'DI'],\n  ['Deprecated', 'Dep'],\n  ['Diacritic', 'Dia'],\n  ['Emoji_Component', 'EComp'],\n  ['Emoji_Modifier', 'EMod'],\n  ['Emoji_Modifier_Base', 'EBase'],\n  ['Emoji_Presentation', 'EPres'],\n  ['Extended_Pictographic', 'ExtPict'],\n  ['Extender', 'Ext'],\n  ['Grapheme_Base', 'Gr_Base'],\n  ['Grapheme_Extend', 'Gr_Ext'],\n  ['Grapheme_Link', 'Gr_Link'],\n  ['Hex_Digit', 'Hex'],\n  ['IDS_Binary_Operator', 'IDSB'],\n  ['IDS_Trinary_Operator', 'IDST'],\n  ['IDS_Unary_Operator', 'IDSU'],\n  ['ID_Continue', 'IDC'],\n  ['ID_Start', 'IDS'],\n  ['Ideographic', 'Ideo'],\n  ['Join_Control', 'Join_C'],\n  ['Logical_Order_Exception', 'LOE'],\n  ['Noncharacter_Code_Point', 'NChar'],\n  ['Other_Alphabetic', 'OAlpha'],\n  ['Other_Default_Ignorable_Code_Point', 'ODI'],\n  ['Other_Grapheme_Extend', 'OGr_Ext'],\n  ['Other_ID_Continue', 'OIDC'],\n  ['Other_ID_Start', 'OIDS'],\n  ['Other_Lowercase', 'OLower'],\n  ['Other_Math', 'OMath'],\n  ['Other_Uppercase', 'OUpper'],\n  ['Pattern_Syntax', 'Pat_Syn'],\n  ['Pattern_White_Space', 'Pat_WS'],\n  ['Prepended_Concatenation_Mark', 'PCM'],\n  ['Quotation_Mark', 'QMark'],\n  ['Regional_Indicator', 'RI'],\n  ['Sentence_Terminal', 'STerm'],\n  ['Soft_Dotted', 'SD'],\n  ['Terminal_Punctuation', 'Term'],\n  ['Unified_Ideograph', 'UIdeo'],\n  ['Variation_Selector', 'VS'],\n  ['White_Space', 'WSpace'],\n  ['XID_Continue', 'XIDC'],\n  ['XID_Start', 'XIDS'],\n  // ## Script aliases\n  // [TODO] Add script aliases\n]);\n\nexport {\n  useUnicodeAliases,\n};\n", "import {createUnicodeProperty, NodeCharacterSetKinds} from '../../parser/parse.js';\nimport {isRange} from './use-shorthands.js';\n\n/**\nUse Unicode properties when possible.\n- `\\p{Any}` from `[0-\\x{10FFFF}]`\n- `\\p{Cc}` from POSIX `\\p{cntrl}`, `[[:cntrl:]]`\nSee also `useShorthands`.\n*/\nconst useUnicodeProps = {\n  CharacterSet({node, root, replaceWith}) {\n    const {kind, negate, value} = node;\n    let newNode;\n    if (\n      kind === NodeCharacterSetKinds.posix &&\n      value === 'cntrl' &&\n      // [TODO] Also need to check whether this flag is set in local context, when the parser\n      // supports this flag on mode modifiers\n      !root.flags.posixIsAscii\n    ) {\n      newNode = createUnicodeProperty('Cc', {negate});\n    }\n\n    if (newNode) {\n      replaceWith(newNode);\n    }\n  },\n\n  CharacterClassRange({node, replaceWith}) {\n    if (isRange(node, 0, 0x10FFFF)) {\n      replaceWith(createUnicodeProperty('Any'));\n    }\n  },\n};\n\nexport {\n  useUnicodeProps,\n};\n", "import {alternationToClass} from './transforms/alternation-to-class.js';\nimport {dedupeClasses} from './transforms/dedupe-classes.js';\nimport {extractPrefix} from './transforms/extract-prefix.js';\nimport {extractPrefix2} from './transforms/extract-prefix-2.js';\nimport {removeEmptyGroups} from './transforms/remove-empty-groups.js';\nimport {removeUselessFlags} from './transforms/remove-useless-flags.js';\nimport {unnestUselessClasses} from './transforms/unnest-useless-classes.js';\nimport {unwrapNegationWrappers} from './transforms/unwrap-negation-wrappers.js';\nimport {unwrapUselessClasses} from './transforms/unwrap-useless-classes.js';\nimport {unwrapUselessGroups} from './transforms/unwrap-useless-groups.js';\nimport {useShorthands} from './transforms/use-shorthands.js';\nimport {useUnicodeAliases} from './transforms/use-unicode-aliases.js';\nimport {useUnicodeProps} from './transforms/use-unicode-props.js';\n\n/**\n@typedef {\n  'alternationToClass' |\n  'dedupeClasses' |\n  'extractPrefix' |\n  'extractPrefix2' |\n  'removeEmptyGroups' |\n  'removeUselessFlags' |\n  'unnestUselessClasses' |\n  'unwrapNegationWrappers' |\n  'unwrapUselessClasses' |\n  'unwrapUselessGroups' |\n  'useShorthands' |\n  'useUnicodeAliases' |\n  'useUnicodeProps'\n} OptimizationName\n*/\nconst optimizations = new Map([\n  ['alternationToClass', alternationToClass],\n  ['dedupeClasses', dedupeClasses],\n  ['extractPrefix', extractPrefix],\n  ['extractPrefix2', extractPrefix2],\n  ['removeEmptyGroups', removeEmptyGroups],\n  ['removeUselessFlags', removeUselessFlags],\n  ['unnestUselessClasses', unnestUselessClasses],\n  ['unwrapNegationWrappers', unwrapNegationWrappers],\n  ['unwrapUselessClasses', unwrapUselessClasses],\n  ['unwrapUselessGroups', unwrapUselessGroups],\n  ['useShorthands', useShorthands],\n  ['useUnicodeAliases', useUnicodeAliases],\n  ['useUnicodeProps', useUnicodeProps],\n]);\n\nexport {\n  optimizations,\n};\n", "import {toOnigurumaAst} from '../index.js';\nimport {generate} from '../generator/generate.js';\nimport {traverse} from '../traverser/traverse.js';\nimport {optimizations} from './optimizations.js';\n\n/**\nReturns an optimized Oniguruma pattern and flags.\n@param {string} pattern Oniguruma regex pattern.\n@param {{\n  flags?: string;\n  override?: {[key in import('./optimizations.js').OptimizationName]?: boolean};\n  rules?: {\n    captureGroup?: boolean;\n    singleline?: boolean;\n  };\n}} [options]\n@returns {{\n  pattern: string;\n  flags: string;\n}}\n*/\nfunction optimize(pattern, options) {\n  const opts = getOptions(options);\n  const ast = toOnigurumaAst(pattern, {\n    flags: opts.flags,\n    rules: opts.rules,\n  });\n  const active = Object.assign(getOptionalOptimizations(), opts.override);\n  Object.keys(active).forEach(key => {\n    if (!active[key]) {\n      delete active[key];\n    }\n  });\n  const names = Object.keys(active);\n  let optimized = {pattern};\n  let counter = 0;\n  do {\n    if (++counter > 200) {\n      throw new Error('Optimization exceeded maximum iterations; possible infinite loop');\n    }\n    pattern = optimized.pattern;\n    for (const name of names) {\n      traverse(ast, optimizations.get(name));\n    }\n    optimized = generate(ast);\n  // Continue until no further optimization progress is made\n  } while (pattern !== optimized.pattern);\n  return optimized;\n}\n\nfunction getOptions(options = {}) {\n  return {\n    flags: '',\n    override: {},\n    rules: {},\n    ...options,\n  };\n}\n\n/**\n@param {{\n  disable?: boolean;\n}} [options]\n@returns {\n  {[key in import('./optimizations.js').OptimizationName]: boolean}\n}\n*/\nfunction getOptionalOptimizations({disable} = {}) {\n  const obj = {};\n  for (const key of optimizations.keys()) {\n    obj[key] = !disable;\n  }\n  return obj;\n}\n\nexport {\n  getOptionalOptimizations,\n  optimize,\n};\n"],
  "mappings": "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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAu2BE,MAAM,IAAI,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",
  "names": ["bundle_exports", "__export", "generate", "getOptionalOptimizations", "optimize", "parse", "toOnigurumaAst", "traverse", "cp", "r", "PosixClassNames", "getOrInsert", "map", "key", "defaultValue", "throwIfNot", "value", "msg", "TokenTypes", "TokenCharacterSetKinds", "TokenDirectiveKinds", "TokenGroupKinds", "TokenQuantifierKinds", "EscapeCharCodes", "charClassOpenPattern", "r", "sharedEscapesPattern", "quantifierRe", "tokenRe", "charClassTokenRe", "tokenize", "pattern", "options", "opts", "flagsObj", "getFlagsObj", "xStack", "context", "isXOn", "tokens", "match", "result", "getTokenWithDetails", "potentialUnnamedCaptureTokens", "numNamedAndOptInUnnamedCaptures", "t", "i", "numCaptures", "splitEscapedNumToken", "m", "lastIndex", "m0", "m1", "getAllTokensForCharClass", "createToken", "createTokenForSharedEscape", "createTokenForFlagMod", "token", "end", "re", "kind", "createTokenForQuantifier", "assertSingleCodePoint", "opener", "numCharClassesOpen", "createTokenForAnyTokenWithinCharClass", "raw", "posix", "PosixClassNames", "inCharClass", "char1", "createTokenForControlChar", "createTokenForShorthandCharClass", "createTokenForUnicodeProperty", "bytes", "hex", "decoded", "encoder", "char", "byte", "getValidatedHexCharCode", "type", "data", "on", "off", "enabledFlags", "getFlagGroupSwitches", "disabledFlags", "flagChanges", "min", "max", "limit", "lower", "p", "neg", "value", "negate", "flags", "obj", "matches", "NodeTypes", "NodeAbsentFunctionKinds", "NodeAssertionKinds", "NodeCharacterClassKinds", "NodeCharacterSetKinds", "TokenCharacterSetKinds", "NodeDirectiveKinds", "TokenDirectiveKinds", "NodeQuantifierKinds", "TokenQuantifierKinds", "NodeLookaroundAssertionKinds", "parse", "pattern", "options", "opts", "tokenized", "tokenize", "context", "walk", "parent", "state", "token", "TokenTypes", "createAlternative", "createAssertionFromToken", "parseBackreference", "createCharacter", "parseCharacterClassHyphen", "parseCharacterClassOpen", "parseCharacterSet", "createDirective", "throwIfNot", "parseGroupOpen", "parseQuantifier", "parseSubroutine", "ast", "createRegex", "createPattern", "createFlags", "top", "node", "capturingGroups", "hasNumberedRef", "namedGroupsByName", "subroutines", "ref", "r", "raw", "hasKWrapper", "fromNum", "num", "isRelative", "numCapturesToLeft", "orphan", "createBackreference", "numberedRef", "tokens", "prevSiblingNode", "nextToken", "nextNode", "createCharacterClassRange", "firstClassToken", "intersections", "createCharacterClass", "throwIfUnclosedCharacterClass", "cc", "normalizeUnknownPropertyNames", "skipPropertyNameValidation", "unicodePropertyMap", "kind", "negate", "value", "normalized", "slug", "PosixClassNames", "createUnicodeProperty", "createPosixClass", "createCharacterSet", "skipLookbehindValidation", "createByGroupKind", "isAbsentFunction", "isLookbehind", "isNegLookbehind", "getOrInsert", "throwIfUnclosedGroup", "alt", "child", "msg", "min", "max", "quantifiedNode", "createQuantifier", "createSubroutine", "createAbsentFunction", "createAssertion", "flags", "name", "number", "TokenGroupKinds", "createGroup", "createCapturingGroup", "createLookaroundAssertion", "hasName", "isValidGroupName", "charCode", "hex", "atomic", "element", "normalizeUnicodePropertyName", "m", "OnigUnicodePropertyMap", "p", "slug", "toOnigurumaAst", "pattern", "options", "parse", "OnigUnicodePropertyMap", "generate", "ast", "lastNode", "state", "gen", "node", "getFirstChild", "fn", "generator", "pattern", "flags", "_", "kind", "alternatives", "NodeAbsentFunctionKinds", "elements", "negate", "NodeAssertionKinds", "r", "throwIfNot", "ref", "name", "value", "getCharEscape", "NodeTypes", "genClass", "NodeCharacterClassKinds", "result", "min", "max", "NodeCharacterSetKinds", "NodeDirectiveKinds", "enable", "disable", "enableStr", "getFlagsStr", "disableStr", "atomic", "contents", "getGroupPrefix", "NodeLookaroundAssertionKinds", "element", "NodeQuantifierKinds", "kidIsGreedyQuantifier", "base", "interval", "suffix", "BaseEscapeChars", "CharClassEscapeChars", "CharCodeEscapeMap", "codePoint", "escDigit", "inCharClass", "isDigitCharCode", "escapeChars", "char", "cp", "ignoreCase", "dotAll", "extended", "digitIsAscii", "posixIsAscii", "spaceIsAscii", "wordIsAscii", "flagMods", "mods", "traverse", "ast", "visitor", "state", "traverseArray", "array", "parent", "i", "keyShift", "traverseNode", "node", "key", "container", "containerExpected", "skipTraversingKidsOfPath", "path", "throwIfNot", "shifted", "newNode", "options", "traverseNew", "newNodes", "keyShiftInLoop", "anyType", "thisType", "enterAllFn", "enterThisFn", "NodeTypes", "alternativeContainerTypes", "NodeTypes", "atomicTypes", "quantifiableTypes", "universalCharacterSetKinds", "NodeCharacterSetKinds", "hasOnlyChild", "node", "props", "kid", "key", "alternationToClass", "node", "alternativeContainerTypes", "newAlts", "ccNodes", "alt", "kid", "NodeTypes", "universalCharacterSetKinds", "createAlternativeWithCombinedNodes", "nodes", "createAlternative", "cc", "createCharacterClass", "dedupeClasses", "node", "kind", "elements", "NodeCharacterClassKinds", "keep", "el", "NodeTypes", "k", "extractPrefix", "node", "alternativeContainerTypes", "prefixNodes", "passedSharedPrefix", "i", "alt", "kid", "isAllowedSimpleType", "isNodeEqual", "newContents", "createAlternative", "suffixGroup", "createGroup", "type", "NodeTypes", "a", "b", "extractPrefix2", "node", "alternativeContainerTypes", "numDiffPrefixes", "numAlts", "prefixAltElsByI", "alt", "prefixNodesByI", "_", "prefixIsFinishedByI", "longestOf", "els", "nodeI", "prefixI", "nextNode", "isAllowedSimpleType", "isPrefixNodeShared", "nodes", "strippedAlts", "counter", "i", "createAlternative", "altComparisonSet", "j", "el", "k", "isNodeEqual", "newContents", "prefixGroup", "createGroup", "prefixAlts", "suffixGroup", "alts", "bNode", "removeEmptyGroups", "node", "remove", "isEmptyGroup", "kid", "NodeTypes", "alt", "removeUselessFlags", "node", "remove", "NodeDirectiveKinds", "removeFlagX", "removeEmptyFlagsObj", "flags", "cleanupFlagsObj", "unnestUselessClasses", "node", "parent", "replaceWith", "replaceWithMultiple", "kind", "negate", "elements", "NodeTypes", "NodeCharacterClassKinds", "firstEl", "hasOnlyChild", "unwrapNegationWrappers", "node", "parent", "replaceWith", "kind", "negate", "elements", "kid", "NodeCharacterClassKinds", "NodeTypes", "NodeQuantifierKinds", "createCharacterSet", "NodeCharacterSetKinds", "unwrapUselessClasses", "node", "parent", "replaceWith", "kind", "negate", "elements", "kid", "NodeTypes", "NodeCharacterClassKinds", "unwrapUselessGroups", "node", "parent", "replaceWithMultiple", "alternatives", "atomic", "flags", "NodeTypes", "els", "unwrap", "type", "atomicTypes", "quantifiedGroup", "groupKids", "candidate", "quantifiableTypes", "useShorthands", "node", "parent", "root", "replaceWith", "kind", "negate", "value", "newNode", "NodeCharacterSetKinds", "createCharacterSet", "NodeTypes", "NodeCharacterClassKinds", "has", "kid", "isRange", "isUnicode", "min", "max", "options", "names", "expanded", "v", "fullNames", "supercategories", "subcategories", "useUnicodeAliases", "node", "NodeCharacterSetKinds", "alias", "OnigUnicodeAliasMap", "useUnicodeProps", "node", "root", "replaceWith", "kind", "negate", "value", "newNode", "NodeCharacterSetKinds", "createUnicodeProperty", "isRange", "optimizations", "alternationToClass", "dedupeClasses", "extractPrefix", "extractPrefix2", "removeEmptyGroups", "removeUselessFlags", "unnestUselessClasses", "unwrapNegationWrappers", "unwrapUselessClasses", "unwrapUselessGroups", "useShorthands", "useUnicodeAliases", "useUnicodeProps", "optimize", "pattern", "options", "opts", "getOptions", "ast", "toOnigurumaAst", "active", "getOptionalOptimizations", "key", "names", "optimized", "counter", "name", "traverse", "optimizations", "generate", "disable", "obj"]
}
