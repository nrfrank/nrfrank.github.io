"use strict";import{NodeAbsentFunctionKinds as _,NodeAssertionKinds as C,NodeCharacterClassKinds as c,NodeCharacterSetKinds as o,NodeDirectiveKinds as d,NodeLookaroundAssertionKinds as b,NodeQuantifierKinds as f,NodeTypes as h}from"../parser/parse.js";import{cp as F,r as n,throwIfNot as y}from"../utils.js";function N(r){let e=null;const t={inCharClass:!1,lastNode:e,parent:null};function a(i){t.lastNode=e,e=i,t.lastNode&&I(t.lastNode)===i&&(t.parent=t.lastNode);const u=v[i.type];if(!u)throw new Error(`Unexpected node type "${i.type}"`);return u(i,t,a)}return a(r)}const v={Regex({pattern:r,flags:e},s,t){return{pattern:t(r),flags:t(e)}},AbsentFunction({kind:r,alternatives:e},s,t){if(r!==_.repeater)throw new Error(`Unexpected absent function kind "${r}"`);return`(?~${e.map(t).join("|")})`},Alternative({elements:r},e,s){return r.map(s).join("")},Assertion({kind:r,negate:e}){return r===C.grapheme_boundary?e?n`\Y`:n`\y`:r===C.word_boundary?e?n`\B`:n`\b`:y({line_end:"$",line_start:"^",search_start:n`\G`,string_end:n`\z`,string_end_newline:n`\Z`,string_start:n`\A`}[r],`Unexpected assertion kind "${r}"`)},Backreference({ref:r}){return typeof r=="number"?"\\"+r:`\\k<${r}>`},CapturingGroup(r,e,s){const{name:t,alternatives:a}=r;return`(${t?`?${t.includes(">")?`'${t}'`:`<${t}>`}`:""}${a.map(s).join("|")})`},Character({value:r},e){return E(r,{escDigit:e.lastNode.type===h.Backreference,inCharClass:e.inCharClass})},CharacterClass({kind:r,negate:e,elements:s},t,a){function i(){return t.parent.type===h.CharacterClass&&t.parent.kind===c.intersection&&r===c.union&&!s.length?"":`[${e?"^":""}${s.map(a).join(r===c.intersection?"&&":"")}]`}if(!t.inCharClass){t.inCharClass=!0;const u=i();return t.inCharClass=!1,u}return i()},CharacterClassRange({min:r,max:e},s,t){return`${t(r)}-${t(e)}`},CharacterSet({kind:r,negate:e,value:s},t){return r===o.digit?e?n`\D`:n`\d`:r===o.hex?e?n`\H`:n`\h`:r===o.newline?e?n`\N`:n`\R`:r===o.posix?t.inCharClass?`[:${e?"^":""}${s}:]`:`${e?n`\P`:n`\p`}{${s}}`:r===o.property?`${e?n`\P`:n`\p`}{${s}}`:r===o.space?e?n`\S`:n`\s`:r===o.word?e?n`\W`:n`\w`:y({any:n`\O`,dot:".",grapheme:n`\X`}[r],`Unexpected character set kind "${r}"`)},Directive({kind:r,flags:e}){if(r===d.flags){const{enable:s={},disable:t={}}=e,a=l(s),i=l(t);return a||i?`(?${a}${i?`-${i}`:""})`:""}if(r===d.keep)return n`\K`;throw new Error(`Unexpected directive kind "${r}"`)},Flags(r){return l(r)},Group({atomic:r,flags:e,alternatives:s},t,a){const i=s.map(a).join("|");return`(?${A(r,e)}${i})`},LookaroundAssertion({kind:r,negate:e,alternatives:s},t,a){return`(?${`${r===b.lookahead?"":"<"}${e?"!":"="}`}${s.map(a).join("|")})`},Pattern({alternatives:r},e,s){return r.map(s).join("|")},Quantifier({min:r,max:e,kind:s,element:t},a,i){if(r>e)throw new Error(`Invalid quantifier: min "${r}" > max "${e}"`);if(r>1&&e===1/0&&s===f.possessive)throw new Error(`Invalid possessive quantifier: min "${r}" with no max"`);if(r===e&&s===f.possessive)throw new Error(`Invalid possessive quantifier: min and max are equal "${r}"`);const u=t.type===h.Quantifier&&t.kind===f.greedy;let p,$=!1;!r&&e===1&&!u?p="?":!r&&e===1/0?p="*":r===1&&e===1/0&&!u?p="+":r===e?(p=`{${r}}`,$=!0):(p=s===f.possessive?`{${e},${r}}`:`{${r},${e===1/0?"":e}}`,$=!0);const g={greedy:"",lazy:"?",possessive:$?"":"+"}[s];return`${i(t)}${p}${g}`},Subroutine({ref:r}){return typeof r=="string"&&r.includes(">")?n`\g'${r}'`:n`\g<${r}>`}},S=new Set(["$","(",")","*","+",".","?","[","\\","^","{","|"]),x=new Set(["&","-","[","\\","]","^"]),w=new Map([[7,n`\a`],[9,n`\t`],[10,n`\n`],[11,n`\v`],[12,n`\f`],[13,n`\r`],[27,n`\e`],[8232,n`\u2028`],[8233,n`\u2029`],[65279,n`\uFEFF`]]);function E(r,{escDigit:e,inCharClass:s}){if(w.has(r))return w.get(r);if(r<32||r>126&&r<160||r>262143||e&&K(r))return r>127?`\\x{${r.toString(16).toUpperCase()}}`:`\\x${r.toString(16).toUpperCase().padStart(2,"0")}`;const t=s?x:S,a=F(r);return(t.has(a)?"\\":"")+a}function I(r){return r.alternatives?r.alternatives[0]:r.elements?r.elements[0]??null:r.element?r.element:r.min&&r.min.type?r.min:r.pattern?r.pattern:null}function l({ignoreCase:r,dotAll:e,extended:s,digitIsAscii:t,posixIsAscii:a,spaceIsAscii:i,wordIsAscii:u}){return`${r?"i":""}${e?"m":""}${s?"x":""}${t?"D":""}${a?"P":""}${i?"S":""}${u?"W":""}`}function A(r,e){if(r)return">";let s="";if(e){const{enable:t={},disable:a={}}=e,i=l(t),u=l(a);s=`${i}${u?`-${u}`:""}`}return`${s}:`}function K(r){return r>47&&r<58}export{N as generate};
//# sourceMappingURL=generate.js.map
