{
  "version": 3,
  "sources": ["../../../src/optimizer/transforms/extract-prefix-2.js"],
  "sourcesContent": ["import {isAllowedSimpleType, isNodeEqual} from './extract-prefix.js';\nimport {alternativeContainerTypes} from '../../parser/node-utils.js';\nimport {createAlternative, createGroup} from '../../parser/parse.js';\n\n/**\nExtract alternating prefixes if patterns are repeated for each prefix.\nAlso works within groups.\n- `^a|!a|^bb|!bb|^c|!c` -> `(?:^|!)(?:a|bb|c)`\n*/\nconst extractPrefix2 = {\n  '*'({node}) {\n    if (!alternativeContainerTypes.has(node.type)) {\n      return;\n    }\n    const numDiffPrefixes = 2;\n    const numAlts = node.alternatives.length;\n    if (numAlts < (numDiffPrefixes * 2) || numAlts % numDiffPrefixes) {\n      return;\n    }\n    const prefixAltElsByI = [...node.alternatives.slice(0, numDiffPrefixes).map(alt => alt.elements)];\n    const prefixNodesByI = Array.from({length: numDiffPrefixes}, _ => []);\n    const prefixIsFinishedByI = Array(numDiffPrefixes).fill(false);\n    const longestOf = Math.max(...prefixAltElsByI.map(els => els.length));\n    for (let nodeI = 0; nodeI < longestOf; nodeI++) {\n      for (let prefixI = 0; prefixI < numDiffPrefixes; prefixI++) {\n        if (!prefixIsFinishedByI[prefixI]) {\n          const nextNode = prefixAltElsByI[prefixI][nodeI];\n          if (\n            !nextNode ||\n            !isAllowedSimpleType(nextNode.type) ||\n            !isPrefixNodeShared(nextNode, node.alternatives, {prefixI, nodeI, numDiffPrefixes})\n          ) {\n            prefixIsFinishedByI[prefixI] = true;\n          } else {\n            prefixNodesByI[prefixI].push(nextNode);\n          }\n        }\n      }\n    }\n    if (!prefixNodesByI.some(nodes => nodes.length)) {\n      return;\n    }\n    const strippedAlts = [];\n    let counter = 0;\n    for (let i = 0; i < numAlts; i++) {\n      const alt = createAlternative();\n      alt.elements = node.alternatives[i].elements.slice(prefixNodesByI[counter].length);\n      strippedAlts.push(alt);\n      counter = counter < (numDiffPrefixes - 1) ? counter + 1 : 0;\n    }\n    // Check that each set of alts now use the same value after having had their prefixes removed\n    for (let i = 0; i < (numAlts / numDiffPrefixes); i++) {\n      const altComparisonSet = strippedAlts.slice(i * numDiffPrefixes, (i * numDiffPrefixes) + numDiffPrefixes);\n      for (let j = 1; j < altComparisonSet.length; j++) {\n        const els = altComparisonSet[j].elements;\n        if (els.length !== altComparisonSet[0].elements.length) {\n          return;\n        }\n        if (!els.every((el, k) => (\n          isAllowedSimpleType(el.type) &&\n          isNodeEqual(el, altComparisonSet[0].elements[k])\n        ))) {\n          return;\n        }\n      }\n    }\n    const newContents = createAlternative();\n    const prefixGroup = createGroup();\n    const prefixAlts = [];\n    for (let i = 0; i < numDiffPrefixes; i++) {\n      const alt = createAlternative();\n      alt.elements = prefixNodesByI[i];\n      prefixAlts.push(alt);\n    }\n    prefixGroup.alternatives = prefixAlts;\n    newContents.elements.push(prefixGroup);\n    const suffixGroup = createGroup();\n    // Only take one (unique) alt from each set of stripped alts\n    suffixGroup.alternatives = strippedAlts.filter((_, i) => i % numDiffPrefixes);\n    if (suffixGroup.alternatives.every(alt => !alt.elements.length)) {\n      node.alternatives = prefixGroup.alternatives;\n    } else {\n      newContents.elements.push(suffixGroup);\n      node.alternatives = [newContents];\n    }\n  },\n};\n\nfunction isPrefixNodeShared(node, alts, {prefixI, nodeI, numDiffPrefixes}) {\n  for (let i = prefixI; i < alts.length; i += numDiffPrefixes) {\n    const alt = alts[i];\n    const bNode = alt.elements[nodeI];\n    if (!bNode || !isNodeEqual(bNode, node)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport {\n  extractPrefix2,\n};\n"],
  "mappings": "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",
  "names": ["isAllowedSimpleType", "isNodeEqual", "alternativeContainerTypes", "createAlternative", "createGroup", "extractPrefix2", "node", "numDiffPrefixes", "numAlts", "prefixAltElsByI", "alt", "prefixNodesByI", "_", "prefixIsFinishedByI", "longestOf", "els", "nodeI", "prefixI", "nextNode", "isPrefixNodeShared", "nodes", "strippedAlts", "counter", "i", "altComparisonSet", "j", "el", "k", "newContents", "prefixGroup", "prefixAlts", "suffixGroup", "alts", "bNode"]
}
