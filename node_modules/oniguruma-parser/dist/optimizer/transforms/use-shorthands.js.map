{
  "version": 3,
  "sources": ["../../../src/optimizer/transforms/use-shorthands.js"],
  "sourcesContent": ["import {createCharacterSet, NodeCharacterClassKinds, NodeCharacterSetKinds, NodeTypes} from '../../parser/parse.js';\n\n/**\nUse shorthands (`\\d`, `\\h`, `\\s`, etc.) when possible.\n- `\\d` from `\\p{Decimal_Number}`, `\\p{Nd}`, `\\p{digit}`, `[[:digit:]]`\n- `\\h` from `\\p{ASCII_Hex_Digit}`, `\\p{AHex}`, `\\p{xdigit}`, `[[:xdigit:]]`, `[0-9A-Fa-f]`\n- `\\s` from `\\p{White_Space}`, `\\p{WSpace}`, `\\p{space}`, `[[:space:]]`\n- `\\w` from `[\\p{L}\\p{M}\\p{N}\\p{Pc}]` - Not the same as POSIX `\\p{word}`, `[[:word:]]`!\n- `\\O` from `\\p{Any}` if not in class\nSee also `useUnicodeProps`.\n*/\nconst useShorthands = {\n  CharacterSet({node, parent, root, replaceWith}) {\n    const {kind, negate, value} = node;\n    let newNode;\n    if (\n      ( kind === NodeCharacterSetKinds.property &&\n        (value === 'Decimal_Number' || value === 'Nd') &&\n        // [TODO] Also need to check whether these flags are set in local context, when the parser\n        // supports these flags on mode modifiers\n        !root.flags.digitIsAscii &&\n        !root.flags.posixIsAscii\n      ) ||\n      ( kind === NodeCharacterSetKinds.posix &&\n        value === 'digit'\n      )\n    ) {\n      newNode = createCharacterSet(NodeCharacterSetKinds.digit, {negate});\n    } else if (\n      ( kind === NodeCharacterSetKinds.property &&\n        (value === 'ASCII_Hex_Digit' || value === 'AHex')\n      ) ||\n      ( kind === NodeCharacterSetKinds.posix &&\n        value === 'xdigit'\n      )\n    ) {\n      newNode = createCharacterSet(NodeCharacterSetKinds.hex, {negate});\n    } else if (\n      ( kind === NodeCharacterSetKinds.property &&\n        (value === 'White_Space' || value === 'WSpace') &&\n        // [TODO] Also need to check whether these flags are set in local context, when the parser\n        // supports these flags on mode modifiers\n        !root.flags.spaceIsAscii &&\n        !root.flags.posixIsAscii\n      ) ||\n      ( kind === NodeCharacterSetKinds.posix &&\n        value === 'space'\n      )\n    ) {\n      newNode = createCharacterSet(NodeCharacterSetKinds.space, {negate});\n    } else if (\n      parent.type !== NodeTypes.CharacterClass &&\n      kind === NodeCharacterSetKinds.property &&\n      !negate &&\n      value === 'Any'\n    ) {\n      newNode = createCharacterSet(NodeCharacterSetKinds.any);\n    }\n\n    if (newNode) {\n      replaceWith(newNode);\n    }\n  },\n\n  CharacterClass({node, root}) {\n    if (node.kind !== NodeCharacterClassKinds.union) {\n      return;\n    }\n    const has = {\n      rangeDigit0To9: false,\n      rangeAToFLower: false,\n      rangeAToFUpper: false,\n      unicodeL: false,\n      unicodeM: false,\n      unicodeN: false,\n      unicodePc: false,\n    }\n    for (const kid of node.elements) {\n      if (kid.type === NodeTypes.CharacterClassRange) {\n        has.rangeDigit0To9 ||= isRange(kid, 48, 57); // '0' to '9'\n        has.rangeAToFLower ||= isRange(kid, 97, 102); // 'a' to 'f'\n        has.rangeAToFUpper ||= isRange(kid, 65, 70); // 'A' to 'F'\n      } else if (kid.type === NodeTypes.CharacterSet) {\n        has.unicodeL ||= isUnicode(kid, 'L');\n        has.unicodeM ||= isUnicode(kid, 'M');\n        has.unicodeN ||= isUnicode(kid, 'N');\n        has.unicodePc ||= isUnicode(kid, 'Pc', {supercategories: true});\n      }\n    }\n    if (has.rangeDigit0To9 && has.rangeAToFUpper && has.rangeAToFLower) {\n      node.elements = node.elements.filter(kid => !(\n        isRange(kid, 48, 57) || isRange(kid, 97, 102) || isRange(kid, 65, 70)\n      ));\n      node.elements.push(createCharacterSet(NodeCharacterSetKinds.hex));\n    }\n    if (\n      (has.unicodeL && has.unicodeM && has.unicodeN && has.unicodePc) &&\n      // [TODO] Also need to check whether these flags are set in local context, when the parser\n      // supports these flags on mode modifiers\n      !root.flags.wordIsAscii &&\n      !root.flags.posixIsAscii\n    ) {\n      node.elements = node.elements.filter(kid => !isUnicode(kid, ['L', 'M', 'N', 'Pc'], {\n        subcategories: true,\n      }));\n      node.elements.push(createCharacterSet(NodeCharacterSetKinds.word));\n    }\n  },\n};\n\nfunction isRange(node, min, max) {\n  return (\n    node.type === NodeTypes.CharacterClassRange &&\n    node.min.value === min &&\n    node.max.value === max\n  );\n}\n\nfunction isUnicode(node, value, options = {}) {\n  const names = Array.isArray(value) ? value : [value];\n  const expanded = [];\n  for (const v of names) {\n    expanded.push(v);\n    if (fullNames[v]) {\n      expanded.push(fullNames[v]);\n    }\n    if (options.supercategories && supercategories[v]) {\n      expanded.push(supercategories[v]);\n      if (fullNames[supercategories[v]]) {\n        expanded.push(fullNames[supercategories[v]]);\n      }\n    }\n    if (options.subcategories && subcategories[v]) {\n      expanded.push(...subcategories[v]);\n    }\n  }\n  return (\n    node.type === NodeTypes.CharacterSet &&\n    node.kind === NodeCharacterSetKinds.property &&\n    !node.negate &&\n    expanded.includes(node.value)\n  );\n}\n\nconst fullNames = {\n  L: 'Letter',\n  M: 'Mark',\n  N: 'Number',\n  P: 'Punctuation',\n};\n\nconst supercategories = {\n  Pc: 'P',\n};\n\nconst subcategories = {\n  L: ['Ll', 'Lm', 'Lo', 'Lt', 'Lu'],\n  M: ['Mc', 'Me', 'Mn'],\n  N: ['Nd', 'Nl', 'No'],\n};\n\nexport {\n  isRange,\n  useShorthands,\n};\n"],
  "mappings": "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",
  "names": ["createCharacterSet", "NodeCharacterClassKinds", "NodeCharacterSetKinds", "NodeTypes", "useShorthands", "node", "parent", "root", "replaceWith", "kind", "negate", "value", "newNode", "has", "kid", "isRange", "isUnicode", "min", "max", "options", "names", "expanded", "v", "fullNames", "supercategories", "subcategories"]
}
