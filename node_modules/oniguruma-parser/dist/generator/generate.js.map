{
  "version": 3,
  "sources": ["../../src/generator/generate.js"],
  "sourcesContent": ["import {NodeAbsentFunctionKinds, NodeAssertionKinds, NodeCharacterClassKinds, NodeCharacterSetKinds, NodeDirectiveKinds, NodeLookaroundAssertionKinds, NodeQuantifierKinds, NodeTypes} from '../parser/parse.js';\nimport {cp, r, throwIfNot} from '../utils.js';\n\n/**\nGenerates a Oniguruma `pattern` and `flags` from an `OnigurumaAst`.\n@param {import('../parser/parse.js').OnigurumaAst} ast\n@returns {{\n  pattern: string;\n  flags: string;\n}}\n*/\nfunction generate(ast) {\n  let lastNode = null;\n  let parent = null;\n  const state = {\n    inCharClass: false,\n    lastNode,\n    parent,\n  };\n  function gen(node) {\n    state.lastNode = lastNode;\n    lastNode = node;\n    if (state.lastNode && getFirstChild(state.lastNode) === node) {\n      state.parent = state.lastNode;\n    }\n    const fn = generator[node.type];\n    if (!fn) {\n      throw new Error(`Unexpected node type \"${node.type}\"`);\n    }\n    return fn(node, state, gen);\n  }\n  return gen(ast);\n}\n\nconst generator = {\n  Regex({pattern, flags}, _, gen) {\n    // Final result is an object; other node types return strings\n    return {\n      pattern: gen(pattern),\n      flags: gen(flags),\n    };\n  },\n\n  AbsentFunction({kind, alternatives}, _, gen) {\n    if (kind !== NodeAbsentFunctionKinds.repeater) {\n      throw new Error(`Unexpected absent function kind \"${kind}\"`);\n    }\n    return `(?~${alternatives.map(gen).join('|')})`;\n  },\n\n  Alternative({elements}, _, gen) {\n    return elements.map(gen).join('');\n  },\n\n  Assertion({kind, negate}) {\n    if (kind === NodeAssertionKinds.grapheme_boundary) {\n      return negate ? r`\\Y` : r`\\y`;\n    }\n    if (kind === NodeAssertionKinds.word_boundary) {\n      return negate ? r`\\B` : r`\\b`;\n    }\n    return throwIfNot({\n      line_end: '$',\n      line_start: '^',\n      search_start: r`\\G`,\n      string_end: r`\\z`,\n      string_end_newline: r`\\Z`,\n      string_start: r`\\A`,\n    }[kind], `Unexpected assertion kind \"${kind}\"`);\n  },\n\n  Backreference({ref}) {\n    if (typeof ref === 'number') {\n      // [TODO] Won't be safe to indiscriminately unenclose when forward backrefs are supported\n      return '\\\\' + ref;\n    }\n    // Onig doesn't allow chars `>` or `'` in backref names, so this is safe\n    return `\\\\k<${ref}>`;\n  },\n\n  CapturingGroup(node, _, gen) {\n    const {name, alternatives} = node;\n    const nameWrapper = name ? `?${name.includes('>') ? `'${name}'` : `<${name}>`}` : '';\n    return `(${nameWrapper}${alternatives.map(gen).join('|')})`;\n  },\n\n  Character({value}, state) {\n    return getCharEscape(value, {\n      escDigit: state.lastNode.type === NodeTypes.Backreference,\n      inCharClass: state.inCharClass,\n    });\n  },\n\n  CharacterClass({kind, negate, elements}, state, gen) {\n    function genClass() {\n      if (\n        state.parent.type === NodeTypes.CharacterClass &&\n        state.parent.kind === NodeCharacterClassKinds.intersection &&\n        kind === NodeCharacterClassKinds.union &&\n        !elements.length\n      ) {\n        // Prevent empty intersection like `[&&]` from becoming the invalid `[[]&&[]]`\n        return '';\n      }\n      return `[${negate ? '^' : ''}${\n        elements.map(gen).join(kind === NodeCharacterClassKinds.intersection ? '&&' : '')\n      }]`;\n    }\n    if (!state.inCharClass) {\n      // For the outermost char class, set state\n      state.inCharClass = true;\n      const result = genClass();\n      state.inCharClass = false;\n      return result;\n    }\n    return genClass();\n  },\n\n  CharacterClassRange({min, max}, _, gen) {\n    return `${gen(min)}-${gen(max)}`;\n  },\n\n  CharacterSet({kind, negate, value}, state) {\n    if (kind === NodeCharacterSetKinds.digit) {\n      return negate ? r`\\D` : r`\\d`;\n    }\n    if (kind === NodeCharacterSetKinds.hex) {\n      return negate ? r`\\H` : r`\\h`;\n    }\n    if (kind === NodeCharacterSetKinds.newline) {\n      return negate ? r`\\N` : r`\\R`;\n    }\n    if (kind === NodeCharacterSetKinds.posix) {\n      return state.inCharClass ?\n        `[:${negate ? '^' : ''}${value}:]` :\n        `${negate ? r`\\P` : r`\\p`}{${value}}`;\n    }\n    if (kind === NodeCharacterSetKinds.property) {\n      return `${negate ? r`\\P` : r`\\p`}{${value}}`;\n    }\n    if (kind === NodeCharacterSetKinds.space) {\n      return negate ? r`\\S` : r`\\s`;\n    }\n    if (kind === NodeCharacterSetKinds.word) {\n      return negate ? r`\\W` : r`\\w`;\n    }\n    return throwIfNot({\n      any: r`\\O`,\n      dot: '.',\n      grapheme: r`\\X`,\n    }[kind], `Unexpected character set kind \"${kind}\"`);\n  },\n\n  Directive({kind, flags}) {\n    if (kind === NodeDirectiveKinds.flags) {\n      const {enable = {}, disable = {}} = flags;\n      const enableStr = getFlagsStr(enable);\n      const disableStr = getFlagsStr(disable);\n      return (enableStr || disableStr) ? `(?${enableStr}${disableStr ? `-${disableStr}` : ''})` : '';\n    }\n    if (kind === NodeDirectiveKinds.keep) {\n      return r`\\K`;\n    }\n    throw new Error(`Unexpected directive kind \"${kind}\"`);\n  },\n\n  Flags(node) {\n    return getFlagsStr(node);\n  },\n\n  Group({atomic, flags, alternatives}, _, gen) {\n    const contents = alternatives.map(gen).join('|');\n    return `(?${getGroupPrefix(atomic, flags)}${contents})`;\n  },\n\n  LookaroundAssertion({kind, negate, alternatives}, _, gen) {\n    const prefix = `${kind === NodeLookaroundAssertionKinds.lookahead ? '' : '<'}${negate ? '!' : '='}`;\n    return `(?${prefix}${alternatives.map(gen).join('|')})`;\n  },\n\n  Pattern({alternatives}, _, gen) {\n    return alternatives.map(gen).join('|');\n  },\n\n  Quantifier({min, max, kind, element}, _, gen) {\n    // These errors shouldn't happen unless the AST is modified in an invalid way after parsing\n    if (min > max) {\n      throw new Error(`Invalid quantifier: min \"${min}\" > max \"${max}\"`);\n    }\n    if (min > 1 && max === Infinity && kind === NodeQuantifierKinds.possessive) {\n      // Onig reversed ranges are possessive but `{,n}` is greedy `{0,n}`, so there's no way to\n      // represent this without adding additional nodes that aren't in the AST\n      throw new Error(`Invalid possessive quantifier: min \"${min}\" with no max\"`);\n    }\n    if (min === max && kind === NodeQuantifierKinds.possessive) {\n      // Can't add a `+` suffix to a fixed `{n}` interval quantifier\n      throw new Error(`Invalid possessive quantifier: min and max are equal \"${min}\"`);\n    }\n    const kidIsGreedyQuantifier = element.type === NodeTypes.Quantifier && element.kind === NodeQuantifierKinds.greedy;\n    let base;\n    let interval = false;\n    if (!min && max === 1 && !kidIsGreedyQuantifier) {\n      base = '?';\n    } else if (!min && max === Infinity) {\n      base = '*';\n    } else if (min === 1 && max === Infinity && !kidIsGreedyQuantifier) {\n      base = '+';\n    } else if (min === max) {\n      base = `{${min}}`;\n      interval = true;\n    } else {\n      base = kind === NodeQuantifierKinds.possessive ?\n        `{${max},${min}}` :\n        `{${min},${max === Infinity ? '' : max}}`;\n      interval = true;\n    }\n    const suffix = {\n      greedy: '',\n      lazy: '?',\n      // Interval quantifiers are marked possessive by reversing their min/max; a `+` suffix would\n      // create a quantifier chain\n      possessive: interval ? '' : '+',\n    }[kind];\n    return `${gen(element)}${base}${suffix}`;\n  },\n\n  Subroutine({ref}) {\n    if (typeof ref === 'string' && ref.includes('>')) {\n      return r`\\g'${ref}'`;\n    }\n    return r`\\g<${ref}>`;\n  },\n};\n\nconst BaseEscapeChars = new Set([\n  '$', '(', ')', '*', '+', '.', '?', '[', '\\\\', '^', '{', '|',\n]);\nconst CharClassEscapeChars = new Set([\n  '&', '-', '[', '\\\\', ']', '^',\n]);\nconst CharCodeEscapeMap = new Map([\n  [ 7, r`\\a`], // bell\n  [ 9, r`\\t`], // horizontal tab\n  [10, r`\\n`], // line feed\n  [11, r`\\v`], // vertical tab\n  [12, r`\\f`], // form feed\n  [13, r`\\r`], // carriage return\n  [27, r`\\e`], // escape\n  [0x2028, r`\\u2028`], // line separator\n  [0x2029, r`\\u2029`], // paragraph separator\n  [0xFEFF, r`\\uFEFF`], // ZWNBSP/BOM\n]);\n\nfunction getCharEscape(codePoint, {escDigit, inCharClass}) {\n  if (CharCodeEscapeMap.has(codePoint)) {\n    return CharCodeEscapeMap.get(codePoint);\n  }\n  if (\n    // Control chars, etc.; condition modeled on the Chrome developer console's display for strings\n    codePoint < 32 || (codePoint > 126 && codePoint < 160) ||\n    // Unicode planes 4-16; unassigned, special purpose, and private use area\n    codePoint > 0x3FFFF ||\n    // Avoid corrupting a preceding backref by immediately following it with a literal digit\n    (escDigit && isDigitCharCode(codePoint))\n  ) {\n    // Don't convert codePoint `0` to `\\0` since that's corruptible by following literal digits\n    return codePoint > 0x7F ?\n      `\\\\x{${codePoint.toString(16).toUpperCase()}}` :\n      `\\\\x${codePoint.toString(16).toUpperCase().padStart(2, '0')}`;\n  }\n  const escapeChars = inCharClass ? CharClassEscapeChars : BaseEscapeChars;\n  const char = cp(codePoint);\n  return (escapeChars.has(char) ? '\\\\' : '') + char;\n}\n\nfunction getFirstChild(node) {\n  if (node.alternatives) {\n    return node.alternatives[0];\n  }\n  if (node.elements) {\n    return node.elements[0] ?? null;\n  }\n  if (node.element) {\n    return node.element;\n  }\n  if (node.min && node.min.type) {\n    return node.min;\n  }\n  if (node.pattern) {\n    return node.pattern;\n  }\n  return null;\n}\n\n/**\n@param {import('../tokenizer/tokenize.js').RegexFlags} node\n@returns {string}\n*/\nfunction getFlagsStr({ignoreCase, dotAll, extended, digitIsAscii, posixIsAscii, spaceIsAscii, wordIsAscii}) {\n  return `${\n    ignoreCase ? 'i' : ''\n  }${\n    dotAll ? 'm' : ''\n  }${\n    extended ? 'x' : ''\n  }${\n    digitIsAscii ? 'D' : ''\n  }${\n    posixIsAscii ? 'P' : ''\n  }${\n    spaceIsAscii ? 'S' : ''\n  }${\n    wordIsAscii ? 'W' : ''\n  }`;\n}\n\n/**\n@param {boolean} atomic\n@param {import('../parser/parse.js').FlagGroupModifiers} flagMods\n@returns {string}\n*/\nfunction getGroupPrefix(atomic, flagMods) {\n  if (atomic) {\n    return '>';\n  }\n  let mods = '';\n  if (flagMods) {\n    const {enable = {}, disable = {}} = flagMods;\n    const enableStr = getFlagsStr(enable);\n    const disableStr = getFlagsStr(disable);\n    mods = `${enableStr}${disableStr ? `-${disableStr}` : ''}`;\n  }\n  return `${mods}:`;\n}\n\nfunction isDigitCharCode(value) {\n  return value > 47 && value < 58;\n}\n\nexport {\n  generate,\n};\n"],
  "mappings": "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",
  "names": ["NodeAbsentFunctionKinds", "NodeAssertionKinds", "NodeCharacterClassKinds", "NodeCharacterSetKinds", "NodeDirectiveKinds", "NodeLookaroundAssertionKinds", "NodeQuantifierKinds", "NodeTypes", "cp", "r", "throwIfNot", "generate", "ast", "lastNode", "state", "gen", "node", "getFirstChild", "fn", "generator", "pattern", "flags", "_", "kind", "alternatives", "elements", "negate", "ref", "name", "value", "getCharEscape", "genClass", "result", "min", "max", "enable", "disable", "enableStr", "getFlagsStr", "disableStr", "atomic", "contents", "getGroupPrefix", "element", "kidIsGreedyQuantifier", "base", "interval", "suffix", "BaseEscapeChars", "CharClassEscapeChars", "CharCodeEscapeMap", "codePoint", "escDigit", "inCharClass", "isDigitCharCode", "escapeChars", "char", "ignoreCase", "dotAll", "extended", "digitIsAscii", "posixIsAscii", "spaceIsAscii", "wordIsAscii", "flagMods", "mods"]
}
