{
  "version": 3,
  "sources": ["../../src/traverser/traverse.js"],
  "sourcesContent": ["import {NodeTypes} from '../parser/parse.js';\nimport {throwIfNot} from '../utils.js';\n\n/**\n@typedef {{\n  node: import('../parser/parse.js').Node;\n  parent: import('../parser/parse.js').Node?;\n  key: (number | string)?;\n  container: Array<import('../parser/parse.js').Node>?;\n  root: import('../parser/parse.js').RegexNode;\n  remove: () => void;\n  removeAllNextSiblings: () => Array<import('../parser/parse.js').Node>;\n  removeAllPrevSiblings: () => Array<import('../parser/parse.js').Node>;\n  replaceWith: (newNode: import('../parser/parse.js').Node, options?: {traverse?: boolean}) => void;\n  replaceWithMultiple: (newNodes: Array<import('../parser/parse.js').Node>, options?: {traverse?: boolean}) => void;\n  skip: () => void;\n}} Path\n@typedef {\n  ( path: Path,\n    state: {\n      [key: string]: any;\n    }\n  ) => void\n} Transformer\n*/\n\n/**\n@param {import('../parser/parse.js').OnigurumaAst} ast\n@param {{\n  [key in ('*' | import('../parser/parse.js').NodeType)]?: Transformer | {enter?: Transformer, exit?: Transformer};\n}} visitor\n@param {{\n  [key: string]: any;\n}} [state]\n*/\nfunction traverse(ast, visitor, state = null) {\n  function traverseArray(array, parent) {\n    for (let i = 0; i < array.length; i++) {\n      const keyShift = traverseNode(array[i], parent, i, array);\n      i = Math.max(-1, i + keyShift);\n    }\n  }\n  function traverseNode(node, parent = null, key = null, container = null) {\n    const containerExpected = 'Container expected';\n    let keyShift = 0;\n    let skipTraversingKidsOfPath = false;\n    const path = {\n      node,\n      parent,\n      key,\n      container,\n      root: ast,\n      remove() {\n        throwIfNot(container, containerExpected).splice(Math.max(0, key + keyShift), 1);\n        keyShift--;\n        skipTraversingKidsOfPath = true;\n      },\n      removeAllNextSiblings() {\n        return throwIfNot(container, containerExpected).splice(key + 1);\n      },\n      removeAllPrevSiblings() {\n        const shifted = key + keyShift;\n        keyShift -= shifted;\n        return throwIfNot(container, containerExpected).splice(0, Math.max(0, shifted));\n      },\n      replaceWith(newNode, options = {}) {\n        const traverseNew = !!options.traverse;\n        if (container) {\n          container[Math.max(0, key + keyShift)] = newNode;\n        } else {\n          parent[key] = newNode;\n        }\n        if (traverseNew) {\n          traverseNode(newNode, parent, key, container);\n        }\n        skipTraversingKidsOfPath = true;\n      },\n      replaceWithMultiple(newNodes, options = {}) {\n        const traverseNew = !!options.traverse;\n        throwIfNot(container, containerExpected).splice(Math.max(0, key + keyShift), 1, ...newNodes);\n        keyShift += newNodes.length - 1;\n        if (traverseNew) {\n          let keyShiftInLoop = 0;\n          for (let i = 0; i < newNodes.length; i++) {\n            keyShiftInLoop += traverseNode(newNodes[i], parent, key + i + keyShiftInLoop, container);\n          }\n        }\n        skipTraversingKidsOfPath = true;\n      },\n      skip() {\n        skipTraversingKidsOfPath = true;\n      },\n    };\n\n    const anyType = visitor['*'];\n    const thisType = visitor[node.type];\n    const enterAllFn = typeof anyType === 'function' ? anyType : anyType?.enter;\n    const enterThisFn = typeof thisType === 'function' ? thisType : thisType?.enter;\n    enterAllFn?.(path, state);\n    enterThisFn?.(path, state);\n\n    if (!skipTraversingKidsOfPath) {\n      switch (node.type) {\n        case NodeTypes.Regex:\n          traverseNode(node.pattern, node, 'pattern');\n          traverseNode(node.flags, node, 'flags');\n          break;\n        case NodeTypes.Alternative:\n        case NodeTypes.CharacterClass:\n          traverseArray(node.elements, node);\n          break;\n        case NodeTypes.Assertion:\n        case NodeTypes.Backreference:\n        case NodeTypes.Character:\n        case NodeTypes.CharacterSet:\n        case NodeTypes.Directive:\n        case NodeTypes.Flags:\n        case NodeTypes.Recursion:\n        case NodeTypes.Subroutine:\n          break;\n        case NodeTypes.AbsentFunction:\n        case NodeTypes.CapturingGroup:\n        case NodeTypes.Group:\n        case NodeTypes.Pattern:\n          traverseArray(node.alternatives, node);\n          break;\n        case NodeTypes.CharacterClassRange:\n          traverseNode(node.min, node, 'min');\n          traverseNode(node.max, node, 'max');\n          break;\n        case NodeTypes.LookaroundAssertion:\n          traverseArray(node.alternatives, node);\n          break;\n        case NodeTypes.Quantifier:\n          traverseNode(node.element, node, 'element');\n          break;\n        default:\n          throw new Error(`Unexpected node type \"${node.type}\"`);\n      }\n    }\n\n    anyType?.exit?.(path, state);\n    thisType?.exit?.(path, state);\n    return keyShift;\n  }\n  traverseNode(ast);\n}\n\nexport {\n  traverse,\n};\n"],
  "mappings": "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",
  "names": ["NodeTypes", "throwIfNot", "traverse", "ast", "visitor", "state", "traverseArray", "array", "parent", "i", "keyShift", "traverseNode", "node", "key", "container", "containerExpected", "skipTraversingKidsOfPath", "path", "shifted", "newNode", "options", "traverseNew", "newNodes", "keyShiftInLoop", "anyType", "thisType", "enterAllFn", "enterThisFn"]
}
