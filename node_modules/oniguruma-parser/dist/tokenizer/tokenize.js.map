{
  "version": 3,
  "sources": ["../../src/tokenizer/tokenize.js"],
  "sourcesContent": ["import {PosixClassNames, r} from '../utils.js';\n\nconst TokenTypes = /** @type {const} */ ({\n  Alternator: 'Alternator',\n  Assertion: 'Assertion',\n  Backreference: 'Backreference',\n  Character: 'Character',\n  CharacterClassClose: 'CharacterClassClose',\n  CharacterClassHyphen: 'CharacterClassHyphen',\n  CharacterClassIntersector: 'CharacterClassIntersector',\n  CharacterClassOpen: 'CharacterClassOpen',\n  CharacterSet: 'CharacterSet',\n  Directive: 'Directive',\n  GroupClose: 'GroupClose',\n  GroupOpen: 'GroupOpen',\n  Subroutine: 'Subroutine',\n  Quantifier: 'Quantifier',\n  // Intermediate representation not included in results\n  EscapedNumber: 'EscapedNumber',\n});\n\nconst TokenCharacterSetKinds = /** @type {const} */ ({\n  any: 'any',\n  digit: 'digit',\n  dot: 'dot',\n  grapheme: 'grapheme',\n  hex: 'hex',\n  newline: 'newline',\n  posix: 'posix',\n  property: 'property',\n  space: 'space',\n  word: 'word',\n});\n\nconst TokenDirectiveKinds = /** @type {const} */ ({\n  flags: 'flags',\n  keep: 'keep',\n});\n\nconst TokenGroupKinds = /** @type {const} */ ({\n  absent_repeater: 'absent_repeater',\n  atomic: 'atomic',\n  capturing: 'capturing',\n  group: 'group',\n  lookahead: 'lookahead',\n  lookbehind: 'lookbehind',\n});\n\nconst TokenQuantifierKinds = /** @type {const} */ ({\n  greedy: 'greedy',\n  lazy: 'lazy',\n  possessive: 'possessive',\n});\n\nconst EscapeCharCodes = new Map([\n  ['a',  7], // alert/bell (Not available in JS)\n  ['b',  8], // backspace (only in char classes)\n  ['e', 27], // escape (Not available in JS)\n  ['f', 12], // form feed\n  ['n', 10], // line feed\n  ['r', 13], // carriage return\n  ['t',  9], // horizontal tab\n  ['v', 11], // vertical tab\n]);\n\nconst charClassOpenPattern = r`\\[\\^?`;\nconst sharedEscapesPattern = `${\n  // Control char\n  'c.? | C(?:-.?)?'\n}|${\n  // Unicode property; Onig considers `\\p` an identity escape, but e.g. `\\p{`, `\\p{ ^L}`, and\n  // `\\p{gc=L}` are invalid\n  r`[pP]\\{(?:\\^?[-\\x20_]*[A-Za-z][-\\x20\\w]*\\})?`\n}|${\n  // Hex encoded byte sequence; attempt match before other `\\xNN` hex char\n  r`x[89A-Fa-f]\\p{AHex}(?:\\\\x[89A-Fa-f]\\p{AHex})*`\n}|${\n  // Hex char\n  r`u(?:\\p{AHex}{4})? | x\\{[^\\}]*\\}? | x\\p{AHex}{0,2}`\n}|${\n  // Enclosed octal code point\n  r`o\\{[^\\}]*\\}?`\n}|${\n  // Escaped number\n  r`\\d{1,3}`\n}`;\n// Even with flag x, Onig doesn't allow whitespace to separate a quantifier from the `?` or `+`\n// that makes it lazy or possessive. Possessive suffixes don't apply to interval quantifiers\nconst quantifierRe = /[?*+][?+]?|\\{(?:\\d+(?:,\\d*)?|,\\d+)\\}\\??/;\nconst tokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | [gk]<[^>]*>?\n    | [gk]'[^']*'?\n    | .\n  )\n  | \\( (?:\n    \\? (?:\n      [:=!>({]\n      | <[=!]\n      | <[^>]*>\n      | '[^']*'\n      | ~\\|?\n      | #(?:[^)\\\\]|\\\\.?)*\n      | [^:)]*[:)]\n    )?\n    | \\*\n  )?\n  | ${quantifierRe.source}\n  | ${charClassOpenPattern}\n  | .\n`.replace(/\\s+/g, ''), 'gsu');\nconst charClassTokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | .\n  )\n  | \\[:(?:\\^?\\p{Alpha}+|\\^):\\]\n  | ${charClassOpenPattern}\n  | &&\n  | .\n`.replace(/\\s+/g, ''), 'gsu');\n\n/**\n@typedef {{\n  ignoreCase: boolean;\n  dotAll: boolean;\n  extended: boolean;\n  digitIsAscii: boolean;\n  posixIsAscii: boolean;\n  spaceIsAscii: boolean;\n  wordIsAscii: boolean;\n}} RegexFlags\n@typedef {{\n  type: keyof TokenTypes;\n  raw: string;\n  [key: string]: string | number | boolean;\n}} Token\n@typedef {{\n  tokens: Array<Token>;\n  flags: RegexFlags;\n}} TokenizerResult\n*/\n/**\n@param {string} pattern Oniguruma pattern.\n@param {{\n  flags?: string;\n  rules?: {\n    captureGroup?: boolean;\n    singleline?: boolean;\n  };\n}} [options]\n@returns {TokenizerResult}\n*/\nfunction tokenize(pattern, options = {}) {\n  const opts = {\n    flags: '',\n    ...options,\n    rules: {\n      captureGroup: false, // `ONIG_OPTION_CAPTURE_GROUP`\n      singleline: false, // `ONIG_OPTION_SINGLELINE`\n      ...options.rules,\n    },\n  };\n  if (typeof pattern !== 'string') {\n    throw new Error('String expected as pattern');\n  }\n  const flagsObj = getFlagsObj(opts.flags);\n  const xStack = [flagsObj.extended];\n  const context = {\n    captureGroup: opts.rules.captureGroup,\n    getCurrentModX: () => xStack.at(-1),\n    numOpenGroups: 0,\n    popModX() {xStack.pop()},\n    pushModX(isXOn) {xStack.push(isXOn)},\n    replaceCurrentModX(isXOn) {xStack[xStack.length - 1] = isXOn},\n    singleline: opts.rules.singleline,\n  };\n  let tokens = [];\n  let match;\n  tokenRe.lastIndex = 0;\n  while ((match = tokenRe.exec(pattern))) {\n    const result = getTokenWithDetails(context, pattern, match[0], tokenRe.lastIndex);\n    if (result.tokens) {\n      tokens.push(...result.tokens);\n    } else if (result.token) {\n      tokens.push(result.token);\n    }\n    if (result.lastIndex !== undefined) {\n      tokenRe.lastIndex = result.lastIndex;\n    }\n  }\n\n  const potentialUnnamedCaptureTokens = [];\n  let numNamedAndOptInUnnamedCaptures = 0;\n  tokens.forEach(t => {\n    if (t.type === TokenTypes.GroupOpen) {\n      if (t.kind === TokenGroupKinds.capturing) {\n        t.number = ++numNamedAndOptInUnnamedCaptures;\n      } else if (t.raw === '(') {\n        potentialUnnamedCaptureTokens.push(t);\n      }\n    }\n  });\n  // Enable unnamed capturing groups if no named captures (when `captureGroup` not enabled)\n  if (!numNamedAndOptInUnnamedCaptures) {\n    potentialUnnamedCaptureTokens.forEach((t, i) => {\n      t.kind = TokenGroupKinds.capturing;\n      t.number = i + 1;\n    });\n  }\n  const numCaptures = numNamedAndOptInUnnamedCaptures || potentialUnnamedCaptureTokens.length;\n  // Can now split escaped nums accurately, accounting for number of captures\n  tokens = tokens.map(\n    t => t.type === TokenTypes.EscapedNumber ? splitEscapedNumToken(t, numCaptures) : t\n  ).flat();\n\n  return {\n    tokens,\n    flags: flagsObj,\n  };\n}\n\nfunction getTokenWithDetails(context, pattern, m, lastIndex) {\n  const [m0, m1] = m;\n\n  if (m0 === '[') {\n    const result = getAllTokensForCharClass(pattern, m, lastIndex);\n    return {\n      // Array of all of the char class's tokens\n      tokens: result.tokens,\n      // Jump forward to the end of the char class\n      lastIndex: result.lastIndex,\n    };\n  }\n\n  if (m0 === '\\\\') {\n    if ('AbBGyYzZ'.includes(m1)) {\n      return {\n        token: createToken(TokenTypes.Assertion, m, {\n          kind: m,\n        }),\n      };\n    }\n    if (/^\\\\g[<']/.test(m)) {\n      if (!/^\\\\g(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.Subroutine, m),\n      };\n    }\n    if (/^\\\\k[<']/.test(m)) {\n      if (!/^\\\\k(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.Backreference, m),\n      };\n    }\n    if (m1 === 'K') {\n      return {\n        token: createToken(TokenTypes.Directive, m, {\n          kind: TokenDirectiveKinds.keep,\n        }),\n      };\n    }\n    if (m1 === 'N' || m1 === 'R') {\n      return {\n        token: createToken(TokenTypes.CharacterSet, m, {\n          kind: TokenCharacterSetKinds.newline,\n          // `\\N` and `\\R` are not actually opposites since the former only excludes `\\n`\n          negate: m1 === 'N',\n        }),\n      };\n    }\n    if (m1 === 'O') {\n      return {\n        token: createToken(TokenTypes.CharacterSet, m, {\n          kind: TokenCharacterSetKinds.any,\n        }),\n      };\n    }\n    if (m1 === 'X') {\n      return {\n        token: createToken(TokenTypes.CharacterSet, m, {\n          kind: TokenCharacterSetKinds.grapheme,\n        }),\n      };\n    }\n    // Run last since it assumes an identity escape as final condition\n    const result = createTokenForSharedEscape(m, {inCharClass: false});\n    return Array.isArray(result) ? {tokens: result} : {token: result};\n  }\n\n  if (m0 === '(') {\n    if (m === '(*') {\n      throw new Error(`Unsupported named callout \"${m}\"`);\n    }\n    if (m === '(?{') {\n      throw new Error(`Unsupported callout \"${m}\"`);\n    }\n    // Comment group\n    if (m.startsWith('(?#')) {\n      // Everything except the closing unescaped `)` is included in the match\n      if (pattern[lastIndex] !== ')') {\n        throw new Error('Unclosed comment group \"(?#\"');\n      }\n      return {\n        // Jump forward to after the closing paren\n        lastIndex: lastIndex + 1,\n      };\n    }\n    // Flag modifier (directive or group opener)\n    if (/^\\(\\?[-imx]+[:)]$/.test(m)) {\n      return {\n        token: createTokenForFlagMod(m, context),\n      };\n    }\n    // --- Remaining group types all reuse current flag x status ---\n    context.pushModX(context.getCurrentModX());\n    context.numOpenGroups++;\n    if (\n      // Unnamed capture if no named captures present and `captureGroup` not enabled, else\n      // noncapturing group\n      (m === '(' && !context.captureGroup) ||\n      // Noncapturing group\n      m === '(?:'\n    ) {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          // For `(`, will later change to `capturing` and add `number` prop if no named captures\n          kind: TokenGroupKinds.group,\n        }),\n      };\n    }\n    // Atomic group\n    if (m === '(?>') {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: TokenGroupKinds.atomic,\n        }),\n      };\n    }\n    // Lookaround\n    if (m === '(?=' || m === '(?!' || m === '(?<=' || m === '(?<!') {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: m[2] === '<' ? TokenGroupKinds.lookbehind : TokenGroupKinds.lookahead,\n          negate: m.endsWith('!'),\n        }),\n      };\n    }\n    // Unnamed capture when `captureGroup` enabled, or named capture (checked after lookbehind due\n    // to similar syntax)\n    if (\n      (m === '(' && context.captureGroup) ||\n      (m.startsWith('(?<') && m.endsWith('>')) ||\n      (m.startsWith(\"(?'\") && m.endsWith(\"'\"))\n    ) {\n      const token = createToken(TokenTypes.GroupOpen, m, {\n        kind: TokenGroupKinds.capturing,\n        // Will add `number` prop in a second pass\n      });\n      if (m !== '(') {\n        token.name = m.slice(3, -1);\n      }\n      return {\n        token,\n      };\n    }\n    if (m.startsWith('(?~')) {\n      if (m === '(?~|') {\n        throw new Error(`Unsupported absent function kind \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: TokenGroupKinds.absent_repeater,\n        }),\n      };\n    }\n    if (m === '(?(') {\n      // Some forms are supportable; can be added\n      throw new Error(`Unsupported conditional \"${m}\"`);\n    }\n    throw new Error(`Invalid or unsupported group option \"${m}\"`);\n  }\n  if (m === ')') {\n    context.popModX();\n    context.numOpenGroups--;\n    if (context.numOpenGroups < 0) {\n      throw new Error('Unmatched \")\"');\n    }\n    return {\n      token: createToken(TokenTypes.GroupClose, m),\n    };\n  }\n\n  if (m === '#' && context.getCurrentModX()) {\n    // Onig's only line break char is line feed\n    const end = pattern.indexOf('\\n', lastIndex);\n    return {\n      // Jump forward to the end of the comment\n      lastIndex: end === -1 ? pattern.length : end,\n    };\n  }\n  if (/^\\s$/.test(m) && context.getCurrentModX()) {\n    const re = /\\s+/y;\n    re.lastIndex = lastIndex;\n    const rest = re.exec(pattern);\n    return {\n      // Jump forward to the end of the whitespace\n      lastIndex: rest ? re.lastIndex : lastIndex,\n    };\n  }\n\n  if (m === '.') {\n    return {\n      token: createToken(TokenTypes.CharacterSet, m, {\n        kind: TokenCharacterSetKinds.dot,\n      }),\n    };\n  }\n\n  if (m === '^' || m === '$') {\n    const kind = context.singleline ? {\n      '^': r`\\A`,\n      '$': r`\\Z`,\n    }[m] : m;\n    return {\n      token: createToken(TokenTypes.Assertion, m, {\n        kind,\n      }),\n    };\n  }\n\n  if (m === '|') {\n    return {\n      token: createToken(TokenTypes.Alternator, m),\n    };\n  }\n\n  if (quantifierRe.test(m)) {\n    return {\n      token: createTokenForQuantifier(m),\n    };\n  }\n\n  assertSingleCodePoint(m);\n  return {\n    token: createToken(TokenTypes.Character, m, {\n      value: m.codePointAt(0),\n    }),\n  };\n}\n\nfunction getAllTokensForCharClass(pattern, opener, lastIndex) {\n  const tokens = [createToken(TokenTypes.CharacterClassOpen, opener, {\n    negate: opener[1] === '^',\n  })];\n  let numCharClassesOpen = 1;\n  let match;\n  charClassTokenRe.lastIndex = lastIndex;\n  while ((match = charClassTokenRe.exec(pattern))) {\n    const m = match[0];\n    // Start of nested char class\n    // POSIX classes are handled as a single token; not as a nested char class\n    if (m[0] === '[' && m[1] !== ':') {\n      numCharClassesOpen++;\n      tokens.push(createToken(TokenTypes.CharacterClassOpen, m, {\n        negate: m[1] === '^',\n      }));\n    } else if (m === ']') {\n      if (tokens.at(-1).type === TokenTypes.CharacterClassOpen) {\n        // Allow unescaped `]` as leading char\n        tokens.push(createToken(TokenTypes.Character, m, {\n          value: 93,\n        }));\n      } else {\n        numCharClassesOpen--;\n        tokens.push(createToken(TokenTypes.CharacterClassClose, m));\n        if (!numCharClassesOpen) {\n          break;\n        }\n      }\n    } else {\n      const result = createTokenForAnyTokenWithinCharClass(m);\n      if (Array.isArray(result)) {\n        tokens.push(...result);\n      } else {\n        tokens.push(result);\n      }\n    }\n  }\n  return {\n    tokens,\n    lastIndex: charClassTokenRe.lastIndex || pattern.length,\n  }\n}\n\nfunction createTokenForAnyTokenWithinCharClass(raw) {\n  if (raw[0] === '\\\\') {\n    // Assumes an identity escape as final condition\n    return createTokenForSharedEscape(raw, {inCharClass: true});\n  }\n  // POSIX class: `[:name:]` or `[:^name:]`\n  if (raw[0] === '[') {\n    const posix = /\\[:(?<negate>\\^?)(?<name>[a-z]+):\\]/.exec(raw);\n    if (!posix || !PosixClassNames.has(posix.groups.name)) {\n      throw new Error(`Invalid POSIX class \"${raw}\"`);\n    }\n    return createToken(TokenTypes.CharacterSet, raw, {\n      kind: TokenCharacterSetKinds.posix,\n      value: posix.groups.name,\n      negate: !!posix.groups.negate,\n    });\n  }\n  // Range (possibly invalid) or literal hyphen\n  if (raw === '-') {\n    return createToken(TokenTypes.CharacterClassHyphen, raw);\n  }\n  if (raw === '&&') {\n    return createToken(TokenTypes.CharacterClassIntersector, raw);\n  }\n  assertSingleCodePoint(raw);\n  return createToken(TokenTypes.Character, raw, {\n    value: raw.codePointAt(0),\n  });\n}\n\n// Tokens shared by base syntax and char class syntax that start with `\\`\nfunction createTokenForSharedEscape(raw, {inCharClass}) {\n  const char1 = raw[1];\n  if (char1 === 'c' || char1 === 'C') {\n    return createTokenForControlChar(raw);\n  }\n  if ('dDhHsSwW'.includes(char1)) {\n    return createTokenForShorthandCharClass(raw);\n  }\n  if (raw.startsWith(r`\\o{`)) {\n    throw new Error(`Incomplete, invalid, or unsupported octal code point \"${raw}\"`);\n  }\n  if (/^\\\\[pP]\\{/.test(raw)) {\n    if (raw.length === 3) {\n      throw new Error(`Incomplete or invalid Unicode property \"${raw}\"`);\n    }\n    return createTokenForUnicodeProperty(raw);\n  }\n  // Hex UTF-8 encoded byte sequence\n  if (/^\\\\x[89A-Fa-f]\\p{AHex}/u.test(raw)) {\n    try {\n      const bytes = raw.split(/\\\\x/).slice(1).map(hex => parseInt(hex, 16));\n      const decoded = new TextDecoder('utf-8', {\n        ignoreBOM: true,\n        fatal: true,\n      }).decode(new Uint8Array(bytes));\n      const encoder = new TextEncoder();\n      const tokens = [...decoded].map(char => {\n        // Since this regenerates `raw`, it might have different casing for hex A-F than the input\n        const raw = [...encoder.encode(char)].map(byte => `\\\\x${byte.toString(16)}`).join('');\n        return createToken(TokenTypes.Character, raw, {\n          value: char.codePointAt(0),\n        });\n      });\n      return tokens;\n    } catch {\n      throw new Error(`Multibyte code \"${raw}\" incomplete or invalid in Oniguruma`);\n    }\n  }\n  if (char1 === 'u' || char1 === 'x') {\n    return createToken(TokenTypes.Character, raw, {\n      value: getValidatedHexCharCode(raw),\n    });\n  }\n  if (EscapeCharCodes.has(char1)) {\n    return createToken(TokenTypes.Character, raw, {\n      value: EscapeCharCodes.get(char1),\n    });\n  }\n  // Escaped number: backref (possibly invalid), null, octal, or identity escape, possibly followed\n  // by 1-2 literal digits\n  if (/\\d/.test(char1)) {\n    return createToken(TokenTypes.EscapedNumber, raw, {\n      inCharClass,\n    });\n  }\n  if (raw === '\\\\') {\n    throw new Error(r`Incomplete escape \"\\\"`);\n  }\n  // Meta `\\M-x` and `\\M-\\C-x` are unsupported; avoid treating as an identity escape\n  if (char1 === 'M') {\n    // Supportable; see:\n    // - <github.com/kkos/oniguruma/blob/master/doc/SYNTAX.md#12-onig_syn_op2_esc_capital_m_bar_meta-enable-m-x>\n    // - <github.com/kkos/oniguruma/blob/43a8c3f3daf263091f3a74019d4b32ebb6417093/src/regparse.c#L4695>\n    // - <github.com/ammar/regexp_parser/blob/8851030feda68223d74f502335fb254a20d77016/lib/regexp_parser/expression/classes/escape_sequence.rb#L75>\n    throw new Error(`Unsupported meta \"${raw}\"`);\n  }\n  // Identity escape; count code point length\n  if ([...raw].length === 2) {\n    return createToken(TokenTypes.Character, raw, {\n      value: raw.codePointAt(1),\n    });\n  }\n  throw new Error(`Unexpected escape \"${raw}\"`);\n}\n\n/**\n@param {keyof TokenTypes} type\n@param {string} raw\n@param {{[key: string]: string | number | boolean;}} [data]\n@returns {Token}\n*/\nfunction createToken(type, raw, data) {\n  return {\n    type,\n    raw,\n    ...data,\n  };\n}\n\n// Expects `\\cx` or `\\C-x`\nfunction createTokenForControlChar(raw) {\n  const char = raw[1] === 'c' ? raw[2] : raw[3];\n  if (!char || !/[A-Za-z]/.test(char)) {\n    // Unlike JS, Onig allows any char to follow `\\c` or `\\C-`, but this is an extreme edge case\n    // Supportable; see <github.com/kkos/oniguruma/blob/master/doc/SYNTAX.md#11-onig_syn_op2_esc_capital_c_bar_control-enable-c-x>, <github.com/kkos/oniguruma/blob/43a8c3f3daf263091f3a74019d4b32ebb6417093/src/regparse.c#L4695>\n    throw new Error(`Unsupported control character \"${raw}\"`);\n  }\n  return createToken(TokenTypes.Character, raw, {\n    value: char.toUpperCase().codePointAt(0) - 64,\n  });\n}\n\nfunction createTokenForFlagMod(raw, context) {\n  // Allows multiple `-` and solo `-` without `on` or `off` flags\n  let {on, off} = /^\\(\\?(?<on>[imx]*)(?:-(?<off>[-imx]*))?/.exec(raw).groups;\n  off ??= '';\n  // Flag x is used directly by the tokenizer since it changes how to interpret the pattern\n  const isXOn = (context.getCurrentModX() || on.includes('x')) && !off.includes('x');\n  const enabledFlags = getFlagGroupSwitches(on);\n  const disabledFlags = getFlagGroupSwitches(off);\n  const flagChanges = {};\n  enabledFlags && (flagChanges.enable = enabledFlags);\n  disabledFlags && (flagChanges.disable = disabledFlags);\n  // Flag directive; ex: `(?im-x)`\n  if (raw.endsWith(')')) {\n    // Replace flag x value until the end of the current group\n    context.replaceCurrentModX(isXOn);\n    // Can't remove flag directives without flags like `(?-)`; they affect following quantifiers\n    return createToken(TokenTypes.Directive, raw, {\n      kind: TokenDirectiveKinds.flags,\n      flags: flagChanges,\n    });\n  }\n  // Flag group opener; ex: `(?im-x:`\n  if (raw.endsWith(':')) {\n    context.pushModX(isXOn);\n    context.numOpenGroups++;\n    const token = createToken(TokenTypes.GroupOpen, raw, {\n      kind: TokenGroupKinds.group,\n    });\n    if (enabledFlags || disabledFlags) {\n      token.flags = flagChanges;\n    }\n    return token;\n  }\n  throw new Error(`Unexpected flag modifier \"${raw}\"`);\n}\n\nfunction createTokenForQuantifier(raw) {\n  const data = {};\n  if (raw[0] === '{') {\n    const {min, max} = /^\\{(?<min>\\d*)(?:,(?<max>\\d*))?/.exec(raw).groups;\n    const limit = 100_000;\n    if (+min > limit || +max > limit) {\n      throw new Error('Quantifier value unsupported in Oniguruma');\n    }\n    data.min = +min;\n    data.max = max === undefined ? +min : (max === '' ? Infinity : +max);\n    // By default, Onig doesn't support making interval quantifiers possessive with a `+` suffix\n    data.kind = raw.endsWith('?') ? TokenQuantifierKinds.lazy : TokenQuantifierKinds.greedy;\n  } else {\n    data.min = raw[0] === '+' ? 1 : 0;\n    data.max = raw[0] === '?' ? 1 : Infinity;\n    data.kind = raw[1] === '+' ?\n      TokenQuantifierKinds.possessive :\n      (raw[1] === '?' ? TokenQuantifierKinds.lazy : TokenQuantifierKinds.greedy);\n  }\n  return createToken(TokenTypes.Quantifier, raw, data);\n}\n\nfunction createTokenForShorthandCharClass(raw) {\n  const lower = raw[1].toLowerCase();\n  return createToken(TokenTypes.CharacterSet, raw, {\n    kind: {\n      'd': TokenCharacterSetKinds.digit,\n      'h': TokenCharacterSetKinds.hex,\n      's': TokenCharacterSetKinds.space,\n      'w': TokenCharacterSetKinds.word,\n    }[lower],\n    negate: raw[1] !== lower,\n  });\n}\n\nfunction createTokenForUnicodeProperty(raw) {\n  const {p, neg, value} = /^\\\\(?<p>[pP])\\{(?<neg>\\^?)(?<value>[^}]+)/.exec(raw).groups;\n  const negate = (p === 'P' && !neg) || (p === 'p' && !!neg);\n  return createToken(TokenTypes.CharacterSet, raw, {\n    kind: TokenCharacterSetKinds.property,\n    value,\n    negate,\n  });\n}\n\n/**\n@typedef {{\n  ignoreCase?: true;\n  dotAll?: true;\n  extended?: true;\n}} FlagGroupSwitches\n*/\n/**\n@param {string} flags\n@returns {FlagGroupSwitches?}\n*/\nfunction getFlagGroupSwitches(flags) {\n  // Don't include `false` for flags that aren't included\n  const obj = {};\n  if (flags.includes('i')) {\n    obj.ignoreCase = true;\n  }\n  if (flags.includes('m')) {\n    // Onig flag m is equivalent to JS flag s\n    obj.dotAll = true;\n  }\n  if (flags.includes('x')) {\n    obj.extended = true;\n  }\n  return Object.keys(obj).length ? obj : null;\n}\n\nfunction getFlagsObj(flags) {\n  if (!/^[imxDPSW]*$/.test(flags)) {\n    throw new Error(`Flags \"${flags}\" includes unsupported value`);\n  }\n  const flagsObj = {\n    ignoreCase: false,\n    dotAll: false,\n    extended: false,\n    digitIsAscii: false,\n    posixIsAscii: false,\n    spaceIsAscii: false,\n    wordIsAscii: false,\n  };\n  for (const char of flags) {\n    flagsObj[{\n      i: 'ignoreCase',\n      // Flag m is called `multiline` in Onig, but that has a different meaning in JS. Onig flag m\n      // is equivalent to JS flag s\n      m: 'dotAll',\n      // Flag x is fully handled during tokenization\n      x: 'extended',\n      // Flags D, P, S, W are currently only supported as top-level flags\n      D: 'digitIsAscii',\n      P: 'posixIsAscii',\n      S: 'spaceIsAscii',\n      W: 'wordIsAscii',\n    }[char]] = true;\n  }\n  return flagsObj;\n}\n\n// - Unenclosed `\\xNN` above 0x7F is handled elsewhere as a UTF-8 encoded byte sequence\n// - Enclosed `\\x{}` with value above 0x10FFFF is allowed here; handled in the parser\nfunction getValidatedHexCharCode(raw) {\n  // Note: Onig (tested 6.9.8) has a bug where bare `\\u` and `\\x` are identity escapes if they\n  // appear at the very end of the pattern, so e.g. `\\u` matches `u`, but `\\u0`, `\\u.`, and `[\\u]`\n  // are all errors, and `\\x.` and `[\\x]` aren't errors but instead the `\\x` is equivalent to `\\0`.\n  // Don't emulate these bugs (see #21), and just treat these cases as errors. Also, Onig treats\n  // incomplete `\\x{` (with the brace and not immediately followed by a hex digit) as an identity\n  // escape, so e.g. `\\x{` matches `x{` and `^\\x{,2}$` matches `xx`, but `\\x{2,}` and `\\x{0,2}` are\n  // errors. Don't emulate this pointless ambiguity; just treat incomplete `\\x{` as an error\n  if (/^(?:\\\\u(?!\\p{AHex}{4})|\\\\x(?!\\p{AHex}{1,2}|\\{\\p{AHex}{1,8}\\}))/u.test(raw)) {\n    throw new Error(`Incomplete or invalid escape \"${raw}\"`);\n  }\n  // Might include leading 0s\n  const hex = raw[2] === '{' ?\n    /^\\\\x\\{\\s*(?<hex>\\p{AHex}+)/u.exec(raw).groups.hex :\n    raw.slice(2);\n  const dec = parseInt(hex, 16);\n  return dec;\n}\n\n// Value is 1-3 digits, which can be a backref (possibly invalid), null, octal, or identity escape,\n// possibly followed by 1-2 literal digits\nfunction splitEscapedNumToken(token, numCaptures) {\n  const {raw, inCharClass} = token;\n  // Keep any leading 0s since they indicate octal\n  const value = raw.slice(1);\n  // Backref (possibly invalid)\n  if (\n    !inCharClass &&\n    ( // Single digit 1-9 outside a char class is always treated as a backref\n      (value !== '0' && value.length === 1) ||\n      // Leading 0 makes it octal; backrefs can't include following literal digits\n      (value[0] !== '0' && +value <= numCaptures)\n    )\n  ) {\n    return [createToken(TokenTypes.Backreference, raw)];\n  }\n  const tokens = [];\n  // Returns 1-3 matches; the first (only) might be octal\n  const matches = value.match(/^[0-7]+|\\d/g);\n  for (let i = 0; i < matches.length; i++) {\n    const m = matches[i];\n    let value;\n    // Octal digits are 0-7\n    if (i === 0 && m !== '8' && m !== '9') {\n      value = parseInt(m, 8);\n      if (value > 0o177) {\n        // Octal UTF-8 encoded byte sequence; not yet supported\n        throw new Error(r`Octal encoded byte above 177 unsupported \"${raw}\"`);\n      }\n    } else {\n      value = m.codePointAt(0);\n    }\n    tokens.push(createToken(TokenTypes.Character, (i === 0 ? '\\\\' : '') + m, {\n      value,\n    }));\n  }\n  return tokens;\n}\n\nfunction assertSingleCodePoint(raw) {\n  if ([...raw].length !== 1) {\n    throw new Error(`Expected \"${raw}\" to be a single code point`);\n  }\n}\n\nexport {\n  tokenize,\n  TokenCharacterSetKinds,\n  TokenDirectiveKinds,\n  TokenGroupKinds,\n  TokenQuantifierKinds,\n  TokenTypes,\n};\n"],
  "mappings": "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",
  "names": ["PosixClassNames", "r", "TokenTypes", "TokenCharacterSetKinds", "TokenDirectiveKinds", "TokenGroupKinds", "TokenQuantifierKinds", "EscapeCharCodes", "charClassOpenPattern", "sharedEscapesPattern", "quantifierRe", "tokenRe", "charClassTokenRe", "tokenize", "pattern", "options", "opts", "flagsObj", "getFlagsObj", "xStack", "context", "isXOn", "tokens", "match", "result", "getTokenWithDetails", "potentialUnnamedCaptureTokens", "numNamedAndOptInUnnamedCaptures", "t", "i", "numCaptures", "splitEscapedNumToken", "m", "lastIndex", "m0", "m1", "getAllTokensForCharClass", "createToken", "createTokenForSharedEscape", "createTokenForFlagMod", "token", "end", "re", "kind", "createTokenForQuantifier", "assertSingleCodePoint", "opener", "numCharClassesOpen", "createTokenForAnyTokenWithinCharClass", "raw", "posix", "inCharClass", "char1", "createTokenForControlChar", "createTokenForShorthandCharClass", "createTokenForUnicodeProperty", "bytes", "hex", "decoded", "encoder", "char", "byte", "getValidatedHexCharCode", "type", "data", "on", "off", "enabledFlags", "getFlagGroupSwitches", "disabledFlags", "flagChanges", "min", "max", "limit", "lower", "p", "neg", "value", "negate", "flags", "obj", "matches"]
}
